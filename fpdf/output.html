<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fpdf.output API documentation</title>
<meta name="description" content="This module contains the serialization logic that produces a PDF document from a FPDF instance.
Most of the code in this module is used when …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.output</code></h1>
</header>
<section id="section-intro">
<p>This module contains the serialization logic that produces a PDF document from a FPDF instance.
Most of the code in this module is used when FPDF.output() is called.</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.output.soft_mask_path_to_xobject"><code class="name flex">
<span>def <span class="ident">soft_mask_path_to_xobject</span></span>(<span>path,<br>resource_catalog: <a title="fpdf.output.ResourceCatalog" href="#fpdf.output.ResourceCatalog">ResourceCatalog</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L1932-L1940" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def soft_mask_path_to_xobject(path, resource_catalog: ResourceCatalog):
    &#34;&#34;&#34;Converts a PaintedSoftMask into a PDF XObject Form suitable for use as a soft mask.&#34;&#34;&#34;
    xobject = PDFContentStream(contents=path.render(resource_catalog))
    xobject._path = path
    xobject.type = Name(&#34;XObject&#34;)
    xobject.subtype = Name(&#34;Form&#34;)
    xobject.b_box = PDFArray(path.get_bounding_box())
    xobject.group = &#34;&lt;&lt;/S /Transparency /CS /DeviceGray /I true /K false&gt;&gt;&#34;
    return xobject</code></pre>
</details>
<div class="desc"><p>Converts a PaintedSoftMask into a PDF XObject Form suitable for use as a soft mask.</p></div>
</dd>
<dt id="fpdf.output.stream_content_for_raster_image"><code class="name flex">
<span>def <span class="ident">stream_content_for_raster_image</span></span>(<span>info: <a title="fpdf.image_datastructures.RasterImageInfo" href="image_datastructures.html#fpdf.image_datastructures.RasterImageInfo">RasterImageInfo</a>,<br>x,<br>y,<br>w,<br>h,<br>keep_aspect_ratio=False,<br>scale=1,<br>pdf_height_to_flip=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L1825-L1847" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def stream_content_for_raster_image(
    info: RasterImageInfo,
    x,
    y,
    w,
    h,
    keep_aspect_ratio=False,
    scale=1,
    pdf_height_to_flip=None,
):
    if keep_aspect_ratio:
        x, y, w, h = info.scale_inside_box(x, y, w, h)
    if pdf_height_to_flip:
        stream_h = h
        stream_y = pdf_height_to_flip - h - y
    else:
        stream_h = -h
        stream_y = y + h
    return (
        f&#34;q {w * scale:.2f} 0 0 {stream_h * scale:.2f}&#34;
        f&#34; {x * scale:.2f} {stream_y * scale:.2f} cm&#34;
        f&#34; /I{info[&#39;i&#39;]} Do Q&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.output.AcroForm"><code class="flex name class">
<span>class <span class="ident">AcroForm</span></span>
<span>(</span><span>fields, sig_flags)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L226-L237" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class AcroForm:
    def __init__(self, fields, sig_flags):
        self.fields = fields
        self.sig_flags = sig_flags

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict, field_join=&#34; &#34;)</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.AcroForm.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L231-L237" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, _security_handler=None, _obj_id=None):
    obj_dict = build_obj_dict(
        {key: getattr(self, key) for key in dir(self)},
        _security_handler=_security_handler,
        _obj_id=_obj_id,
    )
    return pdf_dict(obj_dict, field_join=&#34; &#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.CIDSystemInfo"><code class="flex name class">
<span>class <span class="ident">CIDSystemInfo</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L104-L109" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CIDSystemInfo(PDFObject):
    def __init__(self):
        super().__init__()
        self.registry = PDFString(&#34;Adobe&#34;, encrypt=True)
        self.ordering = PDFString(&#34;UCS&#34;, encrypt=True)
        self.supplement = 0</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.CIDSystemInfo.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.CIDSystemInfo.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.ContentWithoutID"><code class="flex name class">
<span>class <span class="ident">ContentWithoutID</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L64-L66" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class ContentWithoutID:
    def serialize(self, _security_handler=None):
        pass</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.linearization.PDFXrefAndTrailer" href="linearization.html#fpdf.linearization.PDFXrefAndTrailer">PDFXrefAndTrailer</a></li>
<li><a title="fpdf.output.PDFHeader" href="#fpdf.output.PDFHeader">PDFHeader</a></li>
<li><a title="fpdf.output.PDFXrefAndTrailer" href="#fpdf.output.PDFXrefAndTrailer">PDFXrefAndTrailer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.ContentWithoutID.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L65-L66" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, _security_handler=None):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.OutputIntentDictionary"><code class="flex name class">
<span>class <span class="ident">OutputIntentDictionary</span></span>
<span>(</span><span>subtype: OutputIntentSubType | str,<br>output_condition_identifier: str,<br>output_condition: str = None,<br>registry_name: str = None,<br>dest_output_profile: <a title="fpdf.output.PDFICCProfile" href="#fpdf.output.PDFICCProfile">PDFICCProfile</a> = None,<br>info: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"><p>The optional OutputIntents (PDF 1.4) entry in the document
catalog dictionary holds an array of output intent dictionaries,
each describing the colour reproduction characteristics of a possible
output device.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subtype</code></strong> :&ensp;<code>OutputIntentSubType, required</code></dt>
<dd>PDFA, PDFX or ISOPDF</dd>
<dt><strong><code>output_condition_identifier</code></strong> :&ensp;<code>str, required</code></dt>
<dd>see the Name in
<a href="https://www.color.org/registry.xalter">https://www.color.org/registry.xalter</a></dd>
<dt><strong><code>output_condition</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>see the Definition in
<a href="https://www.color.org/registry.xalter">https://www.color.org/registry.xalter</a></dd>
<dt><strong><code>registry_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>"https://www.color.org"</dd>
</dl>
<p>dest_output_profile (PDFICCProfile, required/optional):
PDFICCProfile | None # (required if
output_condition_identifier does not specify a standard
production condition; optional otherwise)
info (str, required/optional see dest_output_profile): human
readable description of profile</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.output.OutputIntentDictionary.dest_output_profile"><code class="name">var <span class="ident">dest_output_profile</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.OutputIntentDictionary.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.OutputIntentDictionary.output_condition"><code class="name">var <span class="ident">output_condition</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.OutputIntentDictionary.output_condition_identifier"><code class="name">var <span class="ident">output_condition_identifier</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.OutputIntentDictionary.registry_name"><code class="name">var <span class="ident">registry_name</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.OutputIntentDictionary.s"><code class="name">var <span class="ident">s</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.OutputIntentDictionary.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L567-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputIntentDictionary:
    &#34;&#34;&#34;
    The optional OutputIntents (PDF 1.4) entry in the document
    catalog dictionary holds an array of output intent dictionaries,
    each describing the colour reproduction characteristics of a possible
    output device.

    Args:
        subtype (OutputIntentSubType, required): PDFA, PDFX or ISOPDF
        output_condition_identifier (str, required): see the Name in
            https://www.color.org/registry.xalter
        output_condition (str, optional): see the Definition in
            https://www.color.org/registry.xalter
        registry_name (str, optional): &#34;https://www.color.org&#34;
        dest_output_profile (PDFICCProfile, required/optional):
            PDFICCProfile | None # (required if
            output_condition_identifier does not specify a standard
            production condition; optional otherwise)
        info (str, required/optional see dest_output_profile): human
            readable description of profile
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;type&#34;,
        &#34;s&#34;,
        &#34;output_condition_identifier&#34;,
        &#34;output_condition&#34;,
        &#34;registry_name&#34;,
        &#34;dest_output_profile&#34;,
        &#34;info&#34;,
    )

    def __init__(
        self,
        subtype: &#34;OutputIntentSubType | str&#34;,
        output_condition_identifier: str,
        output_condition: str = None,
        registry_name: str = None,
        dest_output_profile: PDFICCProfile = None,
        info: str = None,
    ):
        self.type = Name(&#34;OutputIntent&#34;)
        self.s = Name(OutputIntentSubType.coerce(subtype).value)
        self.output_condition_identifier = (
            PDFString(output_condition_identifier)
            if output_condition_identifier
            else None
        )
        self.output_condition = (
            PDFString(output_condition) if output_condition else None
        )
        self.registry_name = PDFString(registry_name) if registry_name else None
        self.dest_output_profile = (
            dest_output_profile
            if dest_output_profile and isinstance(dest_output_profile, PDFICCProfile)
            else None
        )
        self.info = PDFString(info) if info else None

    def serialize(self, _security_handler=None, _obj_id=None):
        obj_dict = build_obj_dict(
            {key: getattr(self, key) for key in dir(self)},
            _security_handler=_security_handler,
            _obj_id=_obj_id,
        )
        return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.OutputIntentDictionary.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L626-L632" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, _security_handler=None, _obj_id=None):
    obj_dict = build_obj_dict(
        {key: getattr(self, key) for key in dir(self)},
        _security_handler=_security_handler,
        _obj_id=_obj_id,
    )
    return pdf_dict(obj_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.OutputProducer"><code class="flex name class">
<span>class <span class="ident">OutputProducer</span></span>
<span>(</span><span>fpdf: FPDF)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L830-L1822" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class OutputProducer:
    &#34;Generates the final bytearray representing the PDF document, based on a FPDF instance.&#34;

    def __init__(self, fpdf: &#34;FPDF&#34;):
        self.fpdf = fpdf
        self.pdf_objs = []
        self.iccp_i_to_pdf_i = {}
        self.obj_id = (
            fpdf._resource_catalog.last_reserved_object_id
        )  # current PDF object number
        # array of PDF object offsets in self.buffer, used to build the xref table:
        self.offsets = {}
        self.trace_labels_per_obj_id = {}
        self.sections_size_per_trace_label = defaultdict(int)
        self.buffer = bytearray()  # resulting output buffer

    def bufferize(self):
        &#34;&#34;&#34;
        This method alters the target FPDF instance
        by assigning IDs to all PDF objects,
        plus a few other properties on PDFPage instances
        &#34;&#34;&#34;
        fpdf = self.fpdf

        # 1. Setup - Insert all PDF objects
        #    and assign unique consecutive numeric IDs to all of them

        if fpdf._security_handler:
            # get the file_id and generate passwords needed to encrypt streams and strings
            file_id = fpdf.file_id()
            if file_id == -1:
                # no custom file id - use default file id so encryption passwords can be generated
                file_id = fpdf._default_file_id(bytearray(0x00))
            fpdf._security_handler.generate_passwords(file_id)

        pdf_version = fpdf.pdf_version
        if (
            fpdf.viewer_preferences
            and fpdf.viewer_preferences._min_pdf_version &gt; pdf_version
        ):
            pdf_version = fpdf.viewer_preferences._min_pdf_version
        self.pdf_objs.append(PDFHeader(pdf_version))
        pages_root_obj = self._add_pages_root()
        catalog_obj = self._add_catalog()
        page_objs = self._add_pages()
        sig_annotation_obj = self._add_annotations_as_objects()
        for embedded_file in fpdf.embedded_files:
            self._add_pdf_obj(embedded_file, &#34;embedded_files&#34;)
            self._add_pdf_obj(embedded_file.file_spec(), &#34;file_spec&#34;)
        self._insert_resources(page_objs)
        struct_tree_root_obj = self._add_structure_tree()
        outline_dict_obj, outline_items = self._add_document_outline()
        xmp_metadata_obj = self._add_xmp_metadata()
        info_obj = None
        if not fpdf._compliance:
            info_obj = self._add_info()
        encryption_obj = self._add_encryption()

        xref = PDFXrefAndTrailer(self)
        self.pdf_objs.append(xref)

        # 2. Plumbing - Inject all PDF object references required:
        pages_root_obj.kids = PDFArray(page_objs)
        self._finalize_catalog(
            catalog_obj,
            pages_root_obj=pages_root_obj,
            first_page_obj=page_objs[0],
            sig_annotation_obj=sig_annotation_obj,
            xmp_metadata_obj=xmp_metadata_obj,
            struct_tree_root_obj=struct_tree_root_obj,
            outline_dict_obj=outline_dict_obj,
        )
        dests = []
        for page_obj in page_objs:
            page_obj.parent = pages_root_obj
            for annot in page_obj.annots:
                page_dests = []
                if annot.dest:
                    # Only add to page_dests if it&#39;s a Destination object (not a string/PDFString)
                    if hasattr(annot.dest, &#34;page_number&#34;):
                        page_dests.append(annot.dest)
                if annot.a and hasattr(annot.a, &#34;dest&#34;):
                    # Only add to page_dests if it&#39;s a Destination object (not a string/PDFString)
                    if hasattr(annot.a.dest, &#34;page_number&#34;):
                        page_dests.append(annot.a.dest)
                for dest in page_dests:
                    if dest.page_number &gt; len(page_objs):
                        raise ValueError(
                            f&#34;Invalid reference to non-existing page {dest.page_number} present on page {page_obj.index()}: &#34;
                        )
                dests.extend(page_dests)
            if not page_obj.annots:
                # Avoid serializing an empty PDFArray:
                page_obj.annots = None
        for outline_item in outline_items:
            dests.append(outline_item.dest)
        # Assigning the .page_ref property of all Destination objects:
        for dest in dests:
            dest.page_ref = pdf_ref(page_objs[dest.page_number - 1].id)
        for struct_elem in fpdf.struct_builder.doc_struct_elem.k:
            struct_elem.pg = page_objs[struct_elem.page_number() - 1]
        xref.catalog_obj = catalog_obj
        xref.info_obj = info_obj
        xref.encryption_obj = encryption_obj

        # 3. Serializing - Append all PDF objects to the buffer:
        assert (
            not self.buffer
        ), f&#34;Nothing should have been appended to the .buffer at this stage: {self.buffer}&#34;
        assert (
            not self.offsets
        ), f&#34;No offset should have been set at this stage: {len(self.offsets)}&#34;

        for pdf_obj in self.pdf_objs:
            if isinstance(pdf_obj, ContentWithoutID):
                # top header, xref table &amp; trailer:
                trace_label = None
            else:
                self.offsets[pdf_obj.id] = len(self.buffer)
                trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)
            if trace_label:
                with self._trace_size(trace_label):
                    self._out(
                        pdf_obj.serialize(_security_handler=fpdf._security_handler)
                    )
            else:
                self._out(pdf_obj.serialize(_security_handler=fpdf._security_handler))
        self._log_final_sections_sizes()

        if fpdf._sign_key:
            self.buffer = sign_content(
                signer,
                self.buffer,
                fpdf._sign_key,
                fpdf._sign_cert,
                fpdf._sign_extra_certs,
                fpdf._sign_hashalgo,
                fpdf._sign_time,
            )
        return self.buffer

    def _out(self, data):
        &#34;Append data to the buffer&#34;
        if not isinstance(data, bytes):
            if not isinstance(data, str):
                data = str(data)
            data = data.encode(&#34;latin1&#34;)
        self.buffer += data + b&#34;\n&#34;

    def _add_pdf_obj(self, pdf_obj, trace_label=None):
        self.obj_id += 1
        pdf_obj.id = self.obj_id
        self.pdf_objs.append(pdf_obj)
        if trace_label:
            self.trace_labels_per_obj_id[self.obj_id] = trace_label
        return self.obj_id

    def _add_pages_root(self):
        fpdf = self.fpdf
        pages_root_obj = PDFPagesRoot(
            count=fpdf.pages_count,
            media_box=_dimensions_to_mediabox(fpdf.default_page_dimensions),
        )
        self._add_pdf_obj(pages_root_obj)
        return pages_root_obj

    def _iter_pages_in_order(self):
        for page_index in range(1, self.fpdf.pages_count + 1):
            page_obj = self.fpdf.pages[page_index]
            # Defensive check:
            assert (
                page_obj.index() == page_index
            ), f&#34;{page_obj.index()=} != {page_index=}&#34;
            yield page_obj

    def _add_pages(self, _slice=slice(0, None)):
        fpdf = self.fpdf
        page_objs = []
        for page_obj in list(self._iter_pages_in_order())[_slice]:
            if fpdf.pdf_version &gt; &#34;1.3&#34; and fpdf.allow_images_transparency:
                page_obj.group = pdf_dict(
                    {&#34;/Type&#34;: &#34;/Group&#34;, &#34;/S&#34;: &#34;/Transparency&#34;, &#34;/CS&#34;: &#34;/DeviceRGB&#34;},
                    field_join=&#34; &#34;,
                )
            if page_obj.dimensions() != fpdf.default_page_dimensions:
                page_obj.media_box = _dimensions_to_mediabox(page_obj.dimensions())
            self._add_pdf_obj(page_obj, &#34;pages&#34;)
            page_objs.append(page_obj)

            # Extracting the page contents to insert it as a content stream:
            cs_obj = PDFContentStream(
                contents=page_obj.contents, compress=fpdf.compress
            )
            self._add_pdf_obj(cs_obj, &#34;pages&#34;)
            page_obj.contents = cs_obj

        return page_objs

    def _add_annotations_as_objects(self):
        sig_annotation_obj = None
        for page_obj in self.fpdf.pages.values():
            for annot_obj in page_obj.annots:
                if isinstance(annot_obj, PDFAnnotation):  # distinct from AnnotationDict
                    self._add_pdf_obj(annot_obj)
                    if isinstance(annot_obj.v, Signature):
                        assert (
                            sig_annotation_obj is None
                        ), &#34;A /Sig annotation is present on more than 1 page&#34;
                        sig_annotation_obj = annot_obj
        return sig_annotation_obj

    def _add_fonts(
        self, image_objects_per_index, gfxstate_objs_per_name, pattern_objs_per_name
    ):
        font_objs_per_index = {}
        for font in sorted(self.fpdf.fonts.values(), key=lambda font: font.i):

            # type 3 font
            if font.type == &#34;TTF&#34; and font.color_font:
                if font.subset._next &gt; 0xFF:
                    raise FPDFException(
                        &#34;Type 3 fonts with color glyphs are not supported is more than 255 glyphs are rendered. &#34;
                        &#34;Set FPDF.render_color_fonts=False or use less color glyphs.&#34;
                    )
                for glyph in font.color_font.glyphs:
                    glyph.obj_id = self._add_pdf_obj(
                        PDFContentStream(contents=glyph.glyph, compress=False), &#34;fonts&#34;
                    )
                bfChar = []

                for glyph, code_mapped in font.subset.items():
                    if len(glyph.unicode) == 0:
                        continue
                    bfChar.append(
                        f&#39;&lt;{code_mapped:02X}&gt; &lt;{&#34;&#34;.join(chr(code).encode(&#34;utf-16-be&#34;).hex().upper() for code in glyph.unicode)}&gt;\n&#39;
                    )

                to_unicode_obj = PDFContentStream(
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;00&gt; &lt;FF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    f&#34;{len(bfChar)} beginbfchar\n&#34;
                    f&#34;{&#39;&#39;.join(bfChar)}&#34;
                    &#34;endbfchar\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._add_pdf_obj(to_unicode_obj, &#34;fonts&#34;)

                t3_font_obj = PDFType3Font(font.color_font)
                t3_font_obj.to_unicode = pdf_ref(to_unicode_obj.id)
                t3_font_obj.generate_resources(
                    image_objects_per_index,
                    gfxstate_objs_per_name,
                    pattern_objs_per_name,
                )
                self._add_pdf_obj(t3_font_obj, &#34;fonts&#34;)
                font_objs_per_index[font.i] = t3_font_obj
                continue

            # Standard font
            if font.type == &#34;core&#34;:
                encoding = (
                    &#34;WinAnsiEncoding&#34;
                    if font.name not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;)
                    else None
                )
                core_font_obj = PDFFont(
                    subtype=&#34;Type1&#34;, base_font=font.name, encoding=encoding
                )
                self._add_pdf_obj(core_font_obj, &#34;fonts&#34;)
                font_objs_per_index[font.i] = core_font_obj
            elif font.type == &#34;TTF&#34;:
                fontname = f&#34;MPDFAA+{font.name}&#34;

                # 1. get all glyphs in PDF
                glyph_names = font.subset.get_all_glyph_names()

                if len(font.missing_glyphs) &gt; 0:
                    msg = &#34;, &#34;.join(
                        f&#34;&#39;{chr(x)}&#39; ({chr(x).encode(&#39;unicode-escape&#39;).decode()})&#34;
                        for x in font.missing_glyphs[:10]
                    )
                    if len(font.missing_glyphs) &gt; 10:
                        msg += f&#34;, ... (and {len(font.missing_glyphs) - 10} others)&#34;
                    LOGGER.warning(
                        &#34;Font %s is missing the following glyphs: %s&#34;, fontname, msg
                    )

                # 2. make a subset
                # notdef_outline=True means that keeps the white box for the .notdef glyph
                # recommended_glyphs=True means that adds the .notdef, .null, CR, and space glyphs
                options = ftsubset.Options(notdef_outline=True, recommended_glyphs=True)
                # dropping some tables that currently not used:
                options.drop_tables += [
                    &#34;FFTM&#34;,  # FontForge Timestamp table - cf. https://github.com/py-pdf/fpdf2/issues/600
                    &#34;GDEF&#34;,  # Glyph Definition table = various glyph properties used in OpenType layout processing
                    &#34;GPOS&#34;,  # Glyph Positioning table = precise control over glyph placement
                    #          for sophisticated text layout and rendering in each script and language system
                    &#34;GSUB&#34;,  # Glyph Substitution table = data for substitution of glyphs for appropriate rendering of scripts
                    &#34;MATH&#34;,  # Mathematical typesetting table = specific information necessary for math formula layout
                    &#34;hdmx&#34;,  # Horizontal Device Metrics table, stores integer advance widths scaled to particular pixel sizes
                    #          for OpenType™ fonts with TrueType outlines
                    &#34;meta&#34;,  # metadata table
                    &#34;sbix&#34;,  # Apple&#39;s SBIX table, used for color bitmap glyphs
                    &#34;CBDT&#34;,  # Color Bitmap Data Table
                    &#34;CBLC&#34;,  # Color Bitmap Location Table
                    &#34;EBDT&#34;,  # Embedded Bitmap Data Table
                    &#34;EBLC&#34;,  # Embedded Bitmap Location Table
                    &#34;EBSC&#34;,  # Embedded Bitmap Scaling Table
                    &#34;SVG &#34;,  # SVG table
                    &#34;CPAL&#34;,  # Color Palette table
                    &#34;COLR&#34;,  # Color table
                ]
                subsetter = ftsubset.Subsetter(options)
                subsetter.populate(glyphs=glyph_names)
                subsetter.subset(font.ttfont)

                # 3. make codeToGlyph
                # is a map Character_ID -&gt; Glyph_ID
                # it&#39;s used for associating glyphs to new codes
                # this basically takes the old code of the character
                # take the glyph associated with it
                # and then associate to the new code the glyph associated with the old code

                code_to_glyph = {
                    char_id: font.ttfont.getGlyphID(glyph.glyph_name)
                    for glyph, char_id in font.subset.items()
                }

                # 4. return the ttfile
                output = BytesIO()
                font.ttfont.save(output)

                output.seek(0)
                ttfontstream = output.read()

                # A composite font - a font composed of other fonts,
                # organized hierarchically
                composite_font_obj = PDFFont(
                    subtype=&#34;Type0&#34;, base_font=fontname, encoding=&#34;Identity-H&#34;
                )
                self._add_pdf_obj(composite_font_obj, &#34;fonts&#34;)
                font_objs_per_index[font.i] = composite_font_obj

                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                cid_font_obj = PDFFont(
                    subtype=&#34;CIDFontType2&#34;,
                    base_font=fontname,
                    d_w=font.desc.missing_width,
                    w=_tt_font_widths(font),
                )
                self._add_pdf_obj(cid_font_obj, &#34;fonts&#34;)
                composite_font_obj.descendant_fonts = PDFArray([cid_font_obj])

                # bfChar
                # This table informs the PDF reader about the unicode
                # character that each used 16-bit code belongs to. It
                # allows searching the file and copying text from it.
                bfChar = []

                def format_code(unicode):
                    if unicode &gt; 0xFFFF:
                        # Calculate surrogate pair
                        code_high = 0xD800 | (unicode - 0x10000) &gt;&gt; 10
                        code_low = 0xDC00 | (unicode &amp; 0x3FF)
                        return f&#34;{code_high:04X}{code_low:04X}&#34;
                    return f&#34;{unicode:04X}&#34;

                for glyph, code_mapped in font.subset.items():
                    if len(glyph.unicode) == 0:
                        continue
                    bfChar.append(
                        f&#39;&lt;{code_mapped:04X}&gt; &lt;{&#34;&#34;.join(format_code(code) for code in glyph.unicode)}&gt;\n&#39;
                    )

                to_unicode_obj = PDFContentStream(
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    f&#34;{len(bfChar)} beginbfchar\n&#34;
                    f&#34;{&#39;&#39;.join(bfChar)}&#34;
                    &#34;endbfchar\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._add_pdf_obj(to_unicode_obj, &#34;fonts&#34;)
                composite_font_obj.to_unicode = to_unicode_obj

                cid_system_info_obj = CIDSystemInfo()
                self._add_pdf_obj(cid_system_info_obj, &#34;fonts&#34;)
                cid_font_obj.c_i_d_system_info = cid_system_info_obj

                font_descriptor_obj = font.desc
                font_descriptor_obj.font_name = Name(fontname)
                self._add_pdf_obj(font_descriptor_obj, &#34;fonts&#34;)
                cid_font_obj.font_descriptor = font_descriptor_obj

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cid_to_gid_map = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in code_to_glyph.items():
                    cid_to_gid_map[cc * 2] = chr(glyph &gt;&gt; 8)
                    cid_to_gid_map[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cid_to_gid_map = &#34;&#34;.join(cid_to_gid_map)

                # manage binary data as latin1 until PEP461-like function is implemented
                cid_to_gid_map_obj = PDFContentStream(
                    contents=cid_to_gid_map.encode(&#34;latin1&#34;), compress=True
                )
                self._add_pdf_obj(cid_to_gid_map_obj, &#34;fonts&#34;)
                cid_font_obj.c_i_d_to_g_i_d_map = cid_to_gid_map_obj

                font_file_cs_obj = PDFFontStream(contents=ttfontstream)
                self._add_pdf_obj(font_file_cs_obj, &#34;fonts&#34;)
                font_descriptor_obj.font_file2 = font_file_cs_obj

                font.subset.pick.cache_clear()
                font.subset.get_glyph.cache_clear()
                font.close()

        return font_objs_per_index

    def _add_images(self):
        img_objs_per_index = {}
        for img in sorted(
            self.fpdf.image_cache.images.values(), key=lambda img: img[&#34;i&#34;]
        ):
            if img[&#34;usages&#34;] &gt; 0:
                img_objs_per_index[img[&#34;i&#34;]] = self._add_image(img)
        return img_objs_per_index

    def _ensure_iccp(self, img_info):
        &#34;&#34;&#34;
        Returns the PDF object of the ICC profile indexed iccp_i in the FPDF object.
        Adds it if not present.
        &#34;&#34;&#34;
        iccp_i = img_info[&#34;iccp_i&#34;]
        if iccp_i in self.iccp_i_to_pdf_i:
            return self.iccp_i_to_pdf_i[iccp_i]
        iccp_content = None
        for iccp_c, i in self.fpdf.image_cache.icc_profiles.items():
            if iccp_i == i:
                iccp_content = iccp_c
                break
        assert iccp_content is not None
        # Note: n should be 4 if the profile ColorSpace is CMYK
        iccp_obj = PDFICCProfile(
            contents=iccp_content, n=img_info[&#34;dpn&#34;], alternate=img_info[&#34;cs&#34;]
        )
        iccp_pdf_i = self._add_pdf_obj(iccp_obj, &#34;iccp&#34;)
        self.iccp_i_to_pdf_i[iccp_i] = iccp_pdf_i
        return iccp_pdf_i

    def _add_image(self, info):
        color_space = Name(info[&#34;cs&#34;])
        decode = None
        iccp_i = info.get(&#34;iccp_i&#34;)
        if color_space == &#34;Indexed&#34;:
            color_space = PDFArray(
                [&#34;/Indexed&#34;, &#34;/DeviceRGB&#34;, f&#34;{len(info[&#39;pal&#39;]) // 3 - 1}&#34;]
            )
        elif iccp_i is not None:
            iccp_pdf_i = self._ensure_iccp(info)
            color_space = PDFArray([&#34;/ICCBased&#34;, str(iccp_pdf_i), str(&#34;0&#34;), &#34;R&#34;])
        elif color_space == &#34;DeviceCMYK&#34;:
            if info[&#34;inverted&#34;] is True:
                decode = &#34;[1 0 1 0 1 0 1 0]&#34;

        decode_parms = f&#34;&lt;&lt;{info[&#39;dp&#39;]} /BitsPerComponent {info[&#39;bpc&#39;]}&gt;&gt;&#34;
        img_obj = PDFXObject(
            subtype=&#34;Image&#34;,
            contents=info[&#34;data&#34;],
            width=info[&#34;w&#34;],
            height=info[&#34;h&#34;],
            color_space=color_space,
            bits_per_component=info[&#34;bpc&#34;],
            img_filter=info[&#34;f&#34;],
            decode=decode,
            decode_parms=decode_parms,
        )
        info[&#34;obj_id&#34;] = self._add_pdf_obj(img_obj, &#34;images&#34;)

        # Soft mask
        if self.fpdf.allow_images_transparency and &#34;smask&#34; in info:
            dp = f&#34;/Predictor 15 /Colors 1 /Columns {info[&#39;w&#39;]}&#34;
            img_obj.s_mask = self._add_image(
                {
                    &#34;w&#34;: info[&#34;w&#34;],
                    &#34;h&#34;: info[&#34;h&#34;],
                    &#34;cs&#34;: &#34;DeviceGray&#34;,
                    &#34;bpc&#34;: 8,
                    &#34;f&#34;: info[&#34;f&#34;],
                    &#34;dp&#34;: dp,
                    &#34;data&#34;: info[&#34;smask&#34;],
                }
            )

        # Palette
        if &#34;/Indexed&#34; in color_space:
            pal_cs_obj = PDFContentStream(
                contents=info[&#34;pal&#34;], compress=self.fpdf.compress
            )
            self._add_pdf_obj(pal_cs_obj, &#34;images&#34;)
            img_obj.color_space.append(pdf_ref(pal_cs_obj.id))

        return img_obj

    def _add_gfxstates(self):
        gfxstate_objs_per_name = OrderedDict()
        for state_dict, name in self.fpdf._resource_catalog.graphics_styles.items():
            gfxstate_obj = PDFExtGState(state_dict)
            self._add_pdf_obj(gfxstate_obj, &#34;gfxstate&#34;)
            gfxstate_objs_per_name[name] = gfxstate_obj
        return gfxstate_objs_per_name

    def _add_soft_masks(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Append soft-mask Form XObjects after patterns exist so we can resolve /Pattern ids.&#34;&#34;&#34;
        for soft_mask in self.fpdf._resource_catalog.soft_mask_xobjects:
            soft_mask.resources = soft_mask._path.get_resource_dictionary(
                gfxstate_objs_per_name, pattern_objs_per_name
            )
            self.pdf_objs.append(soft_mask)

    def _add_shadings(self):
        shading_objs_per_name = OrderedDict()
        for shading, name in self.fpdf._resource_catalog.get_items(
            PDFResourceType.SHADING
        ):
            for function in shading.get_functions():
                self._add_pdf_obj(function, &#34;function&#34;)
            shading_obj = shading.get_shading_object()
            self._add_pdf_obj(shading_obj, &#34;shading&#34;)
            shading_objs_per_name[name] = shading_obj
        return shading_objs_per_name

    def _add_patterns(self):
        pattern_objs_per_name = OrderedDict()
        for pattern, name in self.fpdf._resource_catalog.get_items(
            PDFResourceType.PATTERN
        ):
            self._add_pdf_obj(pattern, &#34;pattern&#34;)
            pattern_objs_per_name[name] = pattern
            if pattern.get_apply_page_ctm():
                pattern.set_matrix(
                    pattern.get_matrix()
                    @ Transform.translation(0, -self.fpdf.h)
                    .scale(x=1, y=-1)
                    .scale(self.fpdf.k)
                )

        return pattern_objs_per_name

    def _insert_resources(self, page_objs):
        img_objs_per_index = self._add_images()
        gfxstate_objs_per_name = self._add_gfxstates()
        pattern_objs_per_name = self._add_patterns()
        font_objs_per_index = self._add_fonts(
            img_objs_per_index, gfxstate_objs_per_name, pattern_objs_per_name
        )
        shading_objs_per_name = self._add_shadings()
        self._add_soft_masks(gfxstate_objs_per_name, pattern_objs_per_name)
        # Insert /Resources dicts:
        if self.fpdf.single_resources_object:
            resources_dict_obj = self._add_resources_dict(
                font_objs_per_index,
                img_objs_per_index,
                gfxstate_objs_per_name,
                shading_objs_per_name,
                pattern_objs_per_name,
            )
            for page_obj in page_objs:
                page_obj.resources = resources_dict_obj
        else:
            for page_number, page_obj in enumerate(page_objs, start=1):
                page_font_objs_per_index = {
                    font_id: font_objs_per_index[font_id]
                    for font_id in self.fpdf._resource_catalog.get_resources_per_page(
                        page_number, PDFResourceType.FONT
                    )
                }
                page_img_objs_per_index = {
                    img_id: img_objs_per_index[img_id]
                    for img_id in self.fpdf._resource_catalog.get_resources_per_page(
                        page_number, PDFResourceType.X_OBJECT
                    )
                }
                page_gfxstate_objs_per_name = {
                    gfx_name: gfx_state
                    for (gfx_name, gfx_state) in gfxstate_objs_per_name.items()
                    if gfx_name
                    in self.fpdf._resource_catalog.get_resources_per_page(
                        page_number, PDFResourceType.EXT_G_STATE
                    )
                }
                page_shading_objs_per_name = {
                    shading_name: shading_objs_per_name[shading_name]
                    for shading_name in self.fpdf._resource_catalog.get_resources_per_page(
                        page_number, PDFResourceType.SHADING
                    )
                }
                page_pattern_objs_per_name = {
                    pattern_name: pattern_objs_per_name[pattern_name]
                    for pattern_name in self.fpdf._resource_catalog.get_resources_per_page(
                        page_number, PDFResourceType.PATTERN
                    )
                }
                page_obj.resources = self._add_resources_dict(
                    page_font_objs_per_index,
                    page_img_objs_per_index,
                    page_gfxstate_objs_per_name,
                    page_shading_objs_per_name,
                    page_pattern_objs_per_name,
                )

    def _add_resources_dict(
        self,
        font_objs_per_index,
        img_objs_per_index,
        gfxstate_objs_per_name,
        shading_objs_per_name,
        pattern_objs_per_name,
    ):
        # From section 10.1, &#34;Procedure Sets&#34;, of PDF 1.7 spec:
        # &gt; Beginning with PDF 1.4, this feature is considered obsolete.
        # &gt; For compatibility with existing consumer applications,
        # &gt; PDF producer applications should continue to specify procedure sets
        # &gt; (preferably, all of those listed in Table 10.1).
        proc_set = &#34;[/PDF /Text /ImageB /ImageC /ImageI]&#34;
        font, x_object, ext_g_state, shading, pattern = None, None, None, None, None

        if font_objs_per_index:
            font = pdf_dict(
                {
                    f&#34;/F{index}&#34;: pdf_ref(font_obj.id)
                    for index, font_obj in sorted(font_objs_per_index.items())
                }
            )

        if img_objs_per_index:
            x_object = pdf_dict(
                {
                    f&#34;/I{index}&#34;: pdf_ref(img_obj.id)
                    for index, img_obj in sorted(img_objs_per_index.items())
                }
            )

        if gfxstate_objs_per_name:
            ext_g_state = pdf_dict(
                {
                    f&#34;/{name}&#34;: pdf_ref(gfxstate_obj.id)
                    for name, gfxstate_obj in gfxstate_objs_per_name.items()
                }
            )
        if shading_objs_per_name:
            shading = pdf_dict(
                {
                    f&#34;/{name}&#34;: pdf_ref(shading_obj.id)
                    for name, shading_obj in sorted(shading_objs_per_name.items())
                }
            )

        if pattern_objs_per_name:
            pattern = pdf_dict(
                {
                    f&#34;/{name}&#34;: pdf_ref(pattern_obj.id)
                    for name, pattern_obj in sorted(pattern_objs_per_name.items())
                }
            )

        resources_obj = PDFResources(
            proc_set=proc_set,
            font=font,
            x_object=x_object,
            ext_g_state=ext_g_state,
            shading=shading,
            pattern=pattern,
        )
        self._add_pdf_obj(resources_obj)
        return resources_obj

    def _add_structure_tree(self):
        &#34;Builds a Structure Hierarchy, including image alternate descriptions&#34;
        if self.fpdf.struct_builder.empty():
            return None
        struct_tree_root_obj = None
        for pdf_obj in self.fpdf.struct_builder:
            if struct_tree_root_obj is None:
                struct_tree_root_obj = pdf_obj
            self._add_pdf_obj(pdf_obj, &#34;structure_tree&#34;)
        return struct_tree_root_obj

    def _add_document_outline(self):
        if not self.fpdf._outline:
            return None, ()
        outline_dict_obj, outline_items = None, []
        for pdf_obj in build_outline_objs(self.fpdf._outline):
            if outline_dict_obj is None:
                outline_dict_obj = pdf_obj
            else:
                outline_items.append(pdf_obj)
            self._add_pdf_obj(pdf_obj, &#34;document_outline&#34;)
        return outline_dict_obj, outline_items

    def _add_xmp_metadata(self):
        # Prefer explicitly provided XMP (user-supplied inner &lt;x:xmpmeta/&gt; without xpacket):
        xmp_src = self.fpdf.xmp_metadata
        # If not provided but a PDF/A document is being created, synthesize it:
        if not xmp_src and self.fpdf._compliance:
            xmp_src = self._build_xmp_from_info()
        if not xmp_src:
            return None
        xpacket = f&#39;&lt;?xpacket begin=&#34;{chr(0xFEFF)}&#34; id=&#34;W5M0MpCehiHzreSzNTczkc9d&#34;?&gt;\n{xmp_src}\n&lt;?xpacket end=&#34;w&#34;?&gt;\n&#39;
        pdf_obj = PDFXmpMetadata(xpacket)
        self._add_pdf_obj(pdf_obj)
        return pdf_obj

    def _build_xmp_from_info(self) -&gt; str:
        title = getattr(self.fpdf, &#34;title&#34;, None) or &#34;&#34;
        subject = getattr(self.fpdf, &#34;subject&#34;, None) or &#34;&#34;
        author = getattr(self.fpdf, &#34;author&#34;, None) or &#34;&#34;
        if author and isinstance(author, str):
            author = [author]
        keywords = getattr(self.fpdf, &#34;keywords&#34;, None) or &#34;&#34;
        if keywords and isinstance(keywords, str):
            keywords = [keywords]
        creator_tool = getattr(self.fpdf, &#34;creator&#34;, None) or &#34;&#34;
        producer = getattr(self.fpdf, &#34;producer&#34;, None) or &#34;&#34;
        cdate = getattr(self.fpdf, &#34;creation_date&#34;, None)
        creation_date_utc = None
        if isinstance(cdate, datetime):
            creation_date_utc = cdate if cdate.tzinfo else cdate.astimezone()
            creation_date_utc = creation_date_utc.astimezone(timezone.utc)
        pdfa = self.fpdf._compliance

        # Escape for XML attributes/PCDATA:
        def esc(s):
            &#34;&#34;&#34;Return XML-escaped text suitable for XMP (attributes or text nodes).&#34;&#34;&#34;
            value = &#34;&#34; if s is None else _html_escape(str(s), quote=True)
            return value.replace(&#34;&#39;&#34;, &#34;&amp;apos;&#34;)

        # XMP times are ISO 8601 (e.g., 2025-09-01T12:34:56+02:00):
        EPOCH = datetime(1969, 12, 31, 19, 0, 0, tzinfo=timezone.utc)
        now = datetime.now(timezone.utc)
        if creation_date_utc == EPOCH:
            xmp_create = EPOCH.isoformat(timespec=&#34;seconds&#34;)
            xmp_modify = EPOCH.isoformat(timespec=&#34;seconds&#34;)
        else:
            create_dt = creation_date_utc or now
            xmp_create = create_dt.isoformat(timespec=&#34;seconds&#34;)
            xmp_modify = now.isoformat(timespec=&#34;seconds&#34;)
        # Build a single Description that includes everything + pdfaid if requested:
        parts = [
            &#39;&lt;x:xmpmeta xmlns:x=&#34;adobe:ns:meta/&#34; x:xmptk=&#34;fpdf2&#34;&gt;&#39;,
            &#34;  &lt;rdf:RDF&#34;,
            &#39;    xmlns:rdf=&#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34;&#39;,
            &#39;    xmlns:dc=&#34;http://purl.org/dc/elements/1.1/&#34;&#39;,
            &#39;    xmlns:xmp=&#34;http://ns.adobe.com/xap/1.0/&#34;&#39;,
            &#39;    xmlns:pdf=&#34;http://ns.adobe.com/pdf/1.3/&#34;&#39;,
            &#39;    xmlns:pdfaid=&#34;http://www.aiim.org/pdfa/ns/id/&#34;&gt;&#39;,
            &#39;    &lt;rdf:Description rdf:about=&#34;&#34;&#39;,
        ]
        # attributes block (xmp, pdf, pdfaid)
        if creator_tool:
            parts.append(f&#39;        xmp:CreatorTool=&#34;{esc(creator_tool)}&#34;&#39;)
        if xmp_create:
            parts.append(f&#39;        xmp:CreateDate=&#34;{esc(xmp_create)}&#34;&#39;)
            parts.append(f&#39;        xmp:ModifyDate=&#34;{esc(xmp_modify)}&#34;&#39;)
            parts.append(f&#39;        xmp:MetadataDate=&#34;{esc(xmp_modify)}&#34;&#39;)
        if producer:
            parts.append(f&#39;        pdf:Producer=&#34;{esc(producer)}&#34;&#39;)
        if keywords:
            keyword_list = &#34;,&#34;.join(keywords)
            parts.append(f&#39;        pdf:Keywords=&#34;{esc(keyword_list)}&#34;&#39;)
        parts.append(&#34;      &gt;&#34;)
        # nested elements (Lang Alt / Seqs)
        if pdfa:
            parts.append(f&#34;      &lt;pdfaid:part&gt;{int(pdfa.part)}&lt;/pdfaid:part&gt;&#34;)
            if pdfa.conformance:
                parts.append(
                    f&#34;      &lt;pdfaid:conformance&gt;{esc(pdfa.conformance)}&lt;/pdfaid:conformance&gt;&#34;
                )
            if pdfa.part == 4:
                parts.append(&#34;      &lt;pdfaid:rev&gt;2020&lt;/pdfaid:rev&gt;&#34;)
        if title:
            parts += [
                &#34;      &lt;dc:title&gt;&lt;rdf:Alt&gt;&#34;,
                &#39;        &lt;rdf:li xml:lang=&#34;x-default&#34;&gt;&#39; + esc(title) + &#34;&lt;/rdf:li&gt;&#34;,
                &#34;      &lt;/rdf:Alt&gt;&lt;/dc:title&gt;&#34;,
            ]
        if subject:
            parts += [
                &#34;      &lt;dc:description&gt;&lt;rdf:Alt&gt;&#34;,
                &#39;        &lt;rdf:li xml:lang=&#34;x-default&#34;&gt;&#39; + esc(subject) + &#34;&lt;/rdf:li&gt;&#34;,
                &#34;      &lt;/rdf:Alt&gt;&lt;/dc:description&gt;&#34;,
            ]
        if author:
            parts.append(&#34;      &lt;dc:creator&gt;&lt;rdf:Seq&gt;&#34;)
            for a in author:
                parts.append(f&#34;        &lt;rdf:li&gt;{esc(a)}&lt;/rdf:li&gt;&#34;)
            parts.append(&#34;      &lt;/rdf:Seq&gt;&lt;/dc:creator&gt;&#34;)
        parts += [
            &#34;    &lt;/rdf:Description&gt;&#34;,
            &#34;  &lt;/rdf:RDF&gt;&#34;,
            &#34;&lt;/x:xmpmeta&gt;&#34;,
        ]
        return &#34;\n&#34;.join(parts)

    def _add_info(self):
        fpdf = self.fpdf
        creation_date = None
        if fpdf.creation_date:
            try:
                creation_date = PDFDate(fpdf.creation_date, with_tz=True, encrypt=True)
            except Exception as error:
                raise FPDFException(
                    f&#34;Could not format date: {fpdf.creation_date}&#34;
                ) from error
        info_obj = PDFInfo(
            title=fpdf.title,
            subject=getattr(fpdf, &#34;subject&#34;, None),
            author=getattr(fpdf, &#34;author&#34;, None),
            keywords=getattr(fpdf, &#34;keywords&#34;, None),
            creator=getattr(fpdf, &#34;creator&#34;, None),
            producer=getattr(fpdf, &#34;producer&#34;, None),
            creation_date=creation_date,
        )
        self._add_pdf_obj(info_obj)
        return info_obj

    def _add_encryption(self):
        if self.fpdf._security_handler:
            encryption_handler = self.fpdf._security_handler
            pdf_obj = encryption_handler.get_encryption_obj()
            self._add_pdf_obj(pdf_obj)
            return pdf_obj
        return None

    def _add_output_intents(self):
        &#34;&#34;&#34;should be added in _add_catalog&#34;&#34;&#34;
        output_intents = self.fpdf.output_intents
        if not output_intents:
            return None
        for output_intent in output_intents:
            if output_intent.dest_output_profile:
                self._add_pdf_obj(output_intent.dest_output_profile)
        return PDFArray(output_intents)

    def _add_catalog(self):
        fpdf = self.fpdf
        catalog_obj = PDFCatalog(
            lang=getattr(fpdf, &#34;lang&#34;, None),
            page_layout=fpdf.page_layout,
            page_mode=fpdf.page_mode,
            viewer_preferences=fpdf.viewer_preferences,
        )
        catalog_obj.output_intents = self._add_output_intents()

        self._add_pdf_obj(catalog_obj)
        return catalog_obj

    def _finalize_catalog(
        self,
        catalog_obj,
        pages_root_obj,
        first_page_obj,
        sig_annotation_obj,
        xmp_metadata_obj,
        struct_tree_root_obj,
        outline_dict_obj,
    ):
        fpdf = self.fpdf
        catalog_obj.pages = pages_root_obj
        catalog_obj.struct_tree_root = struct_tree_root_obj
        catalog_obj.outlines = outline_dict_obj
        catalog_obj.metadata = xmp_metadata_obj
        if sig_annotation_obj:
            flags = SignatureFlag.SIGNATURES_EXIST + SignatureFlag.APPEND_ONLY
            catalog_obj.acro_form = AcroForm(
                fields=PDFArray([sig_annotation_obj]), sig_flags=flags
            )
        if fpdf.zoom_mode in ZOOM_CONFIGS:
            zoom_config = [
                pdf_ref(first_page_obj.id),
                *ZOOM_CONFIGS[fpdf.zoom_mode],
            ]
        else:  # zoom_mode is a number, not one of the allowed strings:
            zoom_config = [
                pdf_ref(first_page_obj.id),
                &#34;/XYZ&#34;,
                &#34;null&#34;,
                &#34;null&#34;,
                str(fpdf.zoom_mode / 100),
            ]
        catalog_obj.open_action = pdf_list(zoom_config)
        if struct_tree_root_obj:
            catalog_obj.mark_info = pdf_dict({&#34;/Marked&#34;: &#34;true&#34;})
        if fpdf.embedded_files or fpdf.named_destinations:
            names_dict_entries = {}

            if fpdf.embedded_files:
                file_spec_names = [
                    f&#34;{PDFString(embedded_file.basename()).serialize()} {embedded_file.file_spec().ref}&#34;
                    for embedded_file in fpdf.embedded_files
                    if embedded_file.globally_enclosed
                ]
                names_dict_entries[&#34;/EmbeddedFiles&#34;] = pdf_dict(
                    {&#34;/Names&#34;: pdf_list(file_spec_names)}
                )
                global_file_specs = [
                    pdf_ref(ef.file_spec().id)
                    for ef in self.fpdf.embedded_files
                    if ef.globally_enclosed()
                ]
                if global_file_specs:
                    catalog_obj.a_f = pdf_list(global_file_specs)

            if fpdf.named_destinations:
                # Create a list of name/destination pairs for the Dests name tree
                dests_names = []
                for name, dest in fpdf.named_destinations.items():
                    # Check if this is a placeholder destination (page 0)
                    if dest.page_number == 0:
                        raise FPDFException(
                            f&#34;Named destination &#39;{name}&#39; was referenced but never set with set_link(name=...)&#34;
                        )

                    # Ensure the destination&#39;s page_ref is set
                    if not hasattr(dest, &#34;page_ref&#34;) or not dest.page_ref:
                        page_index = dest.page_number - 1
                        if 0 &lt;= page_index &lt; len(fpdf.pages):
                            dest.page_ref = pdf_ref(fpdf.pages[dest.page_number].id)

                    # Add name and destination to the Dests list
                    dests_names.append(
                        f&#34;{PDFString(name, encrypt=True).serialize(_security_handler=fpdf._security_handler, _obj_id=catalog_obj.id)} {dest.serialize()}&#34;
                    )

                if dests_names:
                    names_dict_entries[&#34;/Dests&#34;] = pdf_dict(
                        {&#34;/Names&#34;: pdf_list(sorted(dests_names))}
                    )

            catalog_obj.names = pdf_dict(names_dict_entries)

        page_labels = [
            f&#34;{i} {pdf_dict(page.get_page_label().serialize())}&#34;
            for i, page in enumerate(self._iter_pages_in_order())
            if page.get_page_label()
        ]
        if page_labels and not fpdf.pages[1].get_page_label():
            # If page labels are used, an entry for sequence 0 is mandatory
            page_labels.insert(0, &#34;0 &lt;&lt;&gt;&gt;&#34;)
        if page_labels:
            catalog_obj.page_labels = pdf_dict(
                {&#34;/Nums&#34;: PDFArray(page_labels).serialize()}
            )

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        self.sections_size_per_trace_label[label] += len(self.buffer) - prev_size

    def _log_final_sections_sizes(self):
        LOGGER.debug(&#34;Final size summary of the biggest document sections:&#34;)
        for label, section_size in self.sections_size_per_trace_label.items():
            LOGGER.debug(&#34;- %s: %s&#34;, label, _sizeof_fmt(section_size))</code></pre>
</details>
<div class="desc"><p>Generates the final bytearray representing the PDF document, based on a FPDF instance.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.linearization.LinearizedOutputProducer" href="linearization.html#fpdf.linearization.LinearizedOutputProducer">LinearizedOutputProducer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.OutputProducer.bufferize"><code class="name flex">
<span>def <span class="ident">bufferize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L846-L969" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bufferize(self):
    &#34;&#34;&#34;
    This method alters the target FPDF instance
    by assigning IDs to all PDF objects,
    plus a few other properties on PDFPage instances
    &#34;&#34;&#34;
    fpdf = self.fpdf

    # 1. Setup - Insert all PDF objects
    #    and assign unique consecutive numeric IDs to all of them

    if fpdf._security_handler:
        # get the file_id and generate passwords needed to encrypt streams and strings
        file_id = fpdf.file_id()
        if file_id == -1:
            # no custom file id - use default file id so encryption passwords can be generated
            file_id = fpdf._default_file_id(bytearray(0x00))
        fpdf._security_handler.generate_passwords(file_id)

    pdf_version = fpdf.pdf_version
    if (
        fpdf.viewer_preferences
        and fpdf.viewer_preferences._min_pdf_version &gt; pdf_version
    ):
        pdf_version = fpdf.viewer_preferences._min_pdf_version
    self.pdf_objs.append(PDFHeader(pdf_version))
    pages_root_obj = self._add_pages_root()
    catalog_obj = self._add_catalog()
    page_objs = self._add_pages()
    sig_annotation_obj = self._add_annotations_as_objects()
    for embedded_file in fpdf.embedded_files:
        self._add_pdf_obj(embedded_file, &#34;embedded_files&#34;)
        self._add_pdf_obj(embedded_file.file_spec(), &#34;file_spec&#34;)
    self._insert_resources(page_objs)
    struct_tree_root_obj = self._add_structure_tree()
    outline_dict_obj, outline_items = self._add_document_outline()
    xmp_metadata_obj = self._add_xmp_metadata()
    info_obj = None
    if not fpdf._compliance:
        info_obj = self._add_info()
    encryption_obj = self._add_encryption()

    xref = PDFXrefAndTrailer(self)
    self.pdf_objs.append(xref)

    # 2. Plumbing - Inject all PDF object references required:
    pages_root_obj.kids = PDFArray(page_objs)
    self._finalize_catalog(
        catalog_obj,
        pages_root_obj=pages_root_obj,
        first_page_obj=page_objs[0],
        sig_annotation_obj=sig_annotation_obj,
        xmp_metadata_obj=xmp_metadata_obj,
        struct_tree_root_obj=struct_tree_root_obj,
        outline_dict_obj=outline_dict_obj,
    )
    dests = []
    for page_obj in page_objs:
        page_obj.parent = pages_root_obj
        for annot in page_obj.annots:
            page_dests = []
            if annot.dest:
                # Only add to page_dests if it&#39;s a Destination object (not a string/PDFString)
                if hasattr(annot.dest, &#34;page_number&#34;):
                    page_dests.append(annot.dest)
            if annot.a and hasattr(annot.a, &#34;dest&#34;):
                # Only add to page_dests if it&#39;s a Destination object (not a string/PDFString)
                if hasattr(annot.a.dest, &#34;page_number&#34;):
                    page_dests.append(annot.a.dest)
            for dest in page_dests:
                if dest.page_number &gt; len(page_objs):
                    raise ValueError(
                        f&#34;Invalid reference to non-existing page {dest.page_number} present on page {page_obj.index()}: &#34;
                    )
            dests.extend(page_dests)
        if not page_obj.annots:
            # Avoid serializing an empty PDFArray:
            page_obj.annots = None
    for outline_item in outline_items:
        dests.append(outline_item.dest)
    # Assigning the .page_ref property of all Destination objects:
    for dest in dests:
        dest.page_ref = pdf_ref(page_objs[dest.page_number - 1].id)
    for struct_elem in fpdf.struct_builder.doc_struct_elem.k:
        struct_elem.pg = page_objs[struct_elem.page_number() - 1]
    xref.catalog_obj = catalog_obj
    xref.info_obj = info_obj
    xref.encryption_obj = encryption_obj

    # 3. Serializing - Append all PDF objects to the buffer:
    assert (
        not self.buffer
    ), f&#34;Nothing should have been appended to the .buffer at this stage: {self.buffer}&#34;
    assert (
        not self.offsets
    ), f&#34;No offset should have been set at this stage: {len(self.offsets)}&#34;

    for pdf_obj in self.pdf_objs:
        if isinstance(pdf_obj, ContentWithoutID):
            # top header, xref table &amp; trailer:
            trace_label = None
        else:
            self.offsets[pdf_obj.id] = len(self.buffer)
            trace_label = self.trace_labels_per_obj_id.get(pdf_obj.id)
        if trace_label:
            with self._trace_size(trace_label):
                self._out(
                    pdf_obj.serialize(_security_handler=fpdf._security_handler)
                )
        else:
            self._out(pdf_obj.serialize(_security_handler=fpdf._security_handler))
    self._log_final_sections_sizes()

    if fpdf._sign_key:
        self.buffer = sign_content(
            signer,
            self.buffer,
            fpdf._sign_key,
            fpdf._sign_cert,
            fpdf._sign_extra_certs,
            fpdf._sign_hashalgo,
            fpdf._sign_time,
        )
    return self.buffer</code></pre>
</details>
<div class="desc"><p>This method alters the target FPDF instance
by assigning IDs to all PDF objects,
plus a few other properties on PDFPage instances</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFCatalog"><code class="flex name class">
<span>class <span class="ident">PDFCatalog</span></span>
<span>(</span><span>lang=None, page_layout=None, page_mode=None, viewer_preferences=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L240-L258" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFCatalog(PDFObject):
    def __init__(
        self, lang=None, page_layout=None, page_mode=None, viewer_preferences=None
    ):
        super().__init__()
        self.type = Name(&#34;Catalog&#34;)
        self.lang = PDFString(lang) if lang else None
        self.page_layout = page_layout
        self.page_mode = page_mode
        self.viewer_preferences = viewer_preferences
        self.pages = None  # Required; shall be an indirect reference
        self.acro_form = None
        self.open_action = None
        self.mark_info = None
        self.metadata = None
        self.names = None
        self.outlines = None
        self.output_intents = None
        self.struct_tree_root = None</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFCatalog.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFCatalog.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFExtGState"><code class="flex name class">
<span>class <span class="ident">PDFExtGState</span></span>
<span>(</span><span>dict_as_str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L514-L521" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFExtGState(PDFObject):
    def __init__(self, dict_as_str):
        super().__init__()
        self._dict_as_str = dict_as_str

    # method override
    def serialize(self, obj_dict=None, _security_handler=None):
        return f&#34;{self.id} 0 obj\n{self._dict_as_str}\nendobj&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFExtGState.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFExtGState.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L520-L521" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, obj_dict=None, _security_handler=None):
    return f&#34;{self.id} 0 obj\n{self._dict_as_str}\nendobj&#34;</code></pre>
</details>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFFont"><code class="flex name class">
<span>class <span class="ident">PDFFont</span></span>
<span>(</span><span>subtype, base_font, encoding=None, d_w=None, w=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L88-L101" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFFont(PDFObject):
    def __init__(self, subtype, base_font, encoding=None, d_w=None, w=None):
        super().__init__()
        self.type = Name(&#34;Font&#34;)
        self.subtype = Name(subtype)
        self.base_font = Name(base_font)
        self.encoding = Name(encoding) if encoding else None
        self.d_w = d_w
        self.w = w
        self.descendant_fonts = None
        self.to_unicode = None
        self.c_i_d_system_info = None
        self.font_descriptor = None
        self.c_i_d_to_g_i_d_map = None</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFFont.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFFont.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFFontStream"><code class="flex name class">
<span>class <span class="ident">PDFFontStream</span></span>
<span>(</span><span>contents)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L272-L275" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFFontStream(PDFContentStream):
    def __init__(self, contents):
        super().__init__(contents=contents, compress=True)
        self.length1 = len(contents)</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></li>
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFFontStream.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.content_stream" href="syntax.html#fpdf.syntax.PDFContentStream.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFFontStream.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.serialize" href="syntax.html#fpdf.syntax.PDFContentStream.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFHeader"><code class="flex name class">
<span>class <span class="ident">PDFHeader</span></span>
<span>(</span><span>pdf_version)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L69-L85" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFHeader(ContentWithoutID):
    &#34;&#34;&#34;
    Emit the PDF file header as required by ISO 32000-1, §7.5.2 “File header”.

    The header consists of:
      1) A line starting with the literal &#34;%PDF-&#34; followed by the file version
      2) If the file contains binary data an immediate second line that is a comment
         starting with &#34;%&#34; and containing at least four bytes with values ≥ 128 (non-ASCII).
         This helps file-transfer tools treat the content as binary rather than text.
    &#34;&#34;&#34;

    def __init__(self, pdf_version):
        self.pdf_version = pdf_version

    # method override
    def serialize(self, _security_handler=None):
        return f&#34;%PDF-{self.pdf_version}\n%éëñ¿&#34;</code></pre>
</details>
<div class="desc"><p>Emit the PDF file header as required by ISO 32000-1, §7.5.2 “File header”.</p>
<p>The header consists of:
1) A line starting with the literal "%PDF-" followed by the file version
2) If the file contains binary data an immediate second line that is a comment
starting with "%" and containing at least four bytes with values ≥ 128 (non-ASCII).
This helps file-transfer tools treat the content as binary rather than text.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.output.ContentWithoutID" href="#fpdf.output.ContentWithoutID">ContentWithoutID</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFHeader.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L84-L85" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, _security_handler=None):
    return f&#34;%PDF-{self.pdf_version}\n%éëñ¿&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFICCProfile"><code class="flex name class">
<span>class <span class="ident">PDFICCProfile</span></span>
<span>(</span><span>contents, n, alternate)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L327-L353" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFICCProfile(PDFContentStream):
    &#34;&#34;&#34;
    Holds values for ICC Profile Stream
    Args:
        contents (str): stream content
        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK
        alternate (str): [&#39;DeviceGray&#39;|&#39;DeviceRGB&#39;|&#39;DeviceCMYK&#39;]
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;n&#34;,
        &#34;alternate&#34;,
    )

    def __init__(
        self,
        contents,
        n,
        alternate,
    ):
        super().__init__(contents=contents, compress=True)
        self.n = n
        self.alternate = Name(alternate)</code></pre>
</details>
<div class="desc"><p>Holds values for ICC Profile Stream</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>contents</code></strong> :&ensp;<code>str</code></dt>
<dd>stream content</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>[1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK</dd>
<dt><strong><code>alternate</code></strong> :&ensp;<code>str</code></dt>
<dd>['DeviceGray'|'DeviceRGB'|'DeviceCMYK']</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></li>
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.output.PDFICCProfile.alternate"><code class="name">var <span class="ident">alternate</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L327-L353" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFICCProfile(PDFContentStream):
    &#34;&#34;&#34;
    Holds values for ICC Profile Stream
    Args:
        contents (str): stream content
        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK
        alternate (str): [&#39;DeviceGray&#39;|&#39;DeviceRGB&#39;|&#39;DeviceCMYK&#39;]
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;n&#34;,
        &#34;alternate&#34;,
    )

    def __init__(
        self,
        contents,
        n,
        alternate,
    ):
        super().__init__(contents=contents, compress=True)
        self.n = n
        self.alternate = Name(alternate)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFICCProfile.filter"><code class="name">var <span class="ident">filter</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L327-L353" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFICCProfile(PDFContentStream):
    &#34;&#34;&#34;
    Holds values for ICC Profile Stream
    Args:
        contents (str): stream content
        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK
        alternate (str): [&#39;DeviceGray&#39;|&#39;DeviceRGB&#39;|&#39;DeviceCMYK&#39;]
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;n&#34;,
        &#34;alternate&#34;,
    )

    def __init__(
        self,
        contents,
        n,
        alternate,
    ):
        super().__init__(contents=contents, compress=True)
        self.n = n
        self.alternate = Name(alternate)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFICCProfile.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L327-L353" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFICCProfile(PDFContentStream):
    &#34;&#34;&#34;
    Holds values for ICC Profile Stream
    Args:
        contents (str): stream content
        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK
        alternate (str): [&#39;DeviceGray&#39;|&#39;DeviceRGB&#39;|&#39;DeviceCMYK&#39;]
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;n&#34;,
        &#34;alternate&#34;,
    )

    def __init__(
        self,
        contents,
        n,
        alternate,
    ):
        super().__init__(contents=contents, compress=True)
        self.n = n
        self.alternate = Name(alternate)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFICCProfile.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L327-L353" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFICCProfile(PDFContentStream):
    &#34;&#34;&#34;
    Holds values for ICC Profile Stream
    Args:
        contents (str): stream content
        n (int): [1|3|4], # the numbers for colors 1=Gray, 3=RGB, 4=CMYK
        alternate (str): [&#39;DeviceGray&#39;|&#39;DeviceRGB&#39;|&#39;DeviceCMYK&#39;]
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;n&#34;,
        &#34;alternate&#34;,
    )

    def __init__(
        self,
        contents,
        n,
        alternate,
    ):
        super().__init__(contents=contents, compress=True)
        self.n = n
        self.alternate = Name(alternate)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFICCProfile.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.content_stream" href="syntax.html#fpdf.syntax.PDFContentStream.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFICCProfile.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.serialize" href="syntax.html#fpdf.syntax.PDFContentStream.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFInfo"><code class="flex name class">
<span>class <span class="ident">PDFInfo</span></span>
<span>(</span><span>title,<br>subject,<br>author,<br>keywords,<br>creator,<br>producer,<br>creation_date: <a title="fpdf.syntax.PDFDate" href="syntax.html#fpdf.syntax.PDFDate">PDFDate</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L201-L223" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFInfo(PDFObject):
    def __init__(
        self,
        title,
        subject,
        author,
        keywords,
        creator,
        producer,
        creation_date: PDFDate,
    ):
        super().__init__()
        self.title = PDFString(title, encrypt=True) if title else None
        self.subject = PDFString(subject, encrypt=True) if subject else None
        if author and isinstance(author, (list, tuple, set)):
            author = &#34;; &#34;.join(str(a) for a in author)
        self.author = PDFString(author, encrypt=True) if author else None
        if keywords and isinstance(keywords, (list, tuple, set)):
            keywords = &#34;, &#34;.join(str(keyword) for keyword in keywords)
        self.keywords = PDFString(keywords, encrypt=True) if keywords else None
        self.creator = PDFString(creator, encrypt=True) if creator else None
        self.producer = PDFString(producer, encrypt=True) if producer else None
        self.creation_date = creation_date</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFInfo.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFInfo.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFPage"><code class="flex name class">
<span>class <span class="ident">PDFPage</span></span>
<span>(</span><span>duration, transition, contents, index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.output.PDFPage.annots"><code class="name">var <span class="ident">annots</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.contents"><code class="name">var <span class="ident">contents</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.dur"><code class="name">var <span class="ident">dur</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.group"><code class="name">var <span class="ident">group</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.media_box"><code class="name">var <span class="ident">media_box</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.struct_parents"><code class="name">var <span class="ident">struct_parents</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.trans"><code class="name">var <span class="ident">trans</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L409-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPage(PDFObject):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;type&#34;,
        &#34;contents&#34;,
        &#34;dur&#34;,
        &#34;trans&#34;,
        &#34;annots&#34;,
        &#34;group&#34;,
        &#34;media_box&#34;,
        &#34;struct_parents&#34;,
        &#34;resources&#34;,
        &#34;parent&#34;,
        &#34;_index&#34;,
        &#34;_width_pt&#34;,
        &#34;_height_pt&#34;,
        &#34;_page_label&#34;,
        &#34;_text_substitution_fragments&#34;,
    )

    def __init__(
        self,
        duration,
        transition,
        contents,
        index,
    ):
        super().__init__()
        self.type = Name(&#34;Page&#34;)
        self.contents = contents
        self.dur = duration if duration else None
        self.trans = transition
        self.annots = PDFArray()  # list of PDFAnnotation
        self.group = None
        self.media_box = None
        self.struct_parents = None
        self.resources = None  # must always be set before calling .serialize()
        self.parent = None  # must always be set before calling .serialize()
        # Useful properties that will not be serialized in the final PDF document:
        self._index = index
        self._width_pt, self._height_pt = None, None
        self._page_label: PDFPageLabel = None
        self._text_substitution_fragments: list[TotalPagesSubstitutionFragment] = []

    def index(self):
        return self._index

    def set_index(self, i):
        self._index = i

    def dimensions(self):
        &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
        return self._width_pt, self._height_pt

    def set_dimensions(self, width_pt, height_pt):
        &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
        self._width_pt, self._height_pt = width_pt, height_pt

    def set_page_label(
        self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
    ):
        if (
            previous_page_label
            and page_label
            and page_label.get_style() == previous_page_label.get_style()
            and page_label.get_prefix() == previous_page_label.get_prefix()
            and not page_label.st
        ):
            page_label.st = previous_page_label.get_start() + 1

        if page_label:
            if not page_label.get_start():
                page_label.st = 1

        if previous_page_label and not page_label:
            page_label = PDFPageLabel(
                previous_page_label.get_style(),
                previous_page_label.get_prefix(),
                previous_page_label.get_start() + 1,
            )

        self._page_label = page_label

    def get_page_label(self) -&gt; PDFPageLabel:
        return self._page_label

    def get_label(self) -&gt; str:
        return str(self.index()) if not self._page_label else str(self._page_label)

    def get_text_substitutions(self):
        return self._text_substitution_fragments

    def add_text_substitution(self, fragment):
        self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFPage.add_text_substitution"><code class="name flex">
<span>def <span class="ident">add_text_substitution</span></span>(<span>self, fragment)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L501-L502" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_text_substitution(self, fragment):
    self._text_substitution_fragments.append(fragment)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFPage.dimensions"><code class="name flex">
<span>def <span class="ident">dimensions</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L459-L461" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def dimensions(self):
    &#34;Return a pair (width, height) in the unit specified to FPDF constructor&#34;
    return self._width_pt, self._height_pt</code></pre>
</details>
<div class="desc"><p>Return a pair (width, height) in the unit specified to FPDF constructor</p></div>
</dd>
<dt id="fpdf.output.PDFPage.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L495-L496" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_label(self) -&gt; str:
    return str(self.index()) if not self._page_label else str(self._page_label)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.get_page_label"><code class="name flex">
<span>def <span class="ident">get_page_label</span></span>(<span>self) ‑> <a title="fpdf.output.PDFPageLabel" href="#fpdf.output.PDFPageLabel">PDFPageLabel</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L492-L493" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_page_label(self) -&gt; PDFPageLabel:
    return self._page_label</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.get_text_substitutions"><code class="name flex">
<span>def <span class="ident">get_text_substitutions</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L498-L499" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_text_substitutions(self):
    return self._text_substitution_fragments</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L453-L454" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def index(self):
    return self._index</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
<dt id="fpdf.output.PDFPage.set_dimensions"><code class="name flex">
<span>def <span class="ident">set_dimensions</span></span>(<span>self, width_pt, height_pt)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L463-L465" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_dimensions(self, width_pt, height_pt):
    &#34;Accepts a pair (width, height) in the unit specified to FPDF constructor&#34;
    self._width_pt, self._height_pt = width_pt, height_pt</code></pre>
</details>
<div class="desc"><p>Accepts a pair (width, height) in the unit specified to FPDF constructor</p></div>
</dd>
<dt id="fpdf.output.PDFPage.set_index"><code class="name flex">
<span>def <span class="ident">set_index</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L456-L457" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_index(self, i):
    self._index = i</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPage.set_page_label"><code class="name flex">
<span>def <span class="ident">set_page_label</span></span>(<span>self,<br>previous_page_label: <a title="fpdf.output.PDFPageLabel" href="#fpdf.output.PDFPageLabel">PDFPageLabel</a>,<br>page_label: <a title="fpdf.output.PDFPageLabel" href="#fpdf.output.PDFPageLabel">PDFPageLabel</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L467-L490" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def set_page_label(
    self, previous_page_label: PDFPageLabel, page_label: PDFPageLabel
):
    if (
        previous_page_label
        and page_label
        and page_label.get_style() == previous_page_label.get_style()
        and page_label.get_prefix() == previous_page_label.get_prefix()
        and not page_label.st
    ):
        page_label.st = previous_page_label.get_start() + 1

    if page_label:
        if not page_label.get_start():
            page_label.st = 1

    if previous_page_label and not page_label:
        page_label = PDFPageLabel(
            previous_page_label.get_style(),
            previous_page_label.get_prefix(),
            previous_page_label.get_start() + 1,
        )

    self._page_label = page_label</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFPageLabel"><code class="flex name class">
<span>class <span class="ident">PDFPageLabel</span></span>
<span>(</span><span>label_style: <a title="fpdf.enums.PageLabelStyle" href="enums.html#fpdf.enums.PageLabelStyle">PageLabelStyle</a>,<br>label_prefix: str,<br>label_start: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L356-L406" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPageLabel:
    &#34;&#34;&#34;
    This will be displayed by some PDF readers to identify pages.
    &#34;&#34;&#34;

    __slots__ = (&#34;_style&#34;, &#34;_prefix&#34;, &#34;st&#34;)  # RAM usage optimization

    def __init__(
        self, label_style: PageLabelStyle, label_prefix: str, label_start: int
    ):
        self._style: PageLabelStyle = label_style
        self._prefix: str = label_prefix
        self.st: int = label_start

    @property
    def s(self) -&gt; Name:
        return Name(self._style.value) if self._style else None

    @property
    def p(self) -&gt; PDFString:
        return PDFString(self._prefix) if self._prefix else None

    def __repr__(self):
        return f&#34;PDFPageLabel({self._style}, {self._prefix}, {self.st})&#34;

    def __str__(self):
        ret = self._prefix if self._prefix else &#34;&#34;
        if self._style:
            if self._style == PageLabelStyle.NUMBER:
                ret += str(self.st)
            elif self._style == PageLabelStyle.UPPER_ROMAN:
                ret += int2roman(self.st)
            elif self._style == PageLabelStyle.LOWER_ROMAN:
                ret += int2roman(self.st).lower()
            elif self._style == PageLabelStyle.UPPER_LETTER:
                ret += int_to_letters(self.st - 1)
            elif self._style == PageLabelStyle.LOWER_LETTER:
                ret += int_to_letters(self.st - 1).lower()
        return ret

    def serialize(self) -&gt; dict:
        return build_obj_dict({key: getattr(self, key) for key in dir(self)})

    def get_style(self) -&gt; PageLabelStyle:
        return self._style

    def get_prefix(self) -&gt; str:
        return self._prefix

    def get_start(self) -&gt; int:
        return self.st</code></pre>
</details>
<div class="desc"><p>This will be displayed by some PDF readers to identify pages.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.output.PDFPageLabel.p"><code class="name">prop <span class="ident">p</span> : <a title="fpdf.syntax.PDFString" href="syntax.html#fpdf.syntax.PDFString">PDFString</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L374-L376" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def p(self) -&gt; PDFString:
    return PDFString(self._prefix) if self._prefix else None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPageLabel.s"><code class="name">prop <span class="ident">s</span> : <a title="fpdf.syntax.Name" href="syntax.html#fpdf.syntax.Name">Name</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L370-L372" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def s(self) -&gt; Name:
    return Name(self._style.value) if self._style else None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPageLabel.st"><code class="name">var <span class="ident">st</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L356-L406" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPageLabel:
    &#34;&#34;&#34;
    This will be displayed by some PDF readers to identify pages.
    &#34;&#34;&#34;

    __slots__ = (&#34;_style&#34;, &#34;_prefix&#34;, &#34;st&#34;)  # RAM usage optimization

    def __init__(
        self, label_style: PageLabelStyle, label_prefix: str, label_start: int
    ):
        self._style: PageLabelStyle = label_style
        self._prefix: str = label_prefix
        self.st: int = label_start

    @property
    def s(self) -&gt; Name:
        return Name(self._style.value) if self._style else None

    @property
    def p(self) -&gt; PDFString:
        return PDFString(self._prefix) if self._prefix else None

    def __repr__(self):
        return f&#34;PDFPageLabel({self._style}, {self._prefix}, {self.st})&#34;

    def __str__(self):
        ret = self._prefix if self._prefix else &#34;&#34;
        if self._style:
            if self._style == PageLabelStyle.NUMBER:
                ret += str(self.st)
            elif self._style == PageLabelStyle.UPPER_ROMAN:
                ret += int2roman(self.st)
            elif self._style == PageLabelStyle.LOWER_ROMAN:
                ret += int2roman(self.st).lower()
            elif self._style == PageLabelStyle.UPPER_LETTER:
                ret += int_to_letters(self.st - 1)
            elif self._style == PageLabelStyle.LOWER_LETTER:
                ret += int_to_letters(self.st - 1).lower()
        return ret

    def serialize(self) -&gt; dict:
        return build_obj_dict({key: getattr(self, key) for key in dir(self)})

    def get_style(self) -&gt; PageLabelStyle:
        return self._style

    def get_prefix(self) -&gt; str:
        return self._prefix

    def get_start(self) -&gt; int:
        return self.st</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFPageLabel.get_prefix"><code class="name flex">
<span>def <span class="ident">get_prefix</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L402-L403" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_prefix(self) -&gt; str:
    return self._prefix</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPageLabel.get_start"><code class="name flex">
<span>def <span class="ident">get_start</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L405-L406" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_start(self) -&gt; int:
    return self.st</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPageLabel.get_style"><code class="name flex">
<span>def <span class="ident">get_style</span></span>(<span>self) ‑> <a title="fpdf.enums.PageLabelStyle" href="enums.html#fpdf.enums.PageLabelStyle">PageLabelStyle</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L399-L400" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_style(self) -&gt; PageLabelStyle:
    return self._style</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFPageLabel.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L396-L397" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self) -&gt; dict:
    return build_obj_dict({key: getattr(self, key) for key in dir(self)})</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFPagesRoot"><code class="flex name class">
<span>class <span class="ident">PDFPagesRoot</span></span>
<span>(</span><span>count, media_box)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L505-L511" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFPagesRoot(PDFObject):
    def __init__(self, count, media_box):
        super().__init__()
        self.type = Name(&#34;Pages&#34;)
        self.count = count
        self.media_box = media_box
        self.kids = None  # must always be set before calling .serialize()</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFPagesRoot.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFPagesRoot.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFResources"><code class="flex name class">
<span>class <span class="ident">PDFResources</span></span>
<span>(</span><span>proc_set, font, x_object, ext_g_state, shading, pattern)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L261-L269" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFResources(PDFObject):
    def __init__(self, proc_set, font, x_object, ext_g_state, shading, pattern):
        super().__init__()
        self.proc_set = proc_set
        self.font = font
        self.x_object = x_object
        self.ext_g_state = ext_g_state
        self.shading = shading
        self.pattern = pattern</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFResources.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFResources.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFType3Font"><code class="flex name class">
<span>class <span class="ident">PDFType3Font</span></span>
<span>(</span><span>font3: Type3Font)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L112-L198" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFType3Font(PDFObject):
    def __init__(self, font3: &#34;Type3Font&#34;):
        super().__init__()
        self._font3 = font3
        self.type = Name(&#34;Font&#34;)
        self.name = Name(f&#34;MPDFAA+{font3.base_font.name}&#34;)
        self.subtype = Name(&#34;Type3&#34;)
        self.font_b_box = (
            f&#34;[{self._font3.base_font.ttfont[&#39;head&#39;].xMin * self._font3.scale:.0f}&#34;
            f&#34; {self._font3.base_font.ttfont[&#39;head&#39;].yMin * self._font3.scale:.0f}&#34;
            f&#34; {self._font3.base_font.ttfont[&#39;head&#39;].xMax * self._font3.scale:.0f}&#34;
            f&#34; {self._font3.base_font.ttfont[&#39;head&#39;].yMax * self._font3.scale:.0f}]&#34;
        )
        self.font_matrix = &#34;[0.001 0 0 0.001 0 0]&#34;
        self.first_char = min(g.unicode for g in font3.glyphs)
        self.last_char = max(g.unicode for g in font3.glyphs)
        self.resources = None
        self.to_unicode = None

    @property
    def char_procs(self):
        return pdf_dict(
            {f&#34;/{g.glyph_name}&#34;: f&#34;{g.obj_id} 0 R&#34; for g in self._font3.glyphs}
        )

    @property
    def encoding(self):
        return pdf_dict(
            {
                Name(&#34;/Type&#34;): Name(&#34;/Encoding&#34;),
                Name(&#34;/Differences&#34;): self.differences_table(),
            }
        )

    @property
    def widths(self):
        sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)
        # Find the range of unicode values
        min_unicode = sorted_glyphs[0].unicode
        max_unicode = sorted_glyphs[-1].unicode

        # Initialize widths array with zeros
        widths = [0] * (max_unicode + 1 - min_unicode)

        # Populate the widths array
        for glyph in sorted_glyphs:
            widths[glyph.unicode - min_unicode] = round(
                glyph.glyph_width * self._font3.scale + 0.001
            )
        return pdf_list([str(glyph_width) for glyph_width in widths])

    def generate_resources(
        self, img_objs_per_index, gfxstate_objs_per_name, pattern_objs_per_name
    ):
        resources = &#34;&lt;&lt;&#34;
        objects = &#34; &#34;.join(
            f&#34;/I{img} {img_objs_per_index[img].id} 0 R&#34;
            for img in self._font3.images_used
        )
        resources += f&#34;/XObject &lt;&lt;{objects}&gt;&gt;&#34; if len(objects) &gt; 0 else &#34;&#34;

        ext_g_state = &#34; &#34;.join(
            f&#34;/{name} {gfxstate_obj.id} 0 R&#34;
            for name, gfxstate_obj in gfxstate_objs_per_name.items()
            if name in self._font3.graphics_style_used
        )
        resources += f&#34;/ExtGState &lt;&lt;{ext_g_state}&gt;&gt;&#34; if len(ext_g_state) &gt; 0 else &#34;&#34;

        pattern = &#34; &#34;.join(
            f&#34;/{name} {pattern.id} 0 R&#34;
            for name, pattern in pattern_objs_per_name.items()
            if name in self._font3.patterns_used
        )
        resources += f&#34;/Pattern &lt;&lt;{pattern}&gt;&gt;&#34; if len(pattern) &gt; 0 else &#34;&#34;

        resources += &#34;&gt;&gt;&#34;
        self.resources = resources

    def differences_table(self):
        sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)
        return (
            &#34;[&#34;
            + &#34;\n&#34;.join(
                f&#34;{glyph.unicode} /{glyph.glyph_name}&#34; for glyph in sorted_glyphs
            )
            + &#34;]&#34;
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.output.PDFType3Font.char_procs"><code class="name">prop <span class="ident">char_procs</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L131-L135" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def char_procs(self):
    return pdf_dict(
        {f&#34;/{g.glyph_name}&#34;: f&#34;{g.obj_id} 0 R&#34; for g in self._font3.glyphs}
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFType3Font.encoding"><code class="name">prop <span class="ident">encoding</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L137-L144" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def encoding(self):
    return pdf_dict(
        {
            Name(&#34;/Type&#34;): Name(&#34;/Encoding&#34;),
            Name(&#34;/Differences&#34;): self.differences_table(),
        }
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFType3Font.widths"><code class="name">prop <span class="ident">widths</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L146-L161" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def widths(self):
    sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)
    # Find the range of unicode values
    min_unicode = sorted_glyphs[0].unicode
    max_unicode = sorted_glyphs[-1].unicode

    # Initialize widths array with zeros
    widths = [0] * (max_unicode + 1 - min_unicode)

    # Populate the widths array
    for glyph in sorted_glyphs:
        widths[glyph.unicode - min_unicode] = round(
            glyph.glyph_width * self._font3.scale + 0.001
        )
    return pdf_list([str(glyph_width) for glyph_width in widths])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFType3Font.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFType3Font.differences_table"><code class="name flex">
<span>def <span class="ident">differences_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L190-L198" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def differences_table(self):
    sorted_glyphs = sorted(self._font3.glyphs, key=lambda glyph: glyph.unicode)
    return (
        &#34;[&#34;
        + &#34;\n&#34;.join(
            f&#34;{glyph.unicode} /{glyph.glyph_name}&#34; for glyph in sorted_glyphs
        )
        + &#34;]&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFType3Font.generate_resources"><code class="name flex">
<span>def <span class="ident">generate_resources</span></span>(<span>self, img_objs_per_index, gfxstate_objs_per_name, pattern_objs_per_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L163-L188" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def generate_resources(
    self, img_objs_per_index, gfxstate_objs_per_name, pattern_objs_per_name
):
    resources = &#34;&lt;&lt;&#34;
    objects = &#34; &#34;.join(
        f&#34;/I{img} {img_objs_per_index[img].id} 0 R&#34;
        for img in self._font3.images_used
    )
    resources += f&#34;/XObject &lt;&lt;{objects}&gt;&gt;&#34; if len(objects) &gt; 0 else &#34;&#34;

    ext_g_state = &#34; &#34;.join(
        f&#34;/{name} {gfxstate_obj.id} 0 R&#34;
        for name, gfxstate_obj in gfxstate_objs_per_name.items()
        if name in self._font3.graphics_style_used
    )
    resources += f&#34;/ExtGState &lt;&lt;{ext_g_state}&gt;&gt;&#34; if len(ext_g_state) &gt; 0 else &#34;&#34;

    pattern = &#34; &#34;.join(
        f&#34;/{name} {pattern.id} 0 R&#34;
        for name, pattern in pattern_objs_per_name.items()
        if name in self._font3.patterns_used
    )
    resources += f&#34;/Pattern &lt;&lt;{pattern}&gt;&gt;&#34; if len(pattern) &gt; 0 else &#34;&#34;

    resources += &#34;&gt;&gt;&#34;
    self.resources = resources</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFType3Font.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFXObject"><code class="flex name class">
<span>class <span class="ident">PDFXObject</span></span>
<span>(</span><span>contents,<br>subtype,<br>width,<br>height,<br>color_space,<br>bits_per_component,<br>img_filter=None,<br>decode=None,<br>decode_parms=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></li>
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.output.PDFXObject.bits_per_component"><code class="name">var <span class="ident">bits_per_component</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.color_space"><code class="name">var <span class="ident">color_space</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.decode"><code class="name">var <span class="ident">decode</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.decode_parms"><code class="name">var <span class="ident">decode_parms</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.filter"><code class="name">var <span class="ident">filter</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.s_mask"><code class="name">var <span class="ident">s_mask</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.subtype"><code class="name">var <span class="ident">subtype</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.PDFXObject.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L285-L324" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXObject(PDFContentStream):
    __slots__ = (  # RAM usage optimization
        &#34;_id&#34;,
        &#34;_contents&#34;,
        &#34;filter&#34;,
        &#34;length&#34;,
        &#34;type&#34;,
        &#34;subtype&#34;,
        &#34;width&#34;,
        &#34;height&#34;,
        &#34;color_space&#34;,
        &#34;bits_per_component&#34;,
        &#34;decode&#34;,
        &#34;decode_parms&#34;,
        &#34;s_mask&#34;,
    )

    def __init__(
        self,
        contents,
        subtype,
        width,
        height,
        color_space,
        bits_per_component,
        img_filter=None,
        decode=None,
        decode_parms=None,
    ):
        super().__init__(contents=contents)
        self.type = Name(&#34;XObject&#34;)
        self.subtype = Name(subtype)
        self.width = width
        self.height = height
        self.color_space = color_space
        self.bits_per_component = bits_per_component
        self.filter = Name(img_filter)
        self.decode = decode
        self.decode_parms = decode_parms
        self.s_mask = None</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFXObject.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.content_stream" href="syntax.html#fpdf.syntax.PDFContentStream.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFXObject.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.serialize" href="syntax.html#fpdf.syntax.PDFContentStream.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFXmpMetadata"><code class="flex name class">
<span>class <span class="ident">PDFXmpMetadata</span></span>
<span>(</span><span>contents)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L278-L282" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXmpMetadata(PDFContentStream):
    def __init__(self, contents):
        super().__init__(contents=contents.encode(&#34;utf-8&#34;))
        self.type = Name(&#34;Metadata&#34;)
        self.subtype = Name(&#34;XML&#34;)</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></li>
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFXmpMetadata.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.content_stream" href="syntax.html#fpdf.syntax.PDFContentStream.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.output.PDFXmpMetadata.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFContentStream" href="syntax.html#fpdf.syntax.PDFContentStream">PDFContentStream</a></code>.<code><a title="fpdf.syntax.PDFContentStream.serialize" href="syntax.html#fpdf.syntax.PDFContentStream.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.PDFXrefAndTrailer"><code class="flex name class">
<span>class <span class="ident">PDFXrefAndTrailer</span></span>
<span>(</span><span>output_builder)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L524-L564" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFXrefAndTrailer(ContentWithoutID):
    &#34;Cross-reference table &amp; file trailer&#34;

    def __init__(self, output_builder):
        self.output_builder = output_builder
        self.count = output_builder.obj_id + 1
        # Must be set before the call to serialize():
        self.catalog_obj = None
        self.info_obj = None
        self.encryption_obj = None

    def serialize(self, _security_handler=None):
        builder = self.output_builder
        startxref = str(len(builder.buffer))
        out = []
        out.append(&#34;xref&#34;)
        out.append(f&#34;0 {self.count}&#34;)
        out.append(&#34;0000000000 65535 f &#34;)
        for obj_id in range(1, self.count):
            out.append(f&#34;{builder.offsets[obj_id]:010} 00000 n &#34;)
        out.append(&#34;trailer&#34;)
        out.append(&#34;&lt;&lt;&#34;)
        out.append(f&#34;/Size {self.count}&#34;)
        out.append(f&#34;/Root {pdf_ref(self.catalog_obj.id)}&#34;)
        if self.info_obj:
            out.append(f&#34;/Info {pdf_ref(self.info_obj.id)}&#34;)
        fpdf = builder.fpdf
        if self.encryption_obj:
            out.append(f&#34;/Encrypt {pdf_ref(self.encryption_obj.id)}&#34;)
            file_id = fpdf._security_handler.file_id
        else:
            file_id = fpdf.file_id()
            if file_id == -1:
                file_id = fpdf._default_file_id(builder.buffer)
        if file_id:
            out.append(f&#34;/ID [{file_id}]&#34;)
        out.append(&#34;&gt;&gt;&#34;)
        out.append(&#34;startxref&#34;)
        out.append(startxref)
        out.append(&#34;%%EOF&#34;)
        return &#34;\n&#34;.join(out)</code></pre>
</details>
<div class="desc"><p>Cross-reference table &amp; file trailer</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.output.ContentWithoutID" href="#fpdf.output.ContentWithoutID">ContentWithoutID</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.PDFXrefAndTrailer.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L535-L564" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, _security_handler=None):
    builder = self.output_builder
    startxref = str(len(builder.buffer))
    out = []
    out.append(&#34;xref&#34;)
    out.append(f&#34;0 {self.count}&#34;)
    out.append(&#34;0000000000 65535 f &#34;)
    for obj_id in range(1, self.count):
        out.append(f&#34;{builder.offsets[obj_id]:010} 00000 n &#34;)
    out.append(&#34;trailer&#34;)
    out.append(&#34;&lt;&lt;&#34;)
    out.append(f&#34;/Size {self.count}&#34;)
    out.append(f&#34;/Root {pdf_ref(self.catalog_obj.id)}&#34;)
    if self.info_obj:
        out.append(f&#34;/Info {pdf_ref(self.info_obj.id)}&#34;)
    fpdf = builder.fpdf
    if self.encryption_obj:
        out.append(f&#34;/Encrypt {pdf_ref(self.encryption_obj.id)}&#34;)
        file_id = fpdf._security_handler.file_id
    else:
        file_id = fpdf.file_id()
        if file_id == -1:
            file_id = fpdf._default_file_id(builder.buffer)
    if file_id:
        out.append(f&#34;/ID [{file_id}]&#34;)
    out.append(&#34;&gt;&gt;&#34;)
    out.append(&#34;startxref&#34;)
    out.append(startxref)
    out.append(&#34;%%EOF&#34;)
    return &#34;\n&#34;.join(out)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.output.ResourceCatalog"><code class="flex name class">
<span>class <span class="ident">ResourceCatalog</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L635-L827" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class ResourceCatalog:
    &#34;Manage the indexing of resources and association to the pages they are used&#34;

    GS_REGEX = re.compile(r&#34;/(GS\d+) gs&#34;)
    IMG_REGEX = re.compile(r&#34;/I(\d+) Do&#34;)
    PATTERN_FILL_REGEX = re.compile(r&#34;/(P\d+)\s+scn&#34;)
    PATTERN_STROKE_REGEX = re.compile(r&#34;/(P\d+)\s+SCN&#34;)
    FONT_REGEX = re.compile(r&#34;/F(\d+)\s+[-+]?\d+(?:\.\d+)?\s+Tf&#34;)

    def __init__(self):
        self.resources = defaultdict(dict)
        self.resources_per_page = defaultdict(set)
        self.graphics_styles = OrderedDict()
        self.soft_mask_xobjects = []
        self.last_reserved_object_id = 0
        self.font_registry: Dict[str, Union[CoreFont, TTFFont]] = {}

    def add(self, resource_type: PDFResourceType, resource, page_number: Optional[int]):
        if resource_type in (PDFResourceType.PATTERN, PDFResourceType.SHADING):
            registry = self.resources[resource_type]
            prefix = self._get_prefix(resource_type)

            if resource not in registry:
                registry[resource] = f&#34;{prefix}{len(registry) + 1}&#34;
            if page_number is not None:
                self.resources_per_page[(page_number, resource_type)].add(
                    registry[resource]
                )
            return registry[resource]

        self.resources_per_page[(page_number, resource_type)].add(resource)
        return None

    def register_graphics_style(self, style):
        &#34;&#34;&#34;
        Graphics style can be added without associating to a page number right away,
        like when rendering a svg image.
        The method that adds image to the page will call the add method for the page association.
        &#34;&#34;&#34;
        style_dict = style.serialize()
        if not style_dict:  # empty style does not need an entry
            return None

        if style_dict not in self.graphics_styles:
            name = Name(
                f&#34;{self._get_prefix(PDFResourceType.EXT_G_STATE)}{len(self.graphics_styles)}&#34;
            )
            self.graphics_styles[style_dict] = name

        return self.graphics_styles[style_dict]

    def register_soft_mask(self, soft_mask: PaintSoftMask) -&gt; int:
        &#34;&#34;&#34;Register a soft mask xobject and return its object id&#34;&#34;&#34;
        self.last_reserved_object_id += 1
        xobject = soft_mask_path_to_xobject(soft_mask, self)
        xobject.id = self.last_reserved_object_id
        self.soft_mask_xobjects.append(xobject)
        return xobject.id

    def scan_stream(self, rendered: str) -&gt; list[tuple[PDFResourceType, str]]:
        &#34;&#34;&#34;Parse a content stream and return discovered resources&#34;&#34;&#34;
        found = set()

        for m in self.GS_REGEX.finditer(rendered):
            found.add((PDFResourceType.EXT_G_STATE, m.group(1)))

        for m in self.IMG_REGEX.finditer(rendered):
            found.add((PDFResourceType.X_OBJECT, int(m.group(1))))

        for m in self.PATTERN_FILL_REGEX.finditer(rendered):
            found.add((PDFResourceType.PATTERN, m.group(1)))

        for m in self.PATTERN_STROKE_REGEX.finditer(rendered):
            found.add((PDFResourceType.PATTERN, m.group(1)))

        for m in self.FONT_REGEX.finditer(rendered):
            found.add((PDFResourceType.FONT, int(m.group(1))))

        return found

    def index_stream_resources(self, rendered: str, page_number: int) -&gt; None:
        &#34;&#34;&#34;
        Scan a rendered content stream and register resources used on the given page.
        Currently indexes:
          - ExtGState invocations: &#39;/GSn gs&#39;
          - Image XObjects: &#39;/In Do&#39;
        &#34;&#34;&#34;
        for resource_type, resource in self.scan_stream(rendered):
            if resource_type == PDFResourceType.PATTERN:
                self.resources_per_page[(page_number, PDFResourceType.PATTERN)].add(
                    resource
                )
            else:
                self.add(resource_type, resource, page_number)

    def get_items(self, resource_type: PDFResourceType):
        return self.resources[resource_type].items()

    def get_resources_per_page(self, page_number: int, resource_type: PDFResourceType):
        return self.resources_per_page[(page_number, resource_type)]

    def get_used_resources(self, resource_type: PDFResourceType):
        unique = set()
        for (_, rtype), resource in self.resources_per_page.items():
            if rtype == resource_type:
                unique.update(resource)
        return unique

    @classmethod
    def _get_prefix(cls, resource_type: PDFResourceType):
        if resource_type == PDFResourceType.EXT_G_STATE:
            return &#34;GS&#34;
        if resource_type == PDFResourceType.PATTERN:
            return &#34;P&#34;
        if resource_type == PDFResourceType.SHADING:
            return &#34;Sh&#34;
        raise ValueError(f&#34;No prefix for resource type {resource_type}&#34;)

    def get_font_from_family(
        self, font_family: str, font_style: str = &#34;&#34;
    ) -&gt; Union[&#34;CoreFont&#34;, &#34;TTFFont&#34;]:
        &#34;&#34;&#34;
        Resolve a family+style to a concrete font instance from the font registry.
        Behavior:
          - Exact match (family.lower() + style.upper()) in registry: return it
          - If `family` names a core font: add CoreFont to registry (if missing) and return it
          - If `family` is an alias/generic: translate to a core font, add to registry (if missing), and return it
          - Otherwise: raise KeyError

        Notes:
          - For Symbol/ZapfDingbats, style is forced to &#34;&#34; (they don&#39;t support B/I).
        &#34;&#34;&#34;
        if not font_family:
            raise KeyError(&#34;Empty font family&#34;)

        style = &#34;&#34;.join(sorted(font_style.upper()))

        alias = {
            # sans
            &#34;sans-serif&#34;: &#34;helvetica&#34;,
            &#34;sans serif&#34;: &#34;helvetica&#34;,
            &#34;arial&#34;: &#34;helvetica&#34;,
            &#34;verdana&#34;: &#34;helvetica&#34;,
            &#34;tahoma&#34;: &#34;helvetica&#34;,
            &#34;segoe ui&#34;: &#34;helvetica&#34;,
            # serif
            &#34;serif&#34;: &#34;times&#34;,
            &#34;times&#34;: &#34;times&#34;,
            &#34;times new roman&#34;: &#34;times&#34;,
            &#34;georgia&#34;: &#34;times&#34;,
            &#34;cambria&#34;: &#34;times&#34;,
            &#34;garamond&#34;: &#34;times&#34;,
            # mono
            &#34;monospace&#34;: &#34;courier&#34;,
            &#34;courier&#34;: &#34;courier&#34;,
            &#34;courier new&#34;: &#34;courier&#34;,
            &#34;consolas&#34;: &#34;courier&#34;,
            &#34;monaco&#34;: &#34;courier&#34;,
            # symbol
            &#34;symbol&#34;: &#34;symbol&#34;,
            &#34;zapfdingbats&#34;: &#34;zapfdingbats&#34;,
            &#34;zapf dingbats&#34;: &#34;zapfdingbats&#34;,
        }

        for candidate in font_family.strip().strip(&#34;&#39;\&#34;&#34;).split(&#34;,&#34;):
            family = candidate.strip().strip(&#34;&#39;\&#34;&#34;).lower()

            # 1) Exact match
            fontkey = f&#34;{family}{style}&#34;
            if fontkey in self.font_registry:
                return self.font_registry[fontkey]

            # 2) Core-family direct hit?
            if family in CORE_FONTS:
                core_style = &#34;&#34; if family in {&#34;symbol&#34;, &#34;zapfdingbats&#34;} else style
                key = f&#34;{family}{core_style}&#34;
                if key not in self.font_registry:
                    i = len(self.font_registry) + 1
                    self.font_registry[key] = CoreFont(i, key, core_style)
                return self.font_registry[key]

            # 3) Alias / generic mapping to core font
            mapped = alias.get(family)
            if mapped:
                core_style = &#34;&#34; if mapped in {&#34;symbol&#34;, &#34;zapfdingbats&#34;} else style
                key = f&#34;{mapped}{core_style}&#34;
                if key not in self.font_registry:
                    i = len(self.font_registry) + 1
                    self.font_registry[key] = CoreFont(i, key, core_style)
                return self.font_registry[key]

        # 4) Fail: do not return anything
        raise KeyError(f&#34;No suitable font for family={font_family!r}, style={style!r}&#34;)</code></pre>
</details>
<div class="desc"><p>Manage the indexing of resources and association to the pages they are used</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.output.ResourceCatalog.FONT_REGEX"><code class="name">var <span class="ident">FONT_REGEX</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.GS_REGEX"><code class="name">var <span class="ident">GS_REGEX</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.IMG_REGEX"><code class="name">var <span class="ident">IMG_REGEX</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.PATTERN_FILL_REGEX"><code class="name">var <span class="ident">PATTERN_FILL_REGEX</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.PATTERN_STROKE_REGEX"><code class="name">var <span class="ident">PATTERN_STROKE_REGEX</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.ResourceCatalog.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self,<br>resource_type: <a title="fpdf.enums.PDFResourceType" href="enums.html#fpdf.enums.PDFResourceType">PDFResourceType</a>,<br>resource,<br>page_number: int | None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L652-L666" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add(self, resource_type: PDFResourceType, resource, page_number: Optional[int]):
    if resource_type in (PDFResourceType.PATTERN, PDFResourceType.SHADING):
        registry = self.resources[resource_type]
        prefix = self._get_prefix(resource_type)

        if resource not in registry:
            registry[resource] = f&#34;{prefix}{len(registry) + 1}&#34;
        if page_number is not None:
            self.resources_per_page[(page_number, resource_type)].add(
                registry[resource]
            )
        return registry[resource]

    self.resources_per_page[(page_number, resource_type)].add(resource)
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.get_font_from_family"><code class="name flex">
<span>def <span class="ident">get_font_from_family</span></span>(<span>self, font_family: str, font_style: str = '') ‑> <a title="fpdf.fonts.CoreFont" href="fonts.html#fpdf.fonts.CoreFont">CoreFont</a> | <a title="fpdf.fonts.TTFFont" href="fonts.html#fpdf.fonts.TTFFont">TTFFont</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L753-L827" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_font_from_family(
    self, font_family: str, font_style: str = &#34;&#34;
) -&gt; Union[&#34;CoreFont&#34;, &#34;TTFFont&#34;]:
    &#34;&#34;&#34;
    Resolve a family+style to a concrete font instance from the font registry.
    Behavior:
      - Exact match (family.lower() + style.upper()) in registry: return it
      - If `family` names a core font: add CoreFont to registry (if missing) and return it
      - If `family` is an alias/generic: translate to a core font, add to registry (if missing), and return it
      - Otherwise: raise KeyError

    Notes:
      - For Symbol/ZapfDingbats, style is forced to &#34;&#34; (they don&#39;t support B/I).
    &#34;&#34;&#34;
    if not font_family:
        raise KeyError(&#34;Empty font family&#34;)

    style = &#34;&#34;.join(sorted(font_style.upper()))

    alias = {
        # sans
        &#34;sans-serif&#34;: &#34;helvetica&#34;,
        &#34;sans serif&#34;: &#34;helvetica&#34;,
        &#34;arial&#34;: &#34;helvetica&#34;,
        &#34;verdana&#34;: &#34;helvetica&#34;,
        &#34;tahoma&#34;: &#34;helvetica&#34;,
        &#34;segoe ui&#34;: &#34;helvetica&#34;,
        # serif
        &#34;serif&#34;: &#34;times&#34;,
        &#34;times&#34;: &#34;times&#34;,
        &#34;times new roman&#34;: &#34;times&#34;,
        &#34;georgia&#34;: &#34;times&#34;,
        &#34;cambria&#34;: &#34;times&#34;,
        &#34;garamond&#34;: &#34;times&#34;,
        # mono
        &#34;monospace&#34;: &#34;courier&#34;,
        &#34;courier&#34;: &#34;courier&#34;,
        &#34;courier new&#34;: &#34;courier&#34;,
        &#34;consolas&#34;: &#34;courier&#34;,
        &#34;monaco&#34;: &#34;courier&#34;,
        # symbol
        &#34;symbol&#34;: &#34;symbol&#34;,
        &#34;zapfdingbats&#34;: &#34;zapfdingbats&#34;,
        &#34;zapf dingbats&#34;: &#34;zapfdingbats&#34;,
    }

    for candidate in font_family.strip().strip(&#34;&#39;\&#34;&#34;).split(&#34;,&#34;):
        family = candidate.strip().strip(&#34;&#39;\&#34;&#34;).lower()

        # 1) Exact match
        fontkey = f&#34;{family}{style}&#34;
        if fontkey in self.font_registry:
            return self.font_registry[fontkey]

        # 2) Core-family direct hit?
        if family in CORE_FONTS:
            core_style = &#34;&#34; if family in {&#34;symbol&#34;, &#34;zapfdingbats&#34;} else style
            key = f&#34;{family}{core_style}&#34;
            if key not in self.font_registry:
                i = len(self.font_registry) + 1
                self.font_registry[key] = CoreFont(i, key, core_style)
            return self.font_registry[key]

        # 3) Alias / generic mapping to core font
        mapped = alias.get(family)
        if mapped:
            core_style = &#34;&#34; if mapped in {&#34;symbol&#34;, &#34;zapfdingbats&#34;} else style
            key = f&#34;{mapped}{core_style}&#34;
            if key not in self.font_registry:
                i = len(self.font_registry) + 1
                self.font_registry[key] = CoreFont(i, key, core_style)
            return self.font_registry[key]

    # 4) Fail: do not return anything
    raise KeyError(f&#34;No suitable font for family={font_family!r}, style={style!r}&#34;)</code></pre>
</details>
<div class="desc"><p>Resolve a family+style to a concrete font instance from the font registry.</p>
<h2 id="behavior">Behavior</h2>
<ul>
<li>Exact match (family.lower() + style.upper()) in registry: return it</li>
<li>If <code>family</code> names a core font: add CoreFont to registry (if missing) and return it</li>
<li>If <code>family</code> is an alias/generic: translate to a core font, add to registry (if missing), and return it</li>
<li>Otherwise: raise KeyError</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>For Symbol/ZapfDingbats, style is forced to "" (they don't support B/I).</li>
</ul></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.get_items"><code class="name flex">
<span>def <span class="ident">get_items</span></span>(<span>self,<br>resource_type: <a title="fpdf.enums.PDFResourceType" href="enums.html#fpdf.enums.PDFResourceType">PDFResourceType</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L730-L731" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_items(self, resource_type: PDFResourceType):
    return self.resources[resource_type].items()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.get_resources_per_page"><code class="name flex">
<span>def <span class="ident">get_resources_per_page</span></span>(<span>self,<br>page_number: int,<br>resource_type: <a title="fpdf.enums.PDFResourceType" href="enums.html#fpdf.enums.PDFResourceType">PDFResourceType</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L733-L734" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_resources_per_page(self, page_number: int, resource_type: PDFResourceType):
    return self.resources_per_page[(page_number, resource_type)]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.get_used_resources"><code class="name flex">
<span>def <span class="ident">get_used_resources</span></span>(<span>self,<br>resource_type: <a title="fpdf.enums.PDFResourceType" href="enums.html#fpdf.enums.PDFResourceType">PDFResourceType</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L736-L741" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_used_resources(self, resource_type: PDFResourceType):
    unique = set()
    for (_, rtype), resource in self.resources_per_page.items():
        if rtype == resource_type:
            unique.update(resource)
    return unique</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.index_stream_resources"><code class="name flex">
<span>def <span class="ident">index_stream_resources</span></span>(<span>self, rendered: str, page_number: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L715-L728" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def index_stream_resources(self, rendered: str, page_number: int) -&gt; None:
    &#34;&#34;&#34;
    Scan a rendered content stream and register resources used on the given page.
    Currently indexes:
      - ExtGState invocations: &#39;/GSn gs&#39;
      - Image XObjects: &#39;/In Do&#39;
    &#34;&#34;&#34;
    for resource_type, resource in self.scan_stream(rendered):
        if resource_type == PDFResourceType.PATTERN:
            self.resources_per_page[(page_number, PDFResourceType.PATTERN)].add(
                resource
            )
        else:
            self.add(resource_type, resource, page_number)</code></pre>
</details>
<div class="desc"><p>Scan a rendered content stream and register resources used on the given page.
Currently indexes:
- ExtGState invocations: '/GSn gs'
- Image XObjects: '/In Do'</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.register_graphics_style"><code class="name flex">
<span>def <span class="ident">register_graphics_style</span></span>(<span>self, style)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L668-L684" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def register_graphics_style(self, style):
    &#34;&#34;&#34;
    Graphics style can be added without associating to a page number right away,
    like when rendering a svg image.
    The method that adds image to the page will call the add method for the page association.
    &#34;&#34;&#34;
    style_dict = style.serialize()
    if not style_dict:  # empty style does not need an entry
        return None

    if style_dict not in self.graphics_styles:
        name = Name(
            f&#34;{self._get_prefix(PDFResourceType.EXT_G_STATE)}{len(self.graphics_styles)}&#34;
        )
        self.graphics_styles[style_dict] = name

    return self.graphics_styles[style_dict]</code></pre>
</details>
<div class="desc"><p>Graphics style can be added without associating to a page number right away,
like when rendering a svg image.
The method that adds image to the page will call the add method for the page association.</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.register_soft_mask"><code class="name flex">
<span>def <span class="ident">register_soft_mask</span></span>(<span>self,<br>soft_mask: <a title="fpdf.drawing.PaintSoftMask" href="drawing.html#fpdf.drawing.PaintSoftMask">PaintSoftMask</a>) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L686-L692" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def register_soft_mask(self, soft_mask: PaintSoftMask) -&gt; int:
    &#34;&#34;&#34;Register a soft mask xobject and return its object id&#34;&#34;&#34;
    self.last_reserved_object_id += 1
    xobject = soft_mask_path_to_xobject(soft_mask, self)
    xobject.id = self.last_reserved_object_id
    self.soft_mask_xobjects.append(xobject)
    return xobject.id</code></pre>
</details>
<div class="desc"><p>Register a soft mask xobject and return its object id</p></div>
</dd>
<dt id="fpdf.output.ResourceCatalog.scan_stream"><code class="name flex">
<span>def <span class="ident">scan_stream</span></span>(<span>self, rendered: str) ‑> list[tuple[<a title="fpdf.enums.PDFResourceType" href="enums.html#fpdf.enums.PDFResourceType">PDFResourceType</a>, str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5fde9b27b421b8ee7a3cf0e1279ee91ff13c658e/fpdf/output.py#L694-L713" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def scan_stream(self, rendered: str) -&gt; list[tuple[PDFResourceType, str]]:
    &#34;&#34;&#34;Parse a content stream and return discovered resources&#34;&#34;&#34;
    found = set()

    for m in self.GS_REGEX.finditer(rendered):
        found.add((PDFResourceType.EXT_G_STATE, m.group(1)))

    for m in self.IMG_REGEX.finditer(rendered):
        found.add((PDFResourceType.X_OBJECT, int(m.group(1))))

    for m in self.PATTERN_FILL_REGEX.finditer(rendered):
        found.add((PDFResourceType.PATTERN, m.group(1)))

    for m in self.PATTERN_STROKE_REGEX.finditer(rendered):
        found.add((PDFResourceType.PATTERN, m.group(1)))

    for m in self.FONT_REGEX.finditer(rendered):
        found.add((PDFResourceType.FONT, int(m.group(1))))

    return found</code></pre>
</details>
<div class="desc"><p>Parse a content stream and return discovered resources</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.output.soft_mask_path_to_xobject" href="#fpdf.output.soft_mask_path_to_xobject">soft_mask_path_to_xobject</a></code></li>
<li><code><a title="fpdf.output.stream_content_for_raster_image" href="#fpdf.output.stream_content_for_raster_image">stream_content_for_raster_image</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.output.AcroForm" href="#fpdf.output.AcroForm">AcroForm</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.AcroForm.serialize" href="#fpdf.output.AcroForm.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.CIDSystemInfo" href="#fpdf.output.CIDSystemInfo">CIDSystemInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.CIDSystemInfo.content_stream" href="syntax.html#fpdf.output.CIDSystemInfo.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.CIDSystemInfo.serialize" href="syntax.html#fpdf.output.CIDSystemInfo.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.ContentWithoutID" href="#fpdf.output.ContentWithoutID">ContentWithoutID</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.ContentWithoutID.serialize" href="#fpdf.output.ContentWithoutID.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.OutputIntentDictionary" href="#fpdf.output.OutputIntentDictionary">OutputIntentDictionary</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.OutputIntentDictionary.dest_output_profile" href="#fpdf.output.OutputIntentDictionary.dest_output_profile">dest_output_profile</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.info" href="#fpdf.output.OutputIntentDictionary.info">info</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.output_condition" href="#fpdf.output.OutputIntentDictionary.output_condition">output_condition</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.output_condition_identifier" href="#fpdf.output.OutputIntentDictionary.output_condition_identifier">output_condition_identifier</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.registry_name" href="#fpdf.output.OutputIntentDictionary.registry_name">registry_name</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.s" href="#fpdf.output.OutputIntentDictionary.s">s</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.serialize" href="#fpdf.output.OutputIntentDictionary.serialize">serialize</a></code></li>
<li><code><a title="fpdf.output.OutputIntentDictionary.type" href="#fpdf.output.OutputIntentDictionary.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.OutputProducer" href="#fpdf.output.OutputProducer">OutputProducer</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.OutputProducer.bufferize" href="#fpdf.output.OutputProducer.bufferize">bufferize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFCatalog" href="#fpdf.output.PDFCatalog">PDFCatalog</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFCatalog.content_stream" href="syntax.html#fpdf.output.PDFCatalog.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFCatalog.serialize" href="syntax.html#fpdf.output.PDFCatalog.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFExtGState" href="#fpdf.output.PDFExtGState">PDFExtGState</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFExtGState.content_stream" href="syntax.html#fpdf.output.PDFExtGState.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFExtGState.serialize" href="#fpdf.output.PDFExtGState.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFFont" href="#fpdf.output.PDFFont">PDFFont</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFFont.content_stream" href="syntax.html#fpdf.output.PDFFont.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFFont.serialize" href="syntax.html#fpdf.output.PDFFont.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFFontStream" href="#fpdf.output.PDFFontStream">PDFFontStream</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFFontStream.content_stream" href="syntax.html#fpdf.output.PDFFontStream.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFFontStream.serialize" href="syntax.html#fpdf.output.PDFFontStream.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFHeader" href="#fpdf.output.PDFHeader">PDFHeader</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFHeader.serialize" href="#fpdf.output.PDFHeader.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFICCProfile" href="#fpdf.output.PDFICCProfile">PDFICCProfile</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.output.PDFICCProfile.alternate" href="#fpdf.output.PDFICCProfile.alternate">alternate</a></code></li>
<li><code><a title="fpdf.output.PDFICCProfile.content_stream" href="syntax.html#fpdf.output.PDFICCProfile.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFICCProfile.filter" href="#fpdf.output.PDFICCProfile.filter">filter</a></code></li>
<li><code><a title="fpdf.output.PDFICCProfile.length" href="#fpdf.output.PDFICCProfile.length">length</a></code></li>
<li><code><a title="fpdf.output.PDFICCProfile.n" href="#fpdf.output.PDFICCProfile.n">n</a></code></li>
<li><code><a title="fpdf.output.PDFICCProfile.serialize" href="syntax.html#fpdf.output.PDFICCProfile.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFInfo" href="#fpdf.output.PDFInfo">PDFInfo</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFInfo.content_stream" href="syntax.html#fpdf.output.PDFInfo.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFInfo.serialize" href="syntax.html#fpdf.output.PDFInfo.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFPage" href="#fpdf.output.PDFPage">PDFPage</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFPage.add_text_substitution" href="#fpdf.output.PDFPage.add_text_substitution">add_text_substitution</a></code></li>
<li><code><a title="fpdf.output.PDFPage.annots" href="#fpdf.output.PDFPage.annots">annots</a></code></li>
<li><code><a title="fpdf.output.PDFPage.content_stream" href="syntax.html#fpdf.output.PDFPage.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFPage.contents" href="#fpdf.output.PDFPage.contents">contents</a></code></li>
<li><code><a title="fpdf.output.PDFPage.dimensions" href="#fpdf.output.PDFPage.dimensions">dimensions</a></code></li>
<li><code><a title="fpdf.output.PDFPage.dur" href="#fpdf.output.PDFPage.dur">dur</a></code></li>
<li><code><a title="fpdf.output.PDFPage.get_label" href="#fpdf.output.PDFPage.get_label">get_label</a></code></li>
<li><code><a title="fpdf.output.PDFPage.get_page_label" href="#fpdf.output.PDFPage.get_page_label">get_page_label</a></code></li>
<li><code><a title="fpdf.output.PDFPage.get_text_substitutions" href="#fpdf.output.PDFPage.get_text_substitutions">get_text_substitutions</a></code></li>
<li><code><a title="fpdf.output.PDFPage.group" href="#fpdf.output.PDFPage.group">group</a></code></li>
<li><code><a title="fpdf.output.PDFPage.index" href="#fpdf.output.PDFPage.index">index</a></code></li>
<li><code><a title="fpdf.output.PDFPage.media_box" href="#fpdf.output.PDFPage.media_box">media_box</a></code></li>
<li><code><a title="fpdf.output.PDFPage.parent" href="#fpdf.output.PDFPage.parent">parent</a></code></li>
<li><code><a title="fpdf.output.PDFPage.resources" href="#fpdf.output.PDFPage.resources">resources</a></code></li>
<li><code><a title="fpdf.output.PDFPage.serialize" href="syntax.html#fpdf.output.PDFPage.serialize">serialize</a></code></li>
<li><code><a title="fpdf.output.PDFPage.set_dimensions" href="#fpdf.output.PDFPage.set_dimensions">set_dimensions</a></code></li>
<li><code><a title="fpdf.output.PDFPage.set_index" href="#fpdf.output.PDFPage.set_index">set_index</a></code></li>
<li><code><a title="fpdf.output.PDFPage.set_page_label" href="#fpdf.output.PDFPage.set_page_label">set_page_label</a></code></li>
<li><code><a title="fpdf.output.PDFPage.struct_parents" href="#fpdf.output.PDFPage.struct_parents">struct_parents</a></code></li>
<li><code><a title="fpdf.output.PDFPage.trans" href="#fpdf.output.PDFPage.trans">trans</a></code></li>
<li><code><a title="fpdf.output.PDFPage.type" href="#fpdf.output.PDFPage.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFPageLabel" href="#fpdf.output.PDFPageLabel">PDFPageLabel</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.output.PDFPageLabel.get_prefix" href="#fpdf.output.PDFPageLabel.get_prefix">get_prefix</a></code></li>
<li><code><a title="fpdf.output.PDFPageLabel.get_start" href="#fpdf.output.PDFPageLabel.get_start">get_start</a></code></li>
<li><code><a title="fpdf.output.PDFPageLabel.get_style" href="#fpdf.output.PDFPageLabel.get_style">get_style</a></code></li>
<li><code><a title="fpdf.output.PDFPageLabel.p" href="#fpdf.output.PDFPageLabel.p">p</a></code></li>
<li><code><a title="fpdf.output.PDFPageLabel.s" href="#fpdf.output.PDFPageLabel.s">s</a></code></li>
<li><code><a title="fpdf.output.PDFPageLabel.serialize" href="#fpdf.output.PDFPageLabel.serialize">serialize</a></code></li>
<li><code><a title="fpdf.output.PDFPageLabel.st" href="#fpdf.output.PDFPageLabel.st">st</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFPagesRoot" href="#fpdf.output.PDFPagesRoot">PDFPagesRoot</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFPagesRoot.content_stream" href="syntax.html#fpdf.output.PDFPagesRoot.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFPagesRoot.serialize" href="syntax.html#fpdf.output.PDFPagesRoot.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFResources" href="#fpdf.output.PDFResources">PDFResources</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFResources.content_stream" href="syntax.html#fpdf.output.PDFResources.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFResources.serialize" href="syntax.html#fpdf.output.PDFResources.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFType3Font" href="#fpdf.output.PDFType3Font">PDFType3Font</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.output.PDFType3Font.char_procs" href="#fpdf.output.PDFType3Font.char_procs">char_procs</a></code></li>
<li><code><a title="fpdf.output.PDFType3Font.content_stream" href="syntax.html#fpdf.output.PDFType3Font.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFType3Font.differences_table" href="#fpdf.output.PDFType3Font.differences_table">differences_table</a></code></li>
<li><code><a title="fpdf.output.PDFType3Font.encoding" href="#fpdf.output.PDFType3Font.encoding">encoding</a></code></li>
<li><code><a title="fpdf.output.PDFType3Font.generate_resources" href="#fpdf.output.PDFType3Font.generate_resources">generate_resources</a></code></li>
<li><code><a title="fpdf.output.PDFType3Font.serialize" href="syntax.html#fpdf.output.PDFType3Font.serialize">serialize</a></code></li>
<li><code><a title="fpdf.output.PDFType3Font.widths" href="#fpdf.output.PDFType3Font.widths">widths</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFXObject" href="#fpdf.output.PDFXObject">PDFXObject</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.output.PDFXObject.bits_per_component" href="#fpdf.output.PDFXObject.bits_per_component">bits_per_component</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.color_space" href="#fpdf.output.PDFXObject.color_space">color_space</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.content_stream" href="syntax.html#fpdf.output.PDFXObject.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.decode" href="#fpdf.output.PDFXObject.decode">decode</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.decode_parms" href="#fpdf.output.PDFXObject.decode_parms">decode_parms</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.filter" href="#fpdf.output.PDFXObject.filter">filter</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.height" href="#fpdf.output.PDFXObject.height">height</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.length" href="#fpdf.output.PDFXObject.length">length</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.s_mask" href="#fpdf.output.PDFXObject.s_mask">s_mask</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.serialize" href="syntax.html#fpdf.output.PDFXObject.serialize">serialize</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.subtype" href="#fpdf.output.PDFXObject.subtype">subtype</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.type" href="#fpdf.output.PDFXObject.type">type</a></code></li>
<li><code><a title="fpdf.output.PDFXObject.width" href="#fpdf.output.PDFXObject.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFXmpMetadata" href="#fpdf.output.PDFXmpMetadata">PDFXmpMetadata</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFXmpMetadata.content_stream" href="syntax.html#fpdf.output.PDFXmpMetadata.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.output.PDFXmpMetadata.serialize" href="syntax.html#fpdf.output.PDFXmpMetadata.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.PDFXrefAndTrailer" href="#fpdf.output.PDFXrefAndTrailer">PDFXrefAndTrailer</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.PDFXrefAndTrailer.serialize" href="#fpdf.output.PDFXrefAndTrailer.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.output.ResourceCatalog" href="#fpdf.output.ResourceCatalog">ResourceCatalog</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.ResourceCatalog.FONT_REGEX" href="#fpdf.output.ResourceCatalog.FONT_REGEX">FONT_REGEX</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.GS_REGEX" href="#fpdf.output.ResourceCatalog.GS_REGEX">GS_REGEX</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.IMG_REGEX" href="#fpdf.output.ResourceCatalog.IMG_REGEX">IMG_REGEX</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.PATTERN_FILL_REGEX" href="#fpdf.output.ResourceCatalog.PATTERN_FILL_REGEX">PATTERN_FILL_REGEX</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.PATTERN_STROKE_REGEX" href="#fpdf.output.ResourceCatalog.PATTERN_STROKE_REGEX">PATTERN_STROKE_REGEX</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.add" href="#fpdf.output.ResourceCatalog.add">add</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.get_font_from_family" href="#fpdf.output.ResourceCatalog.get_font_from_family">get_font_from_family</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.get_items" href="#fpdf.output.ResourceCatalog.get_items">get_items</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.get_resources_per_page" href="#fpdf.output.ResourceCatalog.get_resources_per_page">get_resources_per_page</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.get_used_resources" href="#fpdf.output.ResourceCatalog.get_used_resources">get_used_resources</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.index_stream_resources" href="#fpdf.output.ResourceCatalog.index_stream_resources">index_stream_resources</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.register_graphics_style" href="#fpdf.output.ResourceCatalog.register_graphics_style">register_graphics_style</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.register_soft_mask" href="#fpdf.output.ResourceCatalog.register_soft_mask">register_soft_mask</a></code></li>
<li><code><a title="fpdf.output.ResourceCatalog.scan_stream" href="#fpdf.output.ResourceCatalog.scan_stream">scan_stream</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
