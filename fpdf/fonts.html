<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fpdf.fonts API documentation</title>
<meta name="description" content="Font-related classes &amp; constants.
Includes the definition of the character widths of all PDF standard fonts …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.fonts</code></h1>
</header>
<section id="section-intro">
<p>Font-related classes &amp; constants.
Includes the definition of the character widths of all PDF standard fonts.</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
<p>Usage documentation at: <a href="https://py-pdf.github.io/fpdf2/Unicode.html">https://py-pdf.github.io/fpdf2/Unicode.html</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.fonts.CoreFont"><code class="flex name class">
<span>class <span class="ident">CoreFont</span></span>
<span>(</span><span>i: int, fontkey: str, style: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.CoreFont.cw"><code class="name">var <span class="ident">cw</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.emphasis"><code class="name">var <span class="ident">emphasis</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.fontkey"><code class="name">var <span class="ident">fontkey</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.i"><code class="name">var <span class="ident">i</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.sp"><code class="name">var <span class="ident">sp</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.ss"><code class="name">var <span class="ident">ss</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.ut"><code class="name">var <span class="ident">ut</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L279-L317" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
    )

    def __init__(self, i: int, fontkey: str, style: str) -&gt; None:
        self.i = i
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.sp = 250  # strikethrough horizontal position
        self.ss = 50  # strikethrough size (height)
        self.up = -100  # underline horizontal position
        self.ut = 50  # underline height
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(
        self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
    ) -&gt; tuple[int, float]:
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text: str) -&gt; str:
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self) -&gt; str:
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.CoreFont.encode_text"><code class="name flex">
<span>def <span class="ident">encode_text</span></span>(<span>self, text: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L313-L314" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def encode_text(self, text: str) -&gt; str:
    return f&#34;({escape_parens(text)}) Tj&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.get_text_width"><code class="name flex">
<span>def <span class="ident">get_text_width</span></span>(<span>self, text: str, font_size_pt: float, _: dict[str, typing.Any] | None) ‑> tuple[int, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L306-L309" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_text_width(
    self, text: str, font_size_pt: float, _: Optional[dict[str, Any]]
) -&gt; tuple[int, float]:
    return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.FontFace"><code class="flex name class">
<span>class <span class="ident">FontFace</span></span>
<span>(</span><span>family: str | None = None,<br>emphasis: <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a> | str | int | None = None,<br>size_pt: float | None = None,<br>color: <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | str | float | Sequence[float] | None = None,<br>fill_color: <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | str | float | Sequence[float] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L99-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[float]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]

    def __init__(
        self,
        family: Optional[str] = None,
        emphasis: Optional[TextEmphasis | str | int] = None,
        size_pt: Optional[float] = None,
        color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
        fill_color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value: Any, override_value: Any) -&gt; Any:
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(
        default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
    ) -&gt; Optional[&#34;FontFace&#34;]:
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"><p>Represent basic font styling properties.
This is a subset of <code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code> properties.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fonts.FontFace.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>default_style: <a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a> | None,<br>override_style: <a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a> | None) ‑> <a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L153-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def combine(
    default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
) -&gt; Optional[&#34;FontFace&#34;]:
    &#34;&#34;&#34;
    Create a combined FontFace with all the supplied features of the two styles. When both
    the default and override styles provide a feature, prefer the override style.
    Override specified FontFace style features
    Override this FontFace&#39;s values with the values of `other`.
    Values of `other` that are None in this FontFace will be kept unchanged.
    &#34;&#34;&#34;
    if override_style is None:
        return default_style
    if default_style is None:
        return override_style
    if not isinstance(override_style, FontFace):
        raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
    if not isinstance(default_style, FontFace):
        raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
    return FontFace(
        family=FontFace._override(default_style.family, override_style.family),
        emphasis=FontFace._override(
            default_style.emphasis,
            override_style.emphasis,
        ),
        size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
        color=FontFace._override(default_style.color, override_style.color),
        fill_color=FontFace._override(
            default_style.fill_color, override_style.fill_color
        ),
    )</code></pre>
</details>
<div class="desc"><p>Create a combined FontFace with all the supplied features of the two styles. When both
the default and override styles provide a feature, prefer the override style.
Override specified FontFace style features
Override this FontFace's values with the values of <code>other</code>.
Values of <code>other</code> that are None in this FontFace will be kept unchanged.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.FontFace.color"><code class="name">var <span class="ident">color</span> : <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L99-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[float]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]

    def __init__(
        self,
        family: Optional[str] = None,
        emphasis: Optional[TextEmphasis | str | int] = None,
        size_pt: Optional[float] = None,
        color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
        fill_color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value: Any, override_value: Any) -&gt; Any:
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(
        default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
    ) -&gt; Optional[&#34;FontFace&#34;]:
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.emphasis"><code class="name">var <span class="ident">emphasis</span> : <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L99-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[float]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]

    def __init__(
        self,
        family: Optional[str] = None,
        emphasis: Optional[TextEmphasis | str | int] = None,
        size_pt: Optional[float] = None,
        color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
        fill_color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value: Any, override_value: Any) -&gt; Any:
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(
        default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
    ) -&gt; Optional[&#34;FontFace&#34;]:
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.family"><code class="name">var <span class="ident">family</span> : str | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L99-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[float]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]

    def __init__(
        self,
        family: Optional[str] = None,
        emphasis: Optional[TextEmphasis | str | int] = None,
        size_pt: Optional[float] = None,
        color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
        fill_color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value: Any, override_value: Any) -&gt; Any:
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(
        default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
    ) -&gt; Optional[&#34;FontFace&#34;]:
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.fill_color"><code class="name">var <span class="ident">fill_color</span> : <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L99-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[float]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]

    def __init__(
        self,
        family: Optional[str] = None,
        emphasis: Optional[TextEmphasis | str | int] = None,
        size_pt: Optional[float] = None,
        color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
        fill_color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value: Any, override_value: Any) -&gt; Any:
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(
        default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
    ) -&gt; Optional[&#34;FontFace&#34;]:
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.size_pt"><code class="name">var <span class="ident">size_pt</span> : float | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L99-L183" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[float]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB, DeviceCMYK]]

    def __init__(
        self,
        family: Optional[str] = None,
        emphasis: Optional[TextEmphasis | str | int] = None,
        size_pt: Optional[float] = None,
        color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
        fill_color: Optional[
            DeviceRGB | DeviceGray | DeviceCMYK | str | float | Sequence[float]
        ] = None,
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace
    &#34;&#34;&#34;
    Create a new FontFace instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;

    @staticmethod
    def _override(current_value: Any, override_value: Any) -&gt; Any:
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(
        default_style: Optional[&#34;FontFace&#34;], override_style: Optional[&#34;FontFace&#34;]
    ) -&gt; Optional[&#34;FontFace&#34;]:
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.FontFace.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>obj, /, **changes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(obj, /, **changes):
    &#34;&#34;&#34;Return a new object replacing specified fields with new values.

    This is especially useful for frozen classes.  Example usage::

      @dataclass(frozen=True)
      class C:
          x: int
          y: int

      c = C(1, 2)
      c1 = replace(c, x=3)
      assert c1.x == 3 and c1.y == 2
    &#34;&#34;&#34;
    if not _is_dataclass_instance(obj):
        raise TypeError(&#34;replace() should be called on dataclass instances&#34;)
    return _replace(obj, **changes)</code></pre>
</details>
<div class="desc"><p>Return a new object replacing specified fields with new values.</p>
<p>This is especially useful for frozen classes.
Example usage::</p>
<p>@dataclass(frozen=True)
class C:
x: int
y: int</p>
<p>c = C(1, 2)
c1 = replace(c, x=3)
assert c1.x == 3 and c1.y == 2</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.Glyph"><code class="flex name class">
<span>class <span class="ident">Glyph</span></span>
<span>(</span><span>glyph_id: int, unicode: int | tuple[int, ...], glyph_name: str, glyph_width: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L920-L936" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: int | tuple[int, ...]
    glyph_name: str
    glyph_width: int

    def __hash__(self) -&gt; int:
        return self.glyph_id</code></pre>
</details>
<div class="desc"><p>This represents one glyph on the font
Unicode is a tuple because ligatures or character substitution
can map a sequence of unicode characters to a single glyph</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.Glyph.glyph_id"><code class="name">var <span class="ident">glyph_id</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L920-L936" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: int | tuple[int, ...]
    glyph_name: str
    glyph_width: int

    def __hash__(self) -&gt; int:
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.glyph_name"><code class="name">var <span class="ident">glyph_name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L920-L936" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: int | tuple[int, ...]
    glyph_name: str
    glyph_width: int

    def __hash__(self) -&gt; int:
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.glyph_width"><code class="name">var <span class="ident">glyph_width</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L920-L936" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: int | tuple[int, ...]
    glyph_name: str
    glyph_width: int

    def __hash__(self) -&gt; int:
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.unicode"><code class="name">var <span class="ident">unicode</span> : int | tuple[int, ...]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L920-L936" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: int | tuple[int, ...]
    glyph_name: str
    glyph_width: int

    def __hash__(self) -&gt; int:
        return self.glyph_id</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.PDFFontDescriptor"><code class="flex name class">
<span>class <span class="ident">PDFFontDescriptor</span></span>
<span>(</span><span>ascent: float,<br>descent: float,<br>cap_height: float,<br>flags: <a title="fpdf.enums.FontDescriptorFlags" href="enums.html#fpdf.enums.FontDescriptorFlags">FontDescriptorFlags</a>,<br>font_b_box: str,<br>italic_angle: int,<br>stem_v: float,<br>missing_width: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L895-L917" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PDFFontDescriptor(PDFObject):
    def __init__(
        self,
        ascent: float,
        descent: float,
        cap_height: float,
        flags: FontDescriptorFlags,
        font_b_box: str,
        italic_angle: int,
        stem_v: float,
        missing_width: float,
    ):
        super().__init__()
        self.type = Name(&#34;FontDescriptor&#34;)
        self.ascent = ascent
        self.descent = descent
        self.cap_height = cap_height
        self.flags = flags
        self.font_b_box = font_b_box
        self.italic_angle = italic_angle
        self.stem_v = stem_v
        self.missing_width = missing_width
        self.font_name: Optional[str] = None</code></pre>
</details>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.PDFFontDescriptor.content_stream"><code class="name flex">
<span>def <span class="ident">content_stream</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code>
</p>
<div class="desc inherited"><p>Subclasses can override this method to indicate the presence of a content stream</p></div>
</dd>
<dt id="fpdf.fonts.PDFFontDescriptor.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, obj_dict: Dict[str, object] | None = None) ‑> str</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></code>.<code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code>
</p>
<div class="desc inherited"><p>Serialize the PDF object as an obj&lt;&lt;/&gt;&gt;endobj text block</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.SubsetMap"><code class="flex name class">
<span>class <span class="ident">SubsetMap</span></span>
<span>(</span><span>font: <a title="fpdf.fonts.TTFFont" href="#fpdf.fonts.TTFFont">TTFFont</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L939-L1043" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class SubsetMap:
    &#34;&#34;&#34;
    Holds a mapping of used characters and their position in the font&#39;s subset

    Characters that must be mapped on their actual unicode must be part of the
    `identities` list during object instantiation. These non-negative values should
    only appear once in the list. `pick()` can be used to get the characters
    corresponding position in the subset. If it&#39;s not yet part of the object, a new
    position is acquired automatically. This implementation always tries to return
    the lowest possible representation.
    &#34;&#34;&#34;

    def __init__(self, font: TTFFont) -&gt; None:
        super().__init__()
        self.font = font
        self._next: int = 0

        # 0x00 &#34;.notdef&#34; and 0x20 &#34;space&#34; are reserved
        self._reserved = [0x00, 0x20]

        # Maps Glyph instances to character IDs (integers):
        self._char_id_per_glyph: dict[Optional[Glyph], int] = {}
        for x in self._reserved:
            glyph = self.get_glyph(unicode=x)
            if glyph:
                self._char_id_per_glyph[glyph] = int(x)

    def __repr__(self) -&gt; str:
        return (
            f&#34;SubsetMap(font={self.font}, _next={self._next},&#34;
            f&#34; _reserved={self._reserved}, _char_id_per_glyph={self._char_id_per_glyph})&#34;
        )

    def __len__(self) -&gt; int:
        return len(self._char_id_per_glyph)

    def items(self) -&gt; Iterator[tuple[Optional[Glyph], int]]:
        for glyph, char_id in self._char_id_per_glyph.items():
            yield glyph, char_id

    # pylint: disable=method-cache-max-size-none
    @cache
    def pick(self, unicode: int) -&gt; Optional[int]:
        glyph = self.get_glyph(unicode=unicode)
        if glyph is None and unicode not in self.font.missing_glyphs:
            self.font.missing_glyphs.append(unicode)
        return self.pick_glyph(glyph)

    def pick_glyph(self, glyph: Optional[Glyph]) -&gt; Optional[int]:
        char_id = self._char_id_per_glyph.get(glyph, None)
        if glyph is not None and char_id is None:
            while self._next in self._reserved:
                self._next += 1
                if self._next &gt; self._reserved[0]:
                    del self._reserved[0]
            char_id = self._next
            self._char_id_per_glyph[glyph] = char_id
            self._next += 1
        return char_id

    # pylint: disable=method-cache-max-size-none
    @cache
    def get_glyph(
        self,
        glyph: Optional[int] = None,
        unicode: Optional[int | tuple[int, ...]] = None,
        glyph_name: Optional[str] = None,
        glyph_width: Optional[int] = None,
    ) -&gt; Optional[Glyph]:
        if (
            glyph
            and unicode is not None
            and glyph_name is not None
            and glyph_width is not None
        ):
            return Glyph(glyph, unicode, glyph_name, glyph_width)
        if unicode is None or not isinstance(unicode, int):
            return None
        if self.font.is_symbol and 0x20 &lt;= unicode &lt;= 0xFF and unicode != 0x7F:
            unicode = 0xF000 + unicode
        glyph_id = self.font.glyph_ids.get(unicode)
        if isinstance(unicode, int) and glyph_id is not None:
            return Glyph(
                glyph_id,
                (unicode,),
                self.font.cmap[unicode],
                int(self.font.cw[unicode]),
            )
        if unicode == 0x00:
            glyph_id = next(iter(self.font.cmap))
            return Glyph(glyph_id, (0x00,), &#34;.notdef&#34;, 0)
        if unicode == 0x20:
            if 0x20 in self.font.cmap:
                glyph_name = self.font.cmap[0x20]
                glyph_id = self.font.glyph_ids.get(0x20, next(iter(self.font.cmap)))
            else:
                glyph_name = next(iter(self.font.cmap.values()))
                glyph_id = next(iter(self.font.cmap))
            return Glyph(glyph_id, (0x20,), glyph_name, int(self.font.cw[0x20]))
        return None

    def get_all_glyph_names(self) -&gt; Sequence[str]:
        return [
            glyph.glyph_name for glyph in self._char_id_per_glyph if glyph is not None
        ]</code></pre>
</details>
<div class="desc"><p>Holds a mapping of used characters and their position in the font's subset</p>
<p>Characters that must be mapped on their actual unicode must be part of the
<code>identities</code> list during object instantiation. These non-negative values should
only appear once in the list. <code>pick()</code> can be used to get the characters
corresponding position in the subset. If it's not yet part of the object, a new
position is acquired automatically. This implementation always tries to return
the lowest possible representation.</p></div>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.SubsetMap.get_all_glyph_names"><code class="name flex">
<span>def <span class="ident">get_all_glyph_names</span></span>(<span>self) ‑> Sequence[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L1040-L1043" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_all_glyph_names(self) -&gt; Sequence[str]:
    return [
        glyph.glyph_name for glyph in self._char_id_per_glyph if glyph is not None
    ]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.get_glyph"><code class="name flex">
<span>def <span class="ident">get_glyph</span></span>(<span>self,<br>glyph: int | None = None,<br>unicode: int | tuple[int, ...] | None = None,<br>glyph_name: str | None = None,<br>glyph_width: int | None = None) ‑> <a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L1000-L1038" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@cache
def get_glyph(
    self,
    glyph: Optional[int] = None,
    unicode: Optional[int | tuple[int, ...]] = None,
    glyph_name: Optional[str] = None,
    glyph_width: Optional[int] = None,
) -&gt; Optional[Glyph]:
    if (
        glyph
        and unicode is not None
        and glyph_name is not None
        and glyph_width is not None
    ):
        return Glyph(glyph, unicode, glyph_name, glyph_width)
    if unicode is None or not isinstance(unicode, int):
        return None
    if self.font.is_symbol and 0x20 &lt;= unicode &lt;= 0xFF and unicode != 0x7F:
        unicode = 0xF000 + unicode
    glyph_id = self.font.glyph_ids.get(unicode)
    if isinstance(unicode, int) and glyph_id is not None:
        return Glyph(
            glyph_id,
            (unicode,),
            self.font.cmap[unicode],
            int(self.font.cw[unicode]),
        )
    if unicode == 0x00:
        glyph_id = next(iter(self.font.cmap))
        return Glyph(glyph_id, (0x00,), &#34;.notdef&#34;, 0)
    if unicode == 0x20:
        if 0x20 in self.font.cmap:
            glyph_name = self.font.cmap[0x20]
            glyph_id = self.font.glyph_ids.get(0x20, next(iter(self.font.cmap)))
        else:
            glyph_name = next(iter(self.font.cmap.values()))
            glyph_id = next(iter(self.font.cmap))
        return Glyph(glyph_id, (0x20,), glyph_name, int(self.font.cw[0x20]))
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self) ‑> Iterator[tuple[<a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a> | None, int]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L975-L977" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def items(self) -&gt; Iterator[tuple[Optional[Glyph], int]]:
    for glyph, char_id in self._char_id_per_glyph.items():
        yield glyph, char_id</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.pick"><code class="name flex">
<span>def <span class="ident">pick</span></span>(<span>self, unicode: int) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L980-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@cache
def pick(self, unicode: int) -&gt; Optional[int]:
    glyph = self.get_glyph(unicode=unicode)
    if glyph is None and unicode not in self.font.missing_glyphs:
        self.font.missing_glyphs.append(unicode)
    return self.pick_glyph(glyph)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.pick_glyph"><code class="name flex">
<span>def <span class="ident">pick_glyph</span></span>(<span>self,<br>glyph: <a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a> | None) ‑> int | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L987-L997" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def pick_glyph(self, glyph: Optional[Glyph]) -&gt; Optional[int]:
    char_id = self._char_id_per_glyph.get(glyph, None)
    if glyph is not None and char_id is None:
        while self._next in self._reserved:
            self._next += 1
            if self._next &gt; self._reserved[0]:
                del self._reserved[0]
        char_id = self._next
        self._char_id_per_glyph[glyph] = char_id
        self._next += 1
    return char_id</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.TTFFont"><code class="flex name class">
<span>class <span class="ident">TTFFont</span></span>
<span>(</span><span>fpdf: FPDF,<br>font_file_path: pathlib.Path,<br>fontkey: str,<br>style: str,<br>unicode_range: set[int] | None = None,<br>axes_dict: dict[str, float] | None = None,<br>palette_index: int | None = None,<br>collection_font_number: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.TTFFont.biggest_size_pt"><code class="name">var <span class="ident">biggest_size_pt</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.cff_ros"><code class="name">var <span class="ident">cff_ros</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.cmap"><code class="name">var <span class="ident">cmap</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.collection_font_number"><code class="name">var <span class="ident">collection_font_number</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.color_font"><code class="name">var <span class="ident">color_font</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.cw"><code class="name">var <span class="ident">cw</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.desc"><code class="name">var <span class="ident">desc</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.emphasis"><code class="name">var <span class="ident">emphasis</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.fontkey"><code class="name">var <span class="ident">fontkey</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.glyph_ids"><code class="name">var <span class="ident">glyph_ids</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.hbfont"><code class="name">prop <span class="ident">hbfont</span> : HarfBuzzFont</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L571-L625" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
    if not self._hbfont:

        if self.is_compressed:
            # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
            # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
            buf = BytesIO()
            self.ttfont.save(buf)
            buf.seek(0)
            ttfont_bytes = buf.read()

            # Try to create a HarfBuzz blob from bytes; if not available, write a
            # temporary file as a last resort.
            try:
                blob = hb.Blob.from_bytes(ttfont_bytes)
                face = hb.Face(blob=blob, index=self.collection_font_number)
            except (AttributeError, RuntimeError):
                import tempfile, os  # pylint: disable=import-outside-toplevel

                tmp_name = None
                try:
                    with tempfile.NamedTemporaryFile(
                        suffix=&#34;.ttf&#34;, delete=False
                    ) as tmp:
                        tmp_name = tmp.name
                        tmp.write(ttfont_bytes)
                        tmp.flush()
                    face = hb.Face(
                        blob=hb.Blob.from_file_path(tmp_name),
                        index=self.collection_font_number,
                    )
                finally:
                    if tmp_name:
                        try:
                            os.unlink(tmp_name)
                        except OSError as cleanup_error:
                            # Log warning about failed cleanup - orphaned temp file may cause disk issues
                            LOGGER.warning(
                                &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                tmp_name,
                                cleanup_error,
                            )

            self._hbfont = HarfBuzzFont(face)
        else:
            # For regular TTF/OTF fonts, load directly from file path (faster)
            self._hbfont = HarfBuzzFont(
                hb.Face(
                    blob=hb.Blob.from_file_path(self.ttffile),
                    index=self.collection_font_number,
                )
            )

    return self._hbfont</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.i"><code class="name">var <span class="ident">i</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.is_cff"><code class="name">var <span class="ident">is_cff</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.is_cid_keyed"><code class="name">var <span class="ident">is_cid_keyed</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.is_compressed"><code class="name">var <span class="ident">is_compressed</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.is_symbol"><code class="name">var <span class="ident">is_symbol</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.missing_glyphs"><code class="name">var <span class="ident">missing_glyphs</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.palette_index"><code class="name">var <span class="ident">palette_index</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.sp"><code class="name">var <span class="ident">sp</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ss"><code class="name">var <span class="ident">ss</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.subset"><code class="name">var <span class="ident">subset</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ttffile"><code class="name">var <span class="ident">ttffile</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ttfont"><code class="name">var <span class="ident">ttfont</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.unicode_range"><code class="name">var <span class="ident">unicode_range</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ut"><code class="name">var <span class="ident">ut</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L320-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;_hbfont&#34;,
        &#34;sp&#34;,
        &#34;ss&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
        &#34;biggest_size_pt&#34;,
        &#34;color_font&#34;,
        &#34;unicode_range&#34;,
        &#34;palette_index&#34;,
        &#34;is_compressed&#34;,
        &#34;is_cff&#34;,
        &#34;is_cid_keyed&#34;,
        &#34;is_symbol&#34;,
        &#34;cff_ros&#34;,
        &#34;collection_font_number&#34;,
    )

    def __init__(
        self,
        fpdf: &#34;FPDF&#34;,
        font_file_path: Path,
        fontkey: str,
        style: str,
        unicode_range: Optional[set[int]] = None,
        axes_dict: Optional[dict[str, float]] = None,
        palette_index: Optional[int] = None,
        collection_font_number: int = 0,
    ):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.is_compressed = str(self.ttffile).lower().endswith((&#34;.woff&#34;, &#34;.woff2&#34;))
        self._hbfont: Optional[&#34;HarfBuzzFont&#34;] = None
        self.fontkey = fontkey
        self.biggest_size_pt: float = 0
        self.collection_font_number = collection_font_number

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        try:
            self.ttfont = ttLib.TTFont(
                self.ttffile,
                recalcTimestamp=False,
                fontNumber=collection_font_number,
                lazy=True,
            )
        except (
            ImportError,
            RuntimeError,
        ) as exc:  # pragma: no cover - defensive messaging
            # If the user passed a WOFF2 file but brotli is not installed, fontTools
            # raises an ImportError/RuntimeError during parsing. Provide a clearer hint
            # only for that specific situation. Allow other exceptions (e.g. FileNotFoundError,
            # OSError, parsing errors) to propagate normally so they aren&#39;t masked here.
            fname_str = str(self.ttffile).lower()
            if fname_str.endswith(&#34;.woff2&#34;):
                raise RuntimeError(
                    &#34;Could not open WOFF2 font. WOFF2 support requires an external Brotli &#34;
                    &#34;library (install &#39;brotli&#39; or &#39;brotlicffi&#39;). Original error: &#34;
                    f&#34;{exc!s}&#34;
                ) from exc
            raise

        if axes_dict is not None:
            if &#34;fvar&#34; not in self.ttfont:
                raise AttributeError(f&#34;{self.ttffile} is not a variable font&#34;)

            instancer.instantiateVariableFont(
                self.ttfont,
                axes_dict,
                inplace=True,
                static=True,
            )
        if self.is_compressed:
            # Normalize to SFNT output for embedding and HarfBuzz.
            self.ttfont.flavor = None
        self.is_cff = &#34;CFF &#34; in self.ttfont or &#34;CFF2&#34; in self.ttfont
        self.is_cid_keyed = False
        self.is_symbol = False
        self.cff_ros: Optional[tuple[str, str, int]] = None
        if self.is_cff:
            try:
                cff_table = &#34;CFF &#34; if &#34;CFF &#34; in self.ttfont else &#34;CFF2&#34;
                top_dict = self.ttfont[cff_table].cff.topDictIndex[0]
                ros = getattr(top_dict, &#34;ROS&#34;, None)
                self.is_cid_keyed = ros is not None
                if ros is not None:
                    self.cff_ros = (str(ros[0]), str(ros[1]), int(ros[2]))
            except (
                KeyError,
                AttributeError,
                IndexError,
                TypeError,
            ):  # pragma: no cover
                self.is_cid_keyed = False
        upem: float = float(self.ttfont[&#34;head&#34;].unitsPerEm)
        self.scale: float = 1000 / upem

        # check if the font is a TrueType and missing a .notdef glyph
        # if it is missing, provide a fallback glyph
        if (
            &#34;glyf&#34; in self.ttfont
            and &#34;.notdef&#34;
            not in self.ttfont[&#34;glyf&#34;]  # pyright: ignore[reportOperatorIssue]
        ):
            LOGGER.warning(
                (
                    &#34;TrueType Font &#39;%s&#39; is missing the &#39;.notdef&#39; glyph. &#34;
                    &#34;Fallback glyph will be provided.&#34;
                ),
                self.fontkey,
            )
            # draw a diagonal cross .notdef glyph
            xMin, xMax, yMin, yMax = (
                self.ttfont[&#34;head&#34;].xMin,
                self.ttfont[&#34;head&#34;].xMax,
                self.ttfont[&#34;head&#34;].yMin,
                self.ttfont[&#34;head&#34;].yMax,
            )
            pen = TTGlyphPen(self.ttfont[&#34;glyf&#34;])  # pyright: ignore[reportArgumentType]
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMin))
            pen.lineTo((xMax, yMax))
            pen.lineTo((xMin, yMax))
            pen.closePath()
            pen.moveTo((xMin, yMin))
            pen.lineTo((xMax, yMax))
            pen.closePath()
            pen.moveTo((xMax, yMin))
            pen.lineTo((xMin, yMax))
            pen.closePath()

            self.ttfont[&#34;glyf&#34;][  # pyright: ignore[reportIndexIssue]
                &#34;.notdef&#34;
            ] = pen.glyph()
            self.ttfont[&#34;hmtx&#34;][&#34;.notdef&#34;] = (  # pyright: ignore[reportIndexIssue]
                xMax - xMin,
                yMax - yMin,
            )

        default_width: float = round(
            self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0]
        )

        os2_table = self.ttfont[&#34;OS/2&#34;]
        post_table = self.ttfont[&#34;post&#34;]

        try:
            cap_height = os2_table.sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if post_table.isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if post_table.italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if os2_table.usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(post_table.italicAngle),
            stem_v=round(50 + int(pow((os2_table.usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw: dict[int, float] = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap: dict[int, str] = self.ttfont.getBestCmap()
        if not self.cmap:
            self.cmap = self._build_symbol_cmap()
            if self.cmap:
                self.is_symbol = True
            else:
                raise NotImplementedError(
                    &#34;Font not supported. No unicode cmap and no support for this non-standard charset.&#34;
                )

        if unicode_range is not None and len(unicode_range) != 0:
            self.cmap = {
                codepoint: glyph_id
                for codepoint, glyph_id in self.cmap.items()  # pyright: ignore[reportUnknownVariableType]
                if codepoint in unicode_range
            }

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:  # pyright: ignore[]
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs: list[int] = []

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(post_table.underlinePosition * self.scale)
        self.ut = round(post_table.underlineThickness * self.scale)
        self.sp = round(os2_table.yStrikeoutPosition * self.scale)
        self.ss = round(os2_table.yStrikeoutSize * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self)
        self.palette_index = palette_index if palette_index is not None else 0
        self.color_font = (
            get_color_font_object(fpdf, self, self.palette_index)
            if fpdf.render_color_fonts
            else None
        )

    # pylint: disable=no-member
    @property
    def hbfont(self) -&gt; &#34;HarfBuzzFont&#34;:
        if not self._hbfont:

            if self.is_compressed:
                # HarfBuzz cannot load compressed WOFF/WOFF2 files directly, so we
                # re-serialize the fontTools TTFont to a raw SFNT byte buffer.
                buf = BytesIO()
                self.ttfont.save(buf)
                buf.seek(0)
                ttfont_bytes = buf.read()

                # Try to create a HarfBuzz blob from bytes; if not available, write a
                # temporary file as a last resort.
                try:
                    blob = hb.Blob.from_bytes(ttfont_bytes)
                    face = hb.Face(blob=blob, index=self.collection_font_number)
                except (AttributeError, RuntimeError):
                    import tempfile, os  # pylint: disable=import-outside-toplevel

                    tmp_name = None
                    try:
                        with tempfile.NamedTemporaryFile(
                            suffix=&#34;.ttf&#34;, delete=False
                        ) as tmp:
                            tmp_name = tmp.name
                            tmp.write(ttfont_bytes)
                            tmp.flush()
                        face = hb.Face(
                            blob=hb.Blob.from_file_path(tmp_name),
                            index=self.collection_font_number,
                        )
                    finally:
                        if tmp_name:
                            try:
                                os.unlink(tmp_name)
                            except OSError as cleanup_error:
                                # Log warning about failed cleanup - orphaned temp file may cause disk issues
                                LOGGER.warning(
                                    &#34;Failed to clean up temporary font file &#39;%s&#39;: %s. This may leave an orphaned file on disk.&#34;,
                                    tmp_name,
                                    cleanup_error,
                                )

                self._hbfont = HarfBuzzFont(face)
            else:
                # For regular TTF/OTF fonts, load directly from file path (faster)
                self._hbfont = HarfBuzzFont(
                    hb.Face(
                        blob=hb.Blob.from_file_path(self.ttffile),
                        index=self.collection_font_number,
                    )
                )

        return self._hbfont

    def __repr__(self) -&gt; str:
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def __deepcopy__(self: &#34;TTFFont&#34;, memo: dict[int, Any]) -&gt; &#34;TTFFont&#34;:
        &#34;&#34;&#34;
        The aim here is that FPDFRecorder.__init__() does NOT deepcopy all fonts attributes
        but instead share references to immutable objects
        between the original FPDF instance and the FPDFRecorder instances
        to avoid performances issues as spotted in issue #1444.
        &#34;&#34;&#34;
        copy = TTFFont.__new__(TTFFont)
        # Immutable attributes:
        copy.i = self.i
        copy.type = &#34;TTF&#34;
        copy.ttffile = self.ttffile
        copy.fontkey = self.fontkey
        copy.scale = self.scale
        copy.name = self.name
        copy.up = self.up
        copy.ut = self.ut
        copy.sp = self.sp
        copy.ss = self.ss
        copy.emphasis = self.emphasis
        copy.is_compressed = self.is_compressed
        copy.is_cff = self.is_cff
        copy.is_cid_keyed = self.is_cid_keyed
        copy.is_symbol = self.is_symbol
        copy.cff_ros = self.cff_ros
        copy.collection_font_number = self.collection_font_number
        # Attributes shared, to improve FPDFRecorder performances:
        copy.ttfont = self.ttfont
        copy.cmap = self.cmap
        copy.desc = self.desc
        # Attributes deepcopied:
        copy.cw = deepcopy(self.cw, memo)
        copy.glyph_ids = deepcopy(self.glyph_ids, memo)
        copy.missing_glyphs = deepcopy(self.missing_glyphs, memo)
        copy.subset = deepcopy(self.subset, memo)
        copy.biggest_size_pt = self.biggest_size_pt
        copy._hbfont = self._hbfont
        copy.color_font = self.color_font
        copy.palette_index = self.palette_index
        return copy

    def close(self) -&gt; None:
        self.ttfont.close()
        self._hbfont = None

    def _build_symbol_cmap(self) -&gt; dict[int, str]:
        &#34;&#34;&#34;
        Build a Unicode cmap from a Microsoft Non-Standard Symbol cmap.
        Maps bytes 0x00-0xFF to the PUA range U+F000-U+F0FF.
        Reference: https://learn.microsoft.com/en-us/typography/opentype/otspec160/recom
        &#34;&#34;&#34;
        try:
            cmap_table = self.ttfont[&#34;cmap&#34;]
        except KeyError:  # pragma: no cover - defensive
            return {}
        symbol_table = None
        for table in cmap_table.tables:
            if table.platformID == 3 and table.platEncID == 0:
                symbol_table = table
                break
        if not symbol_table:
            return {}
        mapping: dict[int, str] = {}
        for code, glyph in symbol_table.cmap.items():
            if code &lt;= 0xFF:
                mapping[0xF000 + code] = glyph
            else:
                mapping[code] = glyph
        return mapping

    def _map_symbol_text(self, text: str) -&gt; str:
        if not self.is_symbol:
            return text
        mapped_chars = []
        for ch in text:
            code = ord(ch)
            if 0xF000 &lt;= code &lt;= 0xF0FF:
                mapped_chars.append(ch)
            elif 0x20 &lt;= code &lt;= 0xFF and code != 0x7F:
                mapped_chars.append(chr(0xF000 + code))
            else:
                mapped_chars.append(ch)
        return &#34;&#34;.join(mapped_chars)

    def escape_text(self, text: str) -&gt; str:
        if self.color_font:
            encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
            return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
        return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))

    def get_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        if font_size_pt &gt; self.biggest_size_pt:
            self.biggest_size_pt = font_size_pt
        mapped_text = self._map_symbol_text(text)
        if text_shaping_params:
            return self.shaped_text_width(
                mapped_text, font_size_pt, text_shaping_params
            )
        return (
            len(mapped_text),
            sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
        )

    def shaped_text_width(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[int, float]:
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width: float = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        text = self._map_symbol_text(text)
        self.hbfont.ptem = font_size_pt
        if TYPE_CHECKING:
            buf: HBBuffer
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = (
            text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
        )
        if text_shaping_params is None:
            text_shaping_params = {}
        if (
            &#34;fragment_direction&#34; in text_shaping_params
            and text_shaping_params[&#34;fragment_direction&#34;] is not None
        ):
            buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
        if (
            &#34;script&#34; in text_shaping_params
            and text_shaping_params[&#34;script&#34;] is not None
        ):
            buf.script = text_shaping_params[&#34;script&#34;]
        if (
            &#34;language&#34; in text_shaping_params
            and text_shaping_params[&#34;language&#34;] is not None
        ):
            buf.language = text_shaping_params[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text: str) -&gt; str:
        text = self._map_symbol_text(text)
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            mapped_char: Optional[int] = self.subset.pick(uni)
            if mapped_char is not None:
                txt_mapped += chr(mapped_char)
        return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;

    def shape_text(
        self,
        text: str,
        font_size_pt: float,
        text_shaping_params: Optional[dict[str, Any]],
    ) -&gt; Sequence[dict[str, Any]]:
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_params
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping: dict[int, list[int]] = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            if glyph is None:
                continue
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.TTFFont.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L671-L673" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    self.ttfont.close()
    self._hbfont = None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.encode_text"><code class="name flex">
<span>def <span class="ident">encode_text</span></span>(<span>self, text: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L806-L816" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def encode_text(self, text: str) -&gt; str:
    text = self._map_symbol_text(text)
    txt_mapped = &#34;&#34;
    for char in text:
        uni = ord(char)
        # Instead of adding the actual character to the stream its code is
        # mapped to a position in the font&#39;s subset
        mapped_char: Optional[int] = self.subset.pick(uni)
        if mapped_char is not None:
            txt_mapped += chr(mapped_char)
    return f&#34;({self.escape_text(txt_mapped)}) Tj&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.escape_text"><code class="name flex">
<span>def <span class="ident">escape_text</span></span>(<span>self, text: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L714-L718" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def escape_text(self, text: str) -&gt; str:
    if self.color_font:
        encoded = text.encode(&#34;latin-1&#34;, errors=&#34;replace&#34;)
        return escape_parens(encoded.decode(&#34;latin-1&#34;, errors=&#34;ignore&#34;))
    return escape_parens(text.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.get_text_width"><code class="name flex">
<span>def <span class="ident">get_text_width</span></span>(<span>self,<br>text: str,<br>font_size_pt: float,<br>text_shaping_params: dict[str, typing.Any] | None) ‑> tuple[int, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L720-L736" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_text_width(
    self,
    text: str,
    font_size_pt: float,
    text_shaping_params: Optional[dict[str, Any]],
) -&gt; tuple[int, float]:
    if font_size_pt &gt; self.biggest_size_pt:
        self.biggest_size_pt = font_size_pt
    mapped_text = self._map_symbol_text(text)
    if text_shaping_params:
        return self.shaped_text_width(
            mapped_text, font_size_pt, text_shaping_params
        )
    return (
        len(mapped_text),
        sum(self.cw[ord(c)] for c in mapped_text) * font_size_pt * 0.001,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.perform_harfbuzz_shaping"><code class="name flex">
<span>def <span class="ident">perform_harfbuzz_shaping</span></span>(<span>self,<br>text: str,<br>font_size_pt: float,<br>text_shaping_params: dict[str, typing.Any] | None) ‑> tuple[typing.Sequence[HBGlyphInfo], typing.Sequence[HBGlyphPosition]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L766-L804" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def perform_harfbuzz_shaping(
    self,
    text: str,
    font_size_pt: float,
    text_shaping_params: Optional[dict[str, Any]],
) -&gt; tuple[Sequence[&#34;HBGlyphInfo&#34;], Sequence[&#34;HBGlyphPosition&#34;]]:
    &#34;&#34;&#34;
    This method invokes Harfbuzz to perform text shaping of the input string
    &#34;&#34;&#34;
    text = self._map_symbol_text(text)
    self.hbfont.ptem = font_size_pt
    if TYPE_CHECKING:
        buf: HBBuffer
    buf = hb.Buffer()
    buf.cluster_level = 1
    buf.add_str(&#34;&#34;.join(text))
    buf.guess_segment_properties()
    features = (
        text_shaping_params[&#34;features&#34;] if text_shaping_params is not None else {}
    )
    if text_shaping_params is None:
        text_shaping_params = {}
    if (
        &#34;fragment_direction&#34; in text_shaping_params
        and text_shaping_params[&#34;fragment_direction&#34;] is not None
    ):
        buf.direction = text_shaping_params[&#34;fragment_direction&#34;].value
    if (
        &#34;script&#34; in text_shaping_params
        and text_shaping_params[&#34;script&#34;] is not None
    ):
        buf.script = text_shaping_params[&#34;script&#34;]
    if (
        &#34;language&#34; in text_shaping_params
        and text_shaping_params[&#34;language&#34;] is not None
    ):
        buf.language = text_shaping_params[&#34;language&#34;]
    hb.shape(self.hbfont, buf, features)
    return buf.glyph_infos, buf.glyph_positions</code></pre>
</details>
<div class="desc"><p>This method invokes Harfbuzz to perform text shaping of the input string</p></div>
</dd>
<dt id="fpdf.fonts.TTFFont.shape_text"><code class="name flex">
<span>def <span class="ident">shape_text</span></span>(<span>self,<br>text: str,<br>font_size_pt: float,<br>text_shaping_params: dict[str, typing.Any] | None) ‑> Sequence[dict[str, Any]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L818-L892" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def shape_text(
    self,
    text: str,
    font_size_pt: float,
    text_shaping_params: Optional[dict[str, Any]],
) -&gt; Sequence[dict[str, Any]]:
    &#34;&#34;&#34;
    This method will invoke harfbuzz for text shaping, include the mapping code
    of the glyphs on the subset and map input characters to the cluster codes
    &#34;&#34;&#34;
    if len(text) == 0:
        return []
    glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
        text, font_size_pt, text_shaping_params
    )
    text_info = []

    # Find cluster gaps
    # Ex: text = &#34;ABCD&#34;
    # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
    # (ligature or substitution) - the glyph should have both unicodes and it should be translated
    # properly on the CID to GID mapping
    #
    def get_cluster_from_text_index(cluster_list: Sequence[int], index: int) -&gt; int:
        pos = bisect_left(cluster_list, index)
        if pos == 0:
            return cluster_list[0]
        if pos == len(cluster_list) or cluster_list[pos] != index:
            return cluster_list[pos - 1]
        return cluster_list[pos]

    cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
    cluster_mapping: dict[int, list[int]] = {}
    for i in range(len(text)):
        cl = get_cluster_from_text_index(cluster_list, i)
        if cl in cluster_mapping:
            cluster_mapping[cl].append(i)
        else:
            cluster_mapping[cl] = [i]

    for cluster_seq, gi in enumerate(glyph_infos):
        unicode = []
        if gi.cluster in cluster_mapping:
            unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
            cluster_mapping.pop(gi.cluster)

        gname = self.ttfont.getGlyphName(gi.codepoint)
        gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
        glyph = self.subset.get_glyph(
            glyph=gi.codepoint,
            unicode=tuple(unicode),
            glyph_name=gname,
            glyph_width=gwidth,
        )
        if glyph is None:
            continue
        force_positioning = False
        if (
            gwidth != glyph_positions[cluster_seq].x_advance
            or glyph_positions[cluster_seq].x_offset != 0
            or glyph_positions[cluster_seq].y_offset != 0
            or glyph_positions[cluster_seq].y_advance != 0
        ):
            force_positioning = True
        text_info.append(
            {
                &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                &#34;force_positioning&#34;: force_positioning,
            }
        )
    return text_info</code></pre>
</details>
<div class="desc"><p>This method will invoke harfbuzz for text shaping, include the mapping code
of the glyphs on the subset and map input characters to the cluster codes</p></div>
</dd>
<dt id="fpdf.fonts.TTFFont.shaped_text_width"><code class="name flex">
<span>def <span class="ident">shaped_text_width</span></span>(<span>self,<br>text: str,<br>font_size_pt: float,<br>text_shaping_params: dict[str, typing.Any] | None) ‑> tuple[int, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L738-L762" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def shaped_text_width(
    self,
    text: str,
    font_size_pt: float,
    text_shaping_params: Optional[dict[str, Any]],
) -&gt; tuple[int, float]:
    &#34;&#34;&#34;
    When texts are shaped, the length of a string is not always the sum of all individual character widths
    This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
    and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
    &#34;&#34;&#34;
    _, glyph_positions = self.perform_harfbuzz_shaping(
        text, font_size_pt, text_shaping_params
    )

    # If there is nothing to render (harfbuzz returns None), we return 0 text width
    if glyph_positions is None:
        return (0, 0)

    text_width: float = 0
    for pos in glyph_positions:
        text_width += (
            round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
        )
    return (len(glyph_positions), text_width)</code></pre>
</details>
<div class="desc"><p>When texts are shaped, the length of a string is not always the sum of all individual character widths
This method will invoke harfbuzz to perform the text shaping and return the sum of "x_advance"
and "x_offset" for each glyph. This method works for "left to right" or "right to left" texts.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.TextStyle"><code class="flex name class">
<span>class <span class="ident">TextStyle</span></span>
<span>(</span><span>font_family: str | None = None,<br>font_style: str | <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a> | None = None,<br>font_size_pt: float | None = None,<br>color: <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | str | float | Sequence[float] | None = None,<br>fill_color: float | Sequence[float] | <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | None = None,<br>underline: bool = False,<br>t_margin: float | None = None,<br>l_margin: float | <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a> | str | None = None,<br>b_margin: float | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L186-L260" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextStyle(FontFace):
    &#34;&#34;&#34;
    Subclass of `FontFace` that allows to specify vertical &amp; horizontal spacing
    &#34;&#34;&#34;

    def __init__(
        self,
        font_family: Optional[str] = None,  # None means &#34;no override&#34;
        #                                     Whereas &#34;&#34; means &#34;no emphasis&#34;
        font_style: Optional[str | TextEmphasis] = None,
        font_size_pt: Optional[float] = None,
        color: Optional[
            Union[str, float, Sequence[float], DeviceGray, DeviceRGB, DeviceCMYK]
        ] = None,  # grey scale or (red, green, blue),
        fill_color: Optional[
            Union[float, Sequence[float], DeviceGray, DeviceRGB, DeviceCMYK]
        ] = None,  # grey scale or (red, green, blue),
        underline: bool = False,
        t_margin: Optional[float] = None,
        l_margin: Optional[float | Align | str] = None,
        b_margin: Optional[float] = None,
    ) -&gt; None:
        if isinstance(font_style, TextEmphasis):
            font_style = font_style.style
        super().__init__(
            font_family,
            ((font_style or &#34;&#34;) + &#34;U&#34;) if underline else font_style,
            font_size_pt,
            color,
            fill_color,
        )
        self.t_margin = t_margin or 0

        if isinstance(l_margin, (int, float)):
            self.l_margin: Optional[float | Align] = float(l_margin)
        elif l_margin:
            self.l_margin = Align.coerce(l_margin)
        else:
            self.l_margin = 0

        self.b_margin = b_margin or 0

    def __repr__(self) -&gt; str:
        return (
            super().__repr__()[:-1]
            + f&#34;, t_margin={self.t_margin}, l_margin={self.l_margin}, b_margin={self.b_margin})&#34;
        )

    # override parent method
    def replace(  # type: ignore[override]
        self,
        /,
        font_family: Optional[str] = None,
        emphasis: Optional[TextEmphasis] = None,
        font_size_pt: Optional[float] = None,
        color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,
        fill_color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,
        t_margin: Optional[float] = None,
        l_margin: Optional[float | Align] = None,
        b_margin: Optional[float] = None,
    ) -&gt; &#34;TextStyle&#34;:
        &#34;&#34;&#34;
        Create a new TextStyle instance, with new values for some attributes.
        Same as `dataclasses.replace()`
        &#34;&#34;&#34;
        return TextStyle(
            font_family=font_family or self.family,
            font_style=self.emphasis if emphasis is None else emphasis.style,
            font_size_pt=font_size_pt or self.size_pt,
            color=color or self.color,
            fill_color=fill_color or self.fill_color,
            t_margin=self.t_margin if t_margin is None else t_margin,
            l_margin=self.l_margin if l_margin is None else l_margin,
            b_margin=self.b_margin if b_margin is None else b_margin,
        )</code></pre>
</details>
<div class="desc"><p>Subclass of <code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code> that allows to specify vertical &amp; horizontal spacing</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fpdf.fonts.TitleStyle</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fonts.TextStyle.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>default_style: <a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a> | None,<br>override_style: <a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a> | None) ‑> <a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a> | None</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code>.<code><a title="fpdf.fonts.FontFace.combine" href="#fpdf.fonts.FontFace.combine">combine</a></code>
</p>
<div class="desc inherited"><p>Create a combined FontFace with all the supplied features of the two styles. When both
the default and override styles provide a feature, prefer the …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.TextStyle.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self,<br>/,<br>font_family: str | None = None,<br>emphasis: <a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a> | None = None,<br>font_size_pt: float | None = None,<br>color: <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | None = None,<br>fill_color: <a title="fpdf.drawing_primitives.DeviceGray" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceGray">DeviceGray</a> | <a title="fpdf.drawing_primitives.DeviceRGB" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceRGB">DeviceRGB</a> | <a title="fpdf.drawing_primitives.DeviceCMYK" href="drawing_primitives.html#fpdf.drawing_primitives.DeviceCMYK">DeviceCMYK</a> | None = None,<br>t_margin: float | None = None,<br>l_margin: float | <a title="fpdf.enums.Align" href="enums.html#fpdf.enums.Align">Align</a> | None = None,<br>b_margin: float | None = None) ‑> <a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/2b804141934066ea88eff5b841271452d4f9dcea/fpdf/fonts.py#L235-L260" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def replace(  # type: ignore[override]
    self,
    /,
    font_family: Optional[str] = None,
    emphasis: Optional[TextEmphasis] = None,
    font_size_pt: Optional[float] = None,
    color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,
    fill_color: Optional[DeviceGray | DeviceRGB | DeviceCMYK] = None,
    t_margin: Optional[float] = None,
    l_margin: Optional[float | Align] = None,
    b_margin: Optional[float] = None,
) -&gt; &#34;TextStyle&#34;:
    &#34;&#34;&#34;
    Create a new TextStyle instance, with new values for some attributes.
    Same as `dataclasses.replace()`
    &#34;&#34;&#34;
    return TextStyle(
        font_family=font_family or self.family,
        font_style=self.emphasis if emphasis is None else emphasis.style,
        font_size_pt=font_size_pt or self.size_pt,
        color=color or self.color,
        fill_color=fill_color or self.fill_color,
        t_margin=self.t_margin if t_margin is None else t_margin,
        l_margin=self.l_margin if l_margin is None else l_margin,
        b_margin=self.b_margin if b_margin is None else b_margin,
    )</code></pre>
</details>
<div class="desc"><p>Create a new TextStyle instance, with new values for some attributes.
Same as <code>dataclasses.replace()</code></p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.fonts.CoreFont" href="#fpdf.fonts.CoreFont">CoreFont</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fonts.CoreFont.cw" href="#fpdf.fonts.CoreFont.cw">cw</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.emphasis" href="#fpdf.fonts.CoreFont.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.encode_text" href="#fpdf.fonts.CoreFont.encode_text">encode_text</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.fontkey" href="#fpdf.fonts.CoreFont.fontkey">fontkey</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.get_text_width" href="#fpdf.fonts.CoreFont.get_text_width">get_text_width</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.i" href="#fpdf.fonts.CoreFont.i">i</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.name" href="#fpdf.fonts.CoreFont.name">name</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.sp" href="#fpdf.fonts.CoreFont.sp">sp</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.ss" href="#fpdf.fonts.CoreFont.ss">ss</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.type" href="#fpdf.fonts.CoreFont.type">type</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.up" href="#fpdf.fonts.CoreFont.up">up</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.ut" href="#fpdf.fonts.CoreFont.ut">ut</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fonts.FontFace.color" href="#fpdf.fonts.FontFace.color">color</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.combine" href="#fpdf.fonts.FontFace.combine">combine</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.emphasis" href="#fpdf.fonts.FontFace.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.family" href="#fpdf.fonts.FontFace.family">family</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.fill_color" href="#fpdf.fonts.FontFace.fill_color">fill_color</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.replace" href="#fpdf.fonts.FontFace.replace">replace</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.size_pt" href="#fpdf.fonts.FontFace.size_pt">size_pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.Glyph.glyph_id" href="#fpdf.fonts.Glyph.glyph_id">glyph_id</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.glyph_name" href="#fpdf.fonts.Glyph.glyph_name">glyph_name</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.glyph_width" href="#fpdf.fonts.Glyph.glyph_width">glyph_width</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.unicode" href="#fpdf.fonts.Glyph.unicode">unicode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.PDFFontDescriptor" href="#fpdf.fonts.PDFFontDescriptor">PDFFontDescriptor</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.PDFFontDescriptor.content_stream" href="syntax.html#fpdf.fonts.PDFFontDescriptor.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.fonts.PDFFontDescriptor.serialize" href="syntax.html#fpdf.fonts.PDFFontDescriptor.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.SubsetMap" href="#fpdf.fonts.SubsetMap">SubsetMap</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.SubsetMap.get_all_glyph_names" href="#fpdf.fonts.SubsetMap.get_all_glyph_names">get_all_glyph_names</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.get_glyph" href="#fpdf.fonts.SubsetMap.get_glyph">get_glyph</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.items" href="#fpdf.fonts.SubsetMap.items">items</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.pick" href="#fpdf.fonts.SubsetMap.pick">pick</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.pick_glyph" href="#fpdf.fonts.SubsetMap.pick_glyph">pick_glyph</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.TTFFont" href="#fpdf.fonts.TTFFont">TTFFont</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.TTFFont.biggest_size_pt" href="#fpdf.fonts.TTFFont.biggest_size_pt">biggest_size_pt</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cff_ros" href="#fpdf.fonts.TTFFont.cff_ros">cff_ros</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.close" href="#fpdf.fonts.TTFFont.close">close</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cmap" href="#fpdf.fonts.TTFFont.cmap">cmap</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.collection_font_number" href="#fpdf.fonts.TTFFont.collection_font_number">collection_font_number</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.color_font" href="#fpdf.fonts.TTFFont.color_font">color_font</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cw" href="#fpdf.fonts.TTFFont.cw">cw</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.desc" href="#fpdf.fonts.TTFFont.desc">desc</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.emphasis" href="#fpdf.fonts.TTFFont.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.encode_text" href="#fpdf.fonts.TTFFont.encode_text">encode_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.escape_text" href="#fpdf.fonts.TTFFont.escape_text">escape_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.fontkey" href="#fpdf.fonts.TTFFont.fontkey">fontkey</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.get_text_width" href="#fpdf.fonts.TTFFont.get_text_width">get_text_width</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.glyph_ids" href="#fpdf.fonts.TTFFont.glyph_ids">glyph_ids</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.hbfont" href="#fpdf.fonts.TTFFont.hbfont">hbfont</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.i" href="#fpdf.fonts.TTFFont.i">i</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.is_cff" href="#fpdf.fonts.TTFFont.is_cff">is_cff</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.is_cid_keyed" href="#fpdf.fonts.TTFFont.is_cid_keyed">is_cid_keyed</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.is_compressed" href="#fpdf.fonts.TTFFont.is_compressed">is_compressed</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.is_symbol" href="#fpdf.fonts.TTFFont.is_symbol">is_symbol</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.missing_glyphs" href="#fpdf.fonts.TTFFont.missing_glyphs">missing_glyphs</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.name" href="#fpdf.fonts.TTFFont.name">name</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.palette_index" href="#fpdf.fonts.TTFFont.palette_index">palette_index</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.perform_harfbuzz_shaping" href="#fpdf.fonts.TTFFont.perform_harfbuzz_shaping">perform_harfbuzz_shaping</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.scale" href="#fpdf.fonts.TTFFont.scale">scale</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.shape_text" href="#fpdf.fonts.TTFFont.shape_text">shape_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.shaped_text_width" href="#fpdf.fonts.TTFFont.shaped_text_width">shaped_text_width</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.sp" href="#fpdf.fonts.TTFFont.sp">sp</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ss" href="#fpdf.fonts.TTFFont.ss">ss</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.subset" href="#fpdf.fonts.TTFFont.subset">subset</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ttffile" href="#fpdf.fonts.TTFFont.ttffile">ttffile</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ttfont" href="#fpdf.fonts.TTFFont.ttfont">ttfont</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.type" href="#fpdf.fonts.TTFFont.type">type</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.unicode_range" href="#fpdf.fonts.TTFFont.unicode_range">unicode_range</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.up" href="#fpdf.fonts.TTFFont.up">up</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ut" href="#fpdf.fonts.TTFFont.ut">ut</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.TextStyle.combine" href="#fpdf.fonts.TextStyle.combine">combine</a></code></li>
<li><code><a title="fpdf.fonts.TextStyle.replace" href="#fpdf.fonts.TextStyle.replace">replace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
