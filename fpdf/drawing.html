<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fpdf.drawing API documentation</title>
<meta name="description" content="Vector drawing: managing colors, graphics states, paths, transforms …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.drawing</code></h1>
</header>
<section id="section-intro">
<p>Vector drawing: managing colors, graphics states, paths, transforms&hellip;</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
<p>Usage documentation at: <a href="https://py-pdf.github.io/fpdf2/Drawing.html">https://py-pdf.github.io/fpdf2/Drawing.html</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.drawing.clone_structure"><code class="name flex">
<span>def <span class="ident">clone_structure</span></span>(<span>node)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4916-L4940" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def clone_structure(node):
    if isinstance(node, GraphicsContext):
        new = GraphicsContext()
        new.style = deepcopy(node.style)
        new.transform = node.transform
        new.clipping_path = node.clipping_path
        new.path_items = [
            (
                clone_structure(ch)
                if isinstance(ch, (GraphicsContext, PaintedPath))
                else ch
            )
            for ch in node.path_items
        ]
        return new
    if isinstance(node, PaintedPath):
        new = PaintedPath.__new__(PaintedPath)
        root = clone_structure(node.get_graphics_context())
        object.__setattr__(new, &#34;_root_graphics_context&#34;, root)
        object.__setattr__(new, &#34;_graphics_context&#34;, root)
        object.__setattr__(new, &#34;_closed&#34;, node._closed)
        object.__setattr__(new, &#34;_close_context&#34;, root)
        object.__setattr__(new, &#34;_starter_move&#34;, node._starter_move)
        return new
    return node</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.render_pdf_primitive"><code class="name flex">
<span>def <span class="ident">render_pdf_primitive</span></span>(<span>primitive)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L73-L130" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_pdf_primitive(primitive):
    &#34;&#34;&#34;
    Render a Python value as a PDF primitive type.

    Container types (tuples/lists and dicts) are rendered recursively. This supports
    values of the type Name, str, bytes, numbers, booleans, list/tuple, and dict.

    Any custom type can be passed in as long as it provides a `serialize` method that
    takes no arguments and returns a string. The primitive object is returned directly
    if it is an instance of the `Raw` class. Otherwise, The existence of the `serialize`
    method is checked before any other type checking is performed, so, for example, a
    `dict` subclass with a `serialize` method would be converted using its `pdf_repr`
    method rather than the built-in `dict` conversion process.

    Args:
        primitive: the primitive value to convert to its PDF representation.

    Returns:
        Raw-wrapped str of the PDF representation.

    Raises:
        ValueError: if a dictionary key is not a Name.
        TypeError: if `primitive` does not have a known conversion to a PDF
            representation.
    &#34;&#34;&#34;

    if isinstance(primitive, Raw):
        return primitive

    if callable(getattr(primitive, &#34;serialize&#34;, None)):
        output = primitive.serialize()
    elif primitive is None:
        output = &#34;null&#34;
    elif isinstance(primitive, str):
        output = f&#34;({escape_parens(primitive)})&#34;
    elif isinstance(primitive, bytes):
        output = f&#34;&lt;{primitive.hex()}&gt;&#34;
    elif isinstance(primitive, bool):  # has to come before number check
        output = [&#34;false&#34;, &#34;true&#34;][primitive]
    elif isinstance(primitive, NumberClass):
        output = number_to_str(primitive)
    elif isinstance(primitive, (list, tuple)):
        output = &#34;[&#34; + &#34; &#34;.join(render_pdf_primitive(val) for val in primitive) + &#34;]&#34;
    elif isinstance(primitive, dict):
        item_list = []
        for key, val in primitive.items():
            if not isinstance(key, Name):
                raise ValueError(&#34;dict keys must be Names&#34;)

            item_list.append(
                render_pdf_primitive(key) + &#34; &#34; + render_pdf_primitive(val)
            )

        output = &#34;&lt;&lt; &#34; + &#34;\n&#34;.join(item_list) + &#34; &gt;&gt;&#34;
    else:
        raise TypeError(f&#34;cannot produce PDF representation for value {primitive!r}&#34;)

    return Raw(output)</code></pre>
</details>
<div class="desc"><p>Render a Python value as a PDF primitive type.</p>
<p>Container types (tuples/lists and dicts) are rendered recursively. This supports
values of the type Name, str, bytes, numbers, booleans, list/tuple, and dict.</p>
<p>Any custom type can be passed in as long as it provides a <code>serialize</code> method that
takes no arguments and returns a string. The primitive object is returned directly
if it is an instance of the <code>Raw</code> class. Otherwise, The existence of the <code>serialize</code>
method is checked before any other type checking is performed, so, for example, a
<code>dict</code> subclass with a <code>serialize</code> method would be converted using its <code>pdf_repr</code>
method rather than the built-in <code>dict</code> conversion process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>primitive</code></strong></dt>
<dd>the primitive value to convert to its PDF representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Raw-wrapped str of the PDF representation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if a dictionary key is not a Name.</dd>
<dt><code>TypeError</code></dt>
<dd>if <code>primitive</code> does not have a known conversion to a PDF
representation.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.drawing.Arc"><code class="flex name class">
<span>class <span class="ident">Arc</span></span>
<span>(</span><span>radii: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>rotation: int | float | decimal.Decimal,<br>large: bool,<br>sweep: bool,<br>end: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2063-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -&gt; Generator[tuple[Point, Point, Point], None, None]:
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -&gt; list[BezierCurve]:
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        prev = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item, initial_point

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<div class="desc"><p>An elliptical arc path element.</p>
<p>The arc is drawn from the end of the current path element to its specified end point
using a number of parameters to determine how it is constructed.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.arc_to" href="#fpdf.drawing.PaintedPath.arc_to">PaintedPath.arc_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.drawing.Arc.subdivide_sweep"><code class="name flex">
<span>def <span class="ident">subdivide_sweep</span></span>(<span>sweep_angle: float) ‑> Generator[tuple[<a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>], None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2086-L2133" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
@force_nodocument
def subdivide_sweep(
    sweep_angle: float,
) -&gt; Generator[tuple[Point, Point, Point], None, None]:
    &#34;&#34;&#34;
    A generator that subdivides a swept angle into segments no larger than a quarter
    turn.

    Any sweep that is larger than a quarter turn is subdivided into as many equally
    sized segments as necessary to prevent any individual segment from being larger
    than a quarter turn.

    This is used for approximating a circular curve segment using cubic Bézier
    curves. This computes the parameters used for the Bézier approximation up
    front, as well as the transform necessary to place the segment in the correct
    position.

    Args:
        sweep_angle (float): the angle to subdivide.

    Yields:
        A tuple of (ctrl1, ctrl2, end) representing the control and end points of
        the cubic Bézier curve approximating the segment as a unit circle centered
        at the origin.
    &#34;&#34;&#34;
    sweep_angle = abs(sweep_angle)
    sweep_left = sweep_angle

    quarterturn = math.pi / 2
    chunks = math.ceil(sweep_angle / quarterturn)

    sweep_segment = sweep_angle / chunks
    cos_t = math.cos(sweep_segment)
    sin_t = math.sin(sweep_segment)
    kappa = 4 / 3 * math.tan(sweep_segment / 4)

    ctrl1 = Point(1, kappa)
    ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
    end = Point(cos_t, sin_t)

    for _ in range(chunks):
        offset = sweep_angle - sweep_left

        transform = Transform.rotation(offset)
        yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

        sweep_left -= sweep_segment</code></pre>
</details>
<div class="desc"><p>A generator that subdivides a swept angle into segments no larger than a quarter
turn.</p>
<p>Any sweep that is larger than a quarter turn is subdivided into as many equally
sized segments as necessary to prevent any individual segment from being larger
than a quarter turn.</p>
<p>This is used for approximating a circular curve segment using cubic Bézier
curves. This computes the parameters used for the Bézier approximation up
front, as well as the transform necessary to place the segment in the correct
position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sweep_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>the angle to subdivide.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>A tuple of (ctrl1, ctrl2, end) representing the control and end points of
the cubic Bézier curve approximating the segment as a unit circle centered
at the origin.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Arc.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2063-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -&gt; Generator[tuple[Point, Point, Point], None, None]:
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -&gt; list[BezierCurve]:
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        prev = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item, initial_point

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<div class="desc"><p>The end point of the arc.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.large"><code class="name">var <span class="ident">large</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2063-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -&gt; Generator[tuple[Point, Point, Point], None, None]:
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -&gt; list[BezierCurve]:
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        prev = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item, initial_point

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<div class="desc"><p>If True, sweep the arc over an angle greater than or equal to 180 degrees.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.radii"><code class="name">var <span class="ident">radii</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2063-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -&gt; Generator[tuple[Point, Point, Point], None, None]:
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -&gt; list[BezierCurve]:
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        prev = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item, initial_point

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<div class="desc"><p>The x- and y-radii of the arc. If <code>radii.x == radii.y</code> the arc will be circular.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.rotation"><code class="name">var <span class="ident">rotation</span> : int | float | decimal.Decimal</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2063-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -&gt; Generator[tuple[Point, Point, Point], None, None]:
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -&gt; list[BezierCurve]:
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        prev = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item, initial_point

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<div class="desc"><p>The rotation of the arc's major/minor axes relative to the coordinate frame.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.sweep"><code class="name">var <span class="ident">sweep</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2063-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivide_sweep(
        sweep_angle: float,
    ) -&gt; Generator[tuple[Point, Point, Point], None, None]:
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (float): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item: Renderable) -&gt; list[BezierCurve]:
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivide_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this arc by approximating it with a series of
        Bezier curves and aggregating their bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        prev = Move(start)

        for curve in self._approximate_arc(prev):
            segment_bbox, _ = curve.bounding_box(prev.end_point)
            bbox = bbox.merge(segment_bbox)
            prev = curve

        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item, initial_point

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(resource_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<div class="desc"><p>If True, the arc is swept in the positive angular direction.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Arc.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2208-L2221" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;
    Compute the bounding box of this arc by approximating it with a series of
    Bezier curves and aggregating their bounding boxes.
    &#34;&#34;&#34;
    bbox = BoundingBox.empty()
    prev = Move(start)

    for curve in self._approximate_arc(prev):
        segment_bbox, _ = curve.bounding_box(prev.end_point)
        bbox = bbox.merge(segment_bbox)
        prev = curve

    return bbox, self.end</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this arc by approximating it with a series of
Bezier curves and aggregating their bounding boxes.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2223-L2257" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
        `BezierCurve`.
    &#34;&#34;&#34;
    curves = self._approximate_arc(last_item)

    if not curves:
        return &#34;&#34;, last_item, initial_point

    return (
        &#34; &#34;.join(
            curve.render(resource_registry, style, prev, initial_point)[0]
            for prev, curve in zip([last_item, *curves[:-1]], curves)
        ),
        curves[-1],
        initial_point,
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is a resolved
<code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2259-L2302" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `Arc.render`.
    &#34;&#34;&#34;
    curves = self._approximate_arc(last_item)

    debug_stream.write(f&#34;{self} resolved to:\n&#34;)
    if not curves:
        debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
        return &#34;&#34;, last_item, initial_point

    previous = [last_item]
    for curve in curves[:-1]:
        previous.append(curve)
        debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
    debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

    return (
        &#34; &#34;.join(
            curve.render(resource_registry, style, prev, initial_point)[0]
            for prev, curve in zip(previous, curves)
        ),
        curves[-1],
        initial_point,
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.Arc.render" href="#fpdf.drawing.Arc.render">Arc.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.BezierCurve"><code class="flex name class">
<span>class <span class="ident">BezierCurve</span></span>
<span>(</span><span>c1: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>c2: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>end: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1663-L1754" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, two off-curve control points, and an end point.

    See: `PaintedPath.curve_to`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;The curve&#39;s first control point.&#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;The curve&#39;s second control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this cubic Bézier curve.&#34;&#34;&#34;

        # Evaluate all candidate t values (endpoints + extrema) for both axes
        px = [start.x, self.c1.x, self.c2.x, self.end.x]
        py = [start.y, self.c1.y, self.c2.y, self.end.y]

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)

        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]
        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_curve(self.c1, self.c2, self.end), self, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `BezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A cubic Bézier curve path element.</p>
<p>This draws a Bézier curve parameterized by the end point of the previous path
element, two off-curve control points, and an end point.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.curve_to" href="#fpdf.drawing.PaintedPath.curve_to">PaintedPath.curve_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.BezierCurve.c1"><code class="name">var <span class="ident">c1</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1663-L1754" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, two off-curve control points, and an end point.

    See: `PaintedPath.curve_to`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;The curve&#39;s first control point.&#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;The curve&#39;s second control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this cubic Bézier curve.&#34;&#34;&#34;

        # Evaluate all candidate t values (endpoints + extrema) for both axes
        px = [start.x, self.c1.x, self.c2.x, self.end.x]
        py = [start.y, self.c1.y, self.c2.y, self.end.y]

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)

        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]
        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_curve(self.c1, self.c2, self.end), self, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `BezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's first control point.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.c2"><code class="name">var <span class="ident">c2</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1663-L1754" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, two off-curve control points, and an end point.

    See: `PaintedPath.curve_to`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;The curve&#39;s first control point.&#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;The curve&#39;s second control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this cubic Bézier curve.&#34;&#34;&#34;

        # Evaluate all candidate t values (endpoints + extrema) for both axes
        px = [start.x, self.c1.x, self.c2.x, self.end.x]
        py = [start.y, self.c1.y, self.c2.y, self.end.y]

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)

        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]
        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_curve(self.c1, self.c2, self.end), self, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `BezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's second control point.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1663-L1754" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, two off-curve control points, and an end point.

    See: `PaintedPath.curve_to`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;The curve&#39;s first control point.&#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;The curve&#39;s second control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this cubic Bézier curve.&#34;&#34;&#34;

        # Evaluate all candidate t values (endpoints + extrema) for both axes
        px = [start.x, self.c1.x, self.c2.x, self.end.x]
        py = [start.y, self.c1.y, self.c2.y, self.end.y]

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)

        xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]
        ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, self.end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_curve(self.c1, self.c2, self.end), self, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `BezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's end point.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.end_point"><code class="name">prop <span class="ident">end_point</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1680-L1683" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def end_point(self) -&gt; Point:
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.end</code></pre>
</details>
<div class="desc"><p>The end point of this path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.BezierCurve.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1685-L1699" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this cubic Bézier curve.&#34;&#34;&#34;

    # Evaluate all candidate t values (endpoints + extrema) for both axes
    px = [start.x, self.c1.x, self.c2.x, self.end.x]
    py = [start.y, self.c1.y, self.c2.y, self.end.y]

    tx = [0, 1] + _cubic_bezier_critical_ts_1d(*px)
    ty = [0, 1] + _cubic_bezier_critical_ts_1d(*py)

    xs = [_eval_cubic_bezier_1d(t, *px) for t in tx]
    ys = [_eval_cubic_bezier_1d(t, *py) for t in ty]

    bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
    return bbox, self.end</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this cubic Bézier curve.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1701-L1723" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    return _render_curve(self.c1, self.c2, self.end), self, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is <code>self</code></p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1725-L1754" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `BezierCurve.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(str(self) + &#34;\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.BezierCurve.render" href="#fpdf.drawing.BezierCurve.render">BezierCurve.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.BoundingBox"><code class="flex name class">
<span>class <span class="ident">BoundingBox</span></span>
<span>(</span><span>x0: float, y0: float, x1: float, y1: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L340-L516" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox(NamedTuple):
    &#34;&#34;&#34;Represents a bounding box, with utility methods for creating and manipulating them.&#34;&#34;&#34;

    x0: float
    y0: float
    x1: float
    y1: float

    @classmethod
    def empty(cls) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return an &#39;empty&#39; bounding box with extreme values that collapse on merge.
        &#34;&#34;&#34;
        return cls(float(&#34;inf&#34;), float(&#34;inf&#34;), float(&#34;-inf&#34;), float(&#34;-inf&#34;))

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the bounding box is not empty.&#34;&#34;&#34;
        return self.x0 &lt;= self.x1 and self.y0 &lt;= self.y1

    @classmethod
    def from_points(cls, points: list[Point]) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Given a list of points, create a bounding box that encloses them all.&#34;&#34;&#34;
        xs = [float(p.x) for p in points]
        ys = [float(p.y) for p in points]
        return cls(min(xs), min(ys), max(xs), max(ys))

    def merge(self, other: &#34;BoundingBox&#34;) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bounding box to include another one.&#34;&#34;&#34;
        if not self.is_valid():
            return other
        if not other.is_valid():
            return self
        return BoundingBox(
            min(self.x0, other.x0),
            min(self.y0, other.y0),
            max(self.x1, other.x1),
            max(self.y1, other.y1),
        )

    def transformed(self, tf: Transform) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return a new bounding box resulting from applying a transform to this one.
        &#34;&#34;&#34;
        corners = [
            Point(self.x0, self.y0),
            Point(self.x1, self.y0),
            Point(self.x0, self.y1),
            Point(self.x1, self.y1),
        ]
        transformed_points = [pt @ tf for pt in corners]
        return BoundingBox.from_points(transformed_points)

    def expanded(self, dx: float, dy: Optional[float] = None) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Return a new bounding box expanded by the given amounts in each direction.&#34;&#34;&#34;
        if dy is None:
            dy = dx
        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)

    def expanded_to_stroke(
        self, style: &#34;GraphicsStyle&#34;, row_norms: tuple[float, float] = (1.0, 1.0)
    ) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bbox to include stroke coverage, given a graphics style.&#34;&#34;&#34;

        # 1) Is there any stroke to consider?
        if not style.resolve_paint_rule() in (
            PathPaintRule.STROKE,
            PathPaintRule.STROKE_FILL_NONZERO,
            PathPaintRule.STROKE_FILL_EVENODD,
        ):
            return self

        # If stroke opacity resolves to 0, no visible stroke =&gt; no expansion
        so = getattr(style, &#34;stroke_opacity&#34;, GraphicsStyle.INHERIT)
        if (so is not GraphicsStyle.INHERIT) and (so is not None):
            try:
                if float(so) &lt;= 0.0:
                    return self  # no visible stroke, don&#39;t expand
            except (TypeError, ValueError):
                pass

        # 2) Effective stroke width (PDF default is 1 if unset/inherit)
        w = (
            1.00
            if style.stroke_width is None or style.stroke_width is GraphicsStyle.INHERIT
            else style.stroke_width
        )
        w = float(w)
        if w == 0.0:
            return self
        r = 0.5 * w

        # 3) Row norms from CTM to scale the half-stroke in X/Y
        nx, ny = row_norms
        return self.expanded(r * nx, r * ny)

    def to_tuple(self) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Convert bounding box to a 4-tuple.&#34;&#34;&#34;
        return (self.x0, self.y0, self.x1, self.y1)

    def to_pdf_array(self) -&gt; str:
        &#34;&#34;&#34;Convert bounding box to a PDF array string.&#34;&#34;&#34;
        return f&#34;[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]&#34;

    def corners(
        self,
    ) -&gt; tuple[
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
    ]:
        &#34;&#34;&#34;Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).&#34;&#34;&#34;
        return (
            (self.x0, self.y0),
            (self.x1, self.y0),
            (self.x1, self.y1),
            (self.x0, self.y1),
        )

    def project_interval_on_axis(
        self, x1: float, y1: float, x2: float, y2: float
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;
        Project bbox corners onto the axis from (x1,y1) to (x2,y2).
        Returns (tmin, tmax, L) where:
          - L is the axis length
          - t are distances along the axis with t=0 at (x1,y1)
        &#34;&#34;&#34;
        vx, vy = (x2 - x1), (y2 - y1)
        L = math.hypot(vx, vy)
        if L == 0.0:
            return 0.0, 0.0, 0.0
        ux, uy = vx / L, vy / L
        ts = []
        for X, Y in self.corners():
            dx, dy = (X - x1), (Y - y1)
            ts.append(dx * ux + dy * uy)  # dot with unit axis
        return min(ts), max(ts), L

    def max_distance_to_point(self, cx: float, cy: float) -&gt; float:
        &#34;&#34;&#34;Max Euclidean distance from (cx,cy) to any bbox corner.&#34;&#34;&#34;
        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())

    @property
    def width(self) -&gt; float:
        &#34;&#34;&#34;Return the width of the bounding box.&#34;&#34;&#34;
        return self.x1 - self.x0

    @property
    def height(self) -&gt; float:
        &#34;&#34;&#34;Return the height of the bounding box.&#34;&#34;&#34;
        return self.y1 - self.y0

    def __str__(self) -&gt; str:
        return f&#34;BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})&#34;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BoundingBox):
            return False
        tolerance = 1e-6
        return (
            abs(self.x0 - other.x0) &lt; tolerance
            and abs(self.y0 - other.y0) &lt; tolerance
            and abs(self.x1 - other.x1) &lt; tolerance
            and abs(self.y1 - other.y1) &lt; tolerance
        )

    def __hash__(self) -&gt; int:
        # Round to match the tolerance used in __eq__
        return hash(
            (
                round(self.x0, 6),
                round(self.y0, 6),
                round(self.x1, 6),
                round(self.y1, 6),
            )
        )</code></pre>
</details>
<div class="desc"><p>Represents a bounding box, with utility methods for creating and manipulating them.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.drawing.BoundingBox.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return an 'empty' bounding box with extreme values that collapse on merge.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.from_points"><code class="name flex">
<span>def <span class="ident">from_points</span></span>(<span>points: list[<a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]) ‑> <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Given a list of points, create a bounding box that encloses them all.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.BoundingBox.height"><code class="name">prop <span class="ident">height</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L488-L491" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def height(self) -&gt; float:
    &#34;&#34;&#34;Return the height of the bounding box.&#34;&#34;&#34;
    return self.y1 - self.y0</code></pre>
</details>
<div class="desc"><p>Return the height of the bounding box.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.width"><code class="name">prop <span class="ident">width</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L483-L486" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def width(self) -&gt; float:
    &#34;&#34;&#34;Return the width of the bounding box.&#34;&#34;&#34;
    return self.x1 - self.x0</code></pre>
</details>
<div class="desc"><p>Return the width of the bounding box.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.x0"><code class="name">var <span class="ident">x0</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L340-L516" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox(NamedTuple):
    &#34;&#34;&#34;Represents a bounding box, with utility methods for creating and manipulating them.&#34;&#34;&#34;

    x0: float
    y0: float
    x1: float
    y1: float

    @classmethod
    def empty(cls) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return an &#39;empty&#39; bounding box with extreme values that collapse on merge.
        &#34;&#34;&#34;
        return cls(float(&#34;inf&#34;), float(&#34;inf&#34;), float(&#34;-inf&#34;), float(&#34;-inf&#34;))

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the bounding box is not empty.&#34;&#34;&#34;
        return self.x0 &lt;= self.x1 and self.y0 &lt;= self.y1

    @classmethod
    def from_points(cls, points: list[Point]) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Given a list of points, create a bounding box that encloses them all.&#34;&#34;&#34;
        xs = [float(p.x) for p in points]
        ys = [float(p.y) for p in points]
        return cls(min(xs), min(ys), max(xs), max(ys))

    def merge(self, other: &#34;BoundingBox&#34;) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bounding box to include another one.&#34;&#34;&#34;
        if not self.is_valid():
            return other
        if not other.is_valid():
            return self
        return BoundingBox(
            min(self.x0, other.x0),
            min(self.y0, other.y0),
            max(self.x1, other.x1),
            max(self.y1, other.y1),
        )

    def transformed(self, tf: Transform) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return a new bounding box resulting from applying a transform to this one.
        &#34;&#34;&#34;
        corners = [
            Point(self.x0, self.y0),
            Point(self.x1, self.y0),
            Point(self.x0, self.y1),
            Point(self.x1, self.y1),
        ]
        transformed_points = [pt @ tf for pt in corners]
        return BoundingBox.from_points(transformed_points)

    def expanded(self, dx: float, dy: Optional[float] = None) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Return a new bounding box expanded by the given amounts in each direction.&#34;&#34;&#34;
        if dy is None:
            dy = dx
        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)

    def expanded_to_stroke(
        self, style: &#34;GraphicsStyle&#34;, row_norms: tuple[float, float] = (1.0, 1.0)
    ) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bbox to include stroke coverage, given a graphics style.&#34;&#34;&#34;

        # 1) Is there any stroke to consider?
        if not style.resolve_paint_rule() in (
            PathPaintRule.STROKE,
            PathPaintRule.STROKE_FILL_NONZERO,
            PathPaintRule.STROKE_FILL_EVENODD,
        ):
            return self

        # If stroke opacity resolves to 0, no visible stroke =&gt; no expansion
        so = getattr(style, &#34;stroke_opacity&#34;, GraphicsStyle.INHERIT)
        if (so is not GraphicsStyle.INHERIT) and (so is not None):
            try:
                if float(so) &lt;= 0.0:
                    return self  # no visible stroke, don&#39;t expand
            except (TypeError, ValueError):
                pass

        # 2) Effective stroke width (PDF default is 1 if unset/inherit)
        w = (
            1.00
            if style.stroke_width is None or style.stroke_width is GraphicsStyle.INHERIT
            else style.stroke_width
        )
        w = float(w)
        if w == 0.0:
            return self
        r = 0.5 * w

        # 3) Row norms from CTM to scale the half-stroke in X/Y
        nx, ny = row_norms
        return self.expanded(r * nx, r * ny)

    def to_tuple(self) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Convert bounding box to a 4-tuple.&#34;&#34;&#34;
        return (self.x0, self.y0, self.x1, self.y1)

    def to_pdf_array(self) -&gt; str:
        &#34;&#34;&#34;Convert bounding box to a PDF array string.&#34;&#34;&#34;
        return f&#34;[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]&#34;

    def corners(
        self,
    ) -&gt; tuple[
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
    ]:
        &#34;&#34;&#34;Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).&#34;&#34;&#34;
        return (
            (self.x0, self.y0),
            (self.x1, self.y0),
            (self.x1, self.y1),
            (self.x0, self.y1),
        )

    def project_interval_on_axis(
        self, x1: float, y1: float, x2: float, y2: float
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;
        Project bbox corners onto the axis from (x1,y1) to (x2,y2).
        Returns (tmin, tmax, L) where:
          - L is the axis length
          - t are distances along the axis with t=0 at (x1,y1)
        &#34;&#34;&#34;
        vx, vy = (x2 - x1), (y2 - y1)
        L = math.hypot(vx, vy)
        if L == 0.0:
            return 0.0, 0.0, 0.0
        ux, uy = vx / L, vy / L
        ts = []
        for X, Y in self.corners():
            dx, dy = (X - x1), (Y - y1)
            ts.append(dx * ux + dy * uy)  # dot with unit axis
        return min(ts), max(ts), L

    def max_distance_to_point(self, cx: float, cy: float) -&gt; float:
        &#34;&#34;&#34;Max Euclidean distance from (cx,cy) to any bbox corner.&#34;&#34;&#34;
        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())

    @property
    def width(self) -&gt; float:
        &#34;&#34;&#34;Return the width of the bounding box.&#34;&#34;&#34;
        return self.x1 - self.x0

    @property
    def height(self) -&gt; float:
        &#34;&#34;&#34;Return the height of the bounding box.&#34;&#34;&#34;
        return self.y1 - self.y0

    def __str__(self) -&gt; str:
        return f&#34;BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})&#34;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BoundingBox):
            return False
        tolerance = 1e-6
        return (
            abs(self.x0 - other.x0) &lt; tolerance
            and abs(self.y0 - other.y0) &lt; tolerance
            and abs(self.x1 - other.x1) &lt; tolerance
            and abs(self.y1 - other.y1) &lt; tolerance
        )

    def __hash__(self) -&gt; int:
        # Round to match the tolerance used in __eq__
        return hash(
            (
                round(self.x0, 6),
                round(self.y0, 6),
                round(self.x1, 6),
                round(self.y1, 6),
            )
        )</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.x1"><code class="name">var <span class="ident">x1</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L340-L516" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox(NamedTuple):
    &#34;&#34;&#34;Represents a bounding box, with utility methods for creating and manipulating them.&#34;&#34;&#34;

    x0: float
    y0: float
    x1: float
    y1: float

    @classmethod
    def empty(cls) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return an &#39;empty&#39; bounding box with extreme values that collapse on merge.
        &#34;&#34;&#34;
        return cls(float(&#34;inf&#34;), float(&#34;inf&#34;), float(&#34;-inf&#34;), float(&#34;-inf&#34;))

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the bounding box is not empty.&#34;&#34;&#34;
        return self.x0 &lt;= self.x1 and self.y0 &lt;= self.y1

    @classmethod
    def from_points(cls, points: list[Point]) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Given a list of points, create a bounding box that encloses them all.&#34;&#34;&#34;
        xs = [float(p.x) for p in points]
        ys = [float(p.y) for p in points]
        return cls(min(xs), min(ys), max(xs), max(ys))

    def merge(self, other: &#34;BoundingBox&#34;) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bounding box to include another one.&#34;&#34;&#34;
        if not self.is_valid():
            return other
        if not other.is_valid():
            return self
        return BoundingBox(
            min(self.x0, other.x0),
            min(self.y0, other.y0),
            max(self.x1, other.x1),
            max(self.y1, other.y1),
        )

    def transformed(self, tf: Transform) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return a new bounding box resulting from applying a transform to this one.
        &#34;&#34;&#34;
        corners = [
            Point(self.x0, self.y0),
            Point(self.x1, self.y0),
            Point(self.x0, self.y1),
            Point(self.x1, self.y1),
        ]
        transformed_points = [pt @ tf for pt in corners]
        return BoundingBox.from_points(transformed_points)

    def expanded(self, dx: float, dy: Optional[float] = None) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Return a new bounding box expanded by the given amounts in each direction.&#34;&#34;&#34;
        if dy is None:
            dy = dx
        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)

    def expanded_to_stroke(
        self, style: &#34;GraphicsStyle&#34;, row_norms: tuple[float, float] = (1.0, 1.0)
    ) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bbox to include stroke coverage, given a graphics style.&#34;&#34;&#34;

        # 1) Is there any stroke to consider?
        if not style.resolve_paint_rule() in (
            PathPaintRule.STROKE,
            PathPaintRule.STROKE_FILL_NONZERO,
            PathPaintRule.STROKE_FILL_EVENODD,
        ):
            return self

        # If stroke opacity resolves to 0, no visible stroke =&gt; no expansion
        so = getattr(style, &#34;stroke_opacity&#34;, GraphicsStyle.INHERIT)
        if (so is not GraphicsStyle.INHERIT) and (so is not None):
            try:
                if float(so) &lt;= 0.0:
                    return self  # no visible stroke, don&#39;t expand
            except (TypeError, ValueError):
                pass

        # 2) Effective stroke width (PDF default is 1 if unset/inherit)
        w = (
            1.00
            if style.stroke_width is None or style.stroke_width is GraphicsStyle.INHERIT
            else style.stroke_width
        )
        w = float(w)
        if w == 0.0:
            return self
        r = 0.5 * w

        # 3) Row norms from CTM to scale the half-stroke in X/Y
        nx, ny = row_norms
        return self.expanded(r * nx, r * ny)

    def to_tuple(self) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Convert bounding box to a 4-tuple.&#34;&#34;&#34;
        return (self.x0, self.y0, self.x1, self.y1)

    def to_pdf_array(self) -&gt; str:
        &#34;&#34;&#34;Convert bounding box to a PDF array string.&#34;&#34;&#34;
        return f&#34;[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]&#34;

    def corners(
        self,
    ) -&gt; tuple[
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
    ]:
        &#34;&#34;&#34;Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).&#34;&#34;&#34;
        return (
            (self.x0, self.y0),
            (self.x1, self.y0),
            (self.x1, self.y1),
            (self.x0, self.y1),
        )

    def project_interval_on_axis(
        self, x1: float, y1: float, x2: float, y2: float
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;
        Project bbox corners onto the axis from (x1,y1) to (x2,y2).
        Returns (tmin, tmax, L) where:
          - L is the axis length
          - t are distances along the axis with t=0 at (x1,y1)
        &#34;&#34;&#34;
        vx, vy = (x2 - x1), (y2 - y1)
        L = math.hypot(vx, vy)
        if L == 0.0:
            return 0.0, 0.0, 0.0
        ux, uy = vx / L, vy / L
        ts = []
        for X, Y in self.corners():
            dx, dy = (X - x1), (Y - y1)
            ts.append(dx * ux + dy * uy)  # dot with unit axis
        return min(ts), max(ts), L

    def max_distance_to_point(self, cx: float, cy: float) -&gt; float:
        &#34;&#34;&#34;Max Euclidean distance from (cx,cy) to any bbox corner.&#34;&#34;&#34;
        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())

    @property
    def width(self) -&gt; float:
        &#34;&#34;&#34;Return the width of the bounding box.&#34;&#34;&#34;
        return self.x1 - self.x0

    @property
    def height(self) -&gt; float:
        &#34;&#34;&#34;Return the height of the bounding box.&#34;&#34;&#34;
        return self.y1 - self.y0

    def __str__(self) -&gt; str:
        return f&#34;BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})&#34;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BoundingBox):
            return False
        tolerance = 1e-6
        return (
            abs(self.x0 - other.x0) &lt; tolerance
            and abs(self.y0 - other.y0) &lt; tolerance
            and abs(self.x1 - other.x1) &lt; tolerance
            and abs(self.y1 - other.y1) &lt; tolerance
        )

    def __hash__(self) -&gt; int:
        # Round to match the tolerance used in __eq__
        return hash(
            (
                round(self.x0, 6),
                round(self.y0, 6),
                round(self.x1, 6),
                round(self.y1, 6),
            )
        )</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.y0"><code class="name">var <span class="ident">y0</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L340-L516" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox(NamedTuple):
    &#34;&#34;&#34;Represents a bounding box, with utility methods for creating and manipulating them.&#34;&#34;&#34;

    x0: float
    y0: float
    x1: float
    y1: float

    @classmethod
    def empty(cls) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return an &#39;empty&#39; bounding box with extreme values that collapse on merge.
        &#34;&#34;&#34;
        return cls(float(&#34;inf&#34;), float(&#34;inf&#34;), float(&#34;-inf&#34;), float(&#34;-inf&#34;))

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the bounding box is not empty.&#34;&#34;&#34;
        return self.x0 &lt;= self.x1 and self.y0 &lt;= self.y1

    @classmethod
    def from_points(cls, points: list[Point]) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Given a list of points, create a bounding box that encloses them all.&#34;&#34;&#34;
        xs = [float(p.x) for p in points]
        ys = [float(p.y) for p in points]
        return cls(min(xs), min(ys), max(xs), max(ys))

    def merge(self, other: &#34;BoundingBox&#34;) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bounding box to include another one.&#34;&#34;&#34;
        if not self.is_valid():
            return other
        if not other.is_valid():
            return self
        return BoundingBox(
            min(self.x0, other.x0),
            min(self.y0, other.y0),
            max(self.x1, other.x1),
            max(self.y1, other.y1),
        )

    def transformed(self, tf: Transform) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return a new bounding box resulting from applying a transform to this one.
        &#34;&#34;&#34;
        corners = [
            Point(self.x0, self.y0),
            Point(self.x1, self.y0),
            Point(self.x0, self.y1),
            Point(self.x1, self.y1),
        ]
        transformed_points = [pt @ tf for pt in corners]
        return BoundingBox.from_points(transformed_points)

    def expanded(self, dx: float, dy: Optional[float] = None) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Return a new bounding box expanded by the given amounts in each direction.&#34;&#34;&#34;
        if dy is None:
            dy = dx
        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)

    def expanded_to_stroke(
        self, style: &#34;GraphicsStyle&#34;, row_norms: tuple[float, float] = (1.0, 1.0)
    ) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bbox to include stroke coverage, given a graphics style.&#34;&#34;&#34;

        # 1) Is there any stroke to consider?
        if not style.resolve_paint_rule() in (
            PathPaintRule.STROKE,
            PathPaintRule.STROKE_FILL_NONZERO,
            PathPaintRule.STROKE_FILL_EVENODD,
        ):
            return self

        # If stroke opacity resolves to 0, no visible stroke =&gt; no expansion
        so = getattr(style, &#34;stroke_opacity&#34;, GraphicsStyle.INHERIT)
        if (so is not GraphicsStyle.INHERIT) and (so is not None):
            try:
                if float(so) &lt;= 0.0:
                    return self  # no visible stroke, don&#39;t expand
            except (TypeError, ValueError):
                pass

        # 2) Effective stroke width (PDF default is 1 if unset/inherit)
        w = (
            1.00
            if style.stroke_width is None or style.stroke_width is GraphicsStyle.INHERIT
            else style.stroke_width
        )
        w = float(w)
        if w == 0.0:
            return self
        r = 0.5 * w

        # 3) Row norms from CTM to scale the half-stroke in X/Y
        nx, ny = row_norms
        return self.expanded(r * nx, r * ny)

    def to_tuple(self) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Convert bounding box to a 4-tuple.&#34;&#34;&#34;
        return (self.x0, self.y0, self.x1, self.y1)

    def to_pdf_array(self) -&gt; str:
        &#34;&#34;&#34;Convert bounding box to a PDF array string.&#34;&#34;&#34;
        return f&#34;[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]&#34;

    def corners(
        self,
    ) -&gt; tuple[
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
    ]:
        &#34;&#34;&#34;Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).&#34;&#34;&#34;
        return (
            (self.x0, self.y0),
            (self.x1, self.y0),
            (self.x1, self.y1),
            (self.x0, self.y1),
        )

    def project_interval_on_axis(
        self, x1: float, y1: float, x2: float, y2: float
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;
        Project bbox corners onto the axis from (x1,y1) to (x2,y2).
        Returns (tmin, tmax, L) where:
          - L is the axis length
          - t are distances along the axis with t=0 at (x1,y1)
        &#34;&#34;&#34;
        vx, vy = (x2 - x1), (y2 - y1)
        L = math.hypot(vx, vy)
        if L == 0.0:
            return 0.0, 0.0, 0.0
        ux, uy = vx / L, vy / L
        ts = []
        for X, Y in self.corners():
            dx, dy = (X - x1), (Y - y1)
            ts.append(dx * ux + dy * uy)  # dot with unit axis
        return min(ts), max(ts), L

    def max_distance_to_point(self, cx: float, cy: float) -&gt; float:
        &#34;&#34;&#34;Max Euclidean distance from (cx,cy) to any bbox corner.&#34;&#34;&#34;
        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())

    @property
    def width(self) -&gt; float:
        &#34;&#34;&#34;Return the width of the bounding box.&#34;&#34;&#34;
        return self.x1 - self.x0

    @property
    def height(self) -&gt; float:
        &#34;&#34;&#34;Return the height of the bounding box.&#34;&#34;&#34;
        return self.y1 - self.y0

    def __str__(self) -&gt; str:
        return f&#34;BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})&#34;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BoundingBox):
            return False
        tolerance = 1e-6
        return (
            abs(self.x0 - other.x0) &lt; tolerance
            and abs(self.y0 - other.y0) &lt; tolerance
            and abs(self.x1 - other.x1) &lt; tolerance
            and abs(self.y1 - other.y1) &lt; tolerance
        )

    def __hash__(self) -&gt; int:
        # Round to match the tolerance used in __eq__
        return hash(
            (
                round(self.x0, 6),
                round(self.y0, 6),
                round(self.x1, 6),
                round(self.y1, 6),
            )
        )</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.y1"><code class="name">var <span class="ident">y1</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L340-L516" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox(NamedTuple):
    &#34;&#34;&#34;Represents a bounding box, with utility methods for creating and manipulating them.&#34;&#34;&#34;

    x0: float
    y0: float
    x1: float
    y1: float

    @classmethod
    def empty(cls) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return an &#39;empty&#39; bounding box with extreme values that collapse on merge.
        &#34;&#34;&#34;
        return cls(float(&#34;inf&#34;), float(&#34;inf&#34;), float(&#34;-inf&#34;), float(&#34;-inf&#34;))

    def is_valid(self) -&gt; bool:
        &#34;&#34;&#34;Return True if the bounding box is not empty.&#34;&#34;&#34;
        return self.x0 &lt;= self.x1 and self.y0 &lt;= self.y1

    @classmethod
    def from_points(cls, points: list[Point]) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Given a list of points, create a bounding box that encloses them all.&#34;&#34;&#34;
        xs = [float(p.x) for p in points]
        ys = [float(p.y) for p in points]
        return cls(min(xs), min(ys), max(xs), max(ys))

    def merge(self, other: &#34;BoundingBox&#34;) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bounding box to include another one.&#34;&#34;&#34;
        if not self.is_valid():
            return other
        if not other.is_valid():
            return self
        return BoundingBox(
            min(self.x0, other.x0),
            min(self.y0, other.y0),
            max(self.x1, other.x1),
            max(self.y1, other.y1),
        )

    def transformed(self, tf: Transform) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;
        Return a new bounding box resulting from applying a transform to this one.
        &#34;&#34;&#34;
        corners = [
            Point(self.x0, self.y0),
            Point(self.x1, self.y0),
            Point(self.x0, self.y1),
            Point(self.x1, self.y1),
        ]
        transformed_points = [pt @ tf for pt in corners]
        return BoundingBox.from_points(transformed_points)

    def expanded(self, dx: float, dy: Optional[float] = None) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Return a new bounding box expanded by the given amounts in each direction.&#34;&#34;&#34;
        if dy is None:
            dy = dx
        return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)

    def expanded_to_stroke(
        self, style: &#34;GraphicsStyle&#34;, row_norms: tuple[float, float] = (1.0, 1.0)
    ) -&gt; &#34;BoundingBox&#34;:
        &#34;&#34;&#34;Expand this bbox to include stroke coverage, given a graphics style.&#34;&#34;&#34;

        # 1) Is there any stroke to consider?
        if not style.resolve_paint_rule() in (
            PathPaintRule.STROKE,
            PathPaintRule.STROKE_FILL_NONZERO,
            PathPaintRule.STROKE_FILL_EVENODD,
        ):
            return self

        # If stroke opacity resolves to 0, no visible stroke =&gt; no expansion
        so = getattr(style, &#34;stroke_opacity&#34;, GraphicsStyle.INHERIT)
        if (so is not GraphicsStyle.INHERIT) and (so is not None):
            try:
                if float(so) &lt;= 0.0:
                    return self  # no visible stroke, don&#39;t expand
            except (TypeError, ValueError):
                pass

        # 2) Effective stroke width (PDF default is 1 if unset/inherit)
        w = (
            1.00
            if style.stroke_width is None or style.stroke_width is GraphicsStyle.INHERIT
            else style.stroke_width
        )
        w = float(w)
        if w == 0.0:
            return self
        r = 0.5 * w

        # 3) Row norms from CTM to scale the half-stroke in X/Y
        nx, ny = row_norms
        return self.expanded(r * nx, r * ny)

    def to_tuple(self) -&gt; tuple[float, float, float, float]:
        &#34;&#34;&#34;Convert bounding box to a 4-tuple.&#34;&#34;&#34;
        return (self.x0, self.y0, self.x1, self.y1)

    def to_pdf_array(self) -&gt; str:
        &#34;&#34;&#34;Convert bounding box to a PDF array string.&#34;&#34;&#34;
        return f&#34;[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]&#34;

    def corners(
        self,
    ) -&gt; tuple[
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
        tuple[float, float],
    ]:
        &#34;&#34;&#34;Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).&#34;&#34;&#34;
        return (
            (self.x0, self.y0),
            (self.x1, self.y0),
            (self.x1, self.y1),
            (self.x0, self.y1),
        )

    def project_interval_on_axis(
        self, x1: float, y1: float, x2: float, y2: float
    ) -&gt; tuple[float, float, float]:
        &#34;&#34;&#34;
        Project bbox corners onto the axis from (x1,y1) to (x2,y2).
        Returns (tmin, tmax, L) where:
          - L is the axis length
          - t are distances along the axis with t=0 at (x1,y1)
        &#34;&#34;&#34;
        vx, vy = (x2 - x1), (y2 - y1)
        L = math.hypot(vx, vy)
        if L == 0.0:
            return 0.0, 0.0, 0.0
        ux, uy = vx / L, vy / L
        ts = []
        for X, Y in self.corners():
            dx, dy = (X - x1), (Y - y1)
            ts.append(dx * ux + dy * uy)  # dot with unit axis
        return min(ts), max(ts), L

    def max_distance_to_point(self, cx: float, cy: float) -&gt; float:
        &#34;&#34;&#34;Max Euclidean distance from (cx,cy) to any bbox corner.&#34;&#34;&#34;
        return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())

    @property
    def width(self) -&gt; float:
        &#34;&#34;&#34;Return the width of the bounding box.&#34;&#34;&#34;
        return self.x1 - self.x0

    @property
    def height(self) -&gt; float:
        &#34;&#34;&#34;Return the height of the bounding box.&#34;&#34;&#34;
        return self.y1 - self.y0

    def __str__(self) -&gt; str:
        return f&#34;BoundingBox({self.x0}, {self.y0}, {self.x1}, {self.y1})&#34;

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, BoundingBox):
            return False
        tolerance = 1e-6
        return (
            abs(self.x0 - other.x0) &lt; tolerance
            and abs(self.y0 - other.y0) &lt; tolerance
            and abs(self.x1 - other.x1) &lt; tolerance
            and abs(self.y1 - other.y1) &lt; tolerance
        )

    def __hash__(self) -&gt; int:
        # Round to match the tolerance used in __eq__
        return hash(
            (
                round(self.x0, 6),
                round(self.y0, 6),
                round(self.x1, 6),
                round(self.y1, 6),
            )
        )</code></pre>
</details>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.BoundingBox.corners"><code class="name flex">
<span>def <span class="ident">corners</span></span>(<span>self) ‑> tuple[tuple[float, float], tuple[float, float], tuple[float, float], tuple[float, float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L443-L457" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def corners(
    self,
) -&gt; tuple[
    tuple[float, float],
    tuple[float, float],
    tuple[float, float],
    tuple[float, float],
]:
    &#34;&#34;&#34;Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).&#34;&#34;&#34;
    return (
        (self.x0, self.y0),
        (self.x1, self.y0),
        (self.x1, self.y1),
        (self.x0, self.y1),
    )</code></pre>
</details>
<div class="desc"><p>Clockwise corners (x,y): (x0,y0),(x1,y0),(x1,y1),(x0,y1).</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.expanded"><code class="name flex">
<span>def <span class="ident">expanded</span></span>(<span>self, dx: float, dy: float | None = None) ‑> <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L392-L396" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def expanded(self, dx: float, dy: Optional[float] = None) -&gt; &#34;BoundingBox&#34;:
    &#34;&#34;&#34;Return a new bounding box expanded by the given amounts in each direction.&#34;&#34;&#34;
    if dy is None:
        dy = dx
    return BoundingBox(self.x0 - dx, self.y0 - dy, self.x1 + dx, self.y1 + dy)</code></pre>
</details>
<div class="desc"><p>Return a new bounding box expanded by the given amounts in each direction.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.expanded_to_stroke"><code class="name flex">
<span>def <span class="ident">expanded_to_stroke</span></span>(<span>self,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>row_norms: tuple[float, float] = (1.0, 1.0)) ‑> <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L398-L433" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def expanded_to_stroke(
    self, style: &#34;GraphicsStyle&#34;, row_norms: tuple[float, float] = (1.0, 1.0)
) -&gt; &#34;BoundingBox&#34;:
    &#34;&#34;&#34;Expand this bbox to include stroke coverage, given a graphics style.&#34;&#34;&#34;

    # 1) Is there any stroke to consider?
    if not style.resolve_paint_rule() in (
        PathPaintRule.STROKE,
        PathPaintRule.STROKE_FILL_NONZERO,
        PathPaintRule.STROKE_FILL_EVENODD,
    ):
        return self

    # If stroke opacity resolves to 0, no visible stroke =&gt; no expansion
    so = getattr(style, &#34;stroke_opacity&#34;, GraphicsStyle.INHERIT)
    if (so is not GraphicsStyle.INHERIT) and (so is not None):
        try:
            if float(so) &lt;= 0.0:
                return self  # no visible stroke, don&#39;t expand
        except (TypeError, ValueError):
            pass

    # 2) Effective stroke width (PDF default is 1 if unset/inherit)
    w = (
        1.00
        if style.stroke_width is None or style.stroke_width is GraphicsStyle.INHERIT
        else style.stroke_width
    )
    w = float(w)
    if w == 0.0:
        return self
    r = 0.5 * w

    # 3) Row norms from CTM to scale the half-stroke in X/Y
    nx, ny = row_norms
    return self.expanded(r * nx, r * ny)</code></pre>
</details>
<div class="desc"><p>Expand this bbox to include stroke coverage, given a graphics style.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L355-L357" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def is_valid(self) -&gt; bool:
    &#34;&#34;&#34;Return True if the bounding box is not empty.&#34;&#34;&#34;
    return self.x0 &lt;= self.x1 and self.y0 &lt;= self.y1</code></pre>
</details>
<div class="desc"><p>Return True if the bounding box is not empty.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.max_distance_to_point"><code class="name flex">
<span>def <span class="ident">max_distance_to_point</span></span>(<span>self, cx: float, cy: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L479-L481" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def max_distance_to_point(self, cx: float, cy: float) -&gt; float:
    &#34;&#34;&#34;Max Euclidean distance from (cx,cy) to any bbox corner.&#34;&#34;&#34;
    return max(math.hypot(X - cx, Y - cy) for (X, Y) in self.corners())</code></pre>
</details>
<div class="desc"><p>Max Euclidean distance from (cx,cy) to any bbox corner.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self,<br>other: <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>) ‑> <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L366-L377" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def merge(self, other: &#34;BoundingBox&#34;) -&gt; &#34;BoundingBox&#34;:
    &#34;&#34;&#34;Expand this bounding box to include another one.&#34;&#34;&#34;
    if not self.is_valid():
        return other
    if not other.is_valid():
        return self
    return BoundingBox(
        min(self.x0, other.x0),
        min(self.y0, other.y0),
        max(self.x1, other.x1),
        max(self.y1, other.y1),
    )</code></pre>
</details>
<div class="desc"><p>Expand this bounding box to include another one.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.project_interval_on_axis"><code class="name flex">
<span>def <span class="ident">project_interval_on_axis</span></span>(<span>self, x1: float, y1: float, x2: float, y2: float) ‑> tuple[float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L459-L477" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def project_interval_on_axis(
    self, x1: float, y1: float, x2: float, y2: float
) -&gt; tuple[float, float, float]:
    &#34;&#34;&#34;
    Project bbox corners onto the axis from (x1,y1) to (x2,y2).
    Returns (tmin, tmax, L) where:
      - L is the axis length
      - t are distances along the axis with t=0 at (x1,y1)
    &#34;&#34;&#34;
    vx, vy = (x2 - x1), (y2 - y1)
    L = math.hypot(vx, vy)
    if L == 0.0:
        return 0.0, 0.0, 0.0
    ux, uy = vx / L, vy / L
    ts = []
    for X, Y in self.corners():
        dx, dy = (X - x1), (Y - y1)
        ts.append(dx * ux + dy * uy)  # dot with unit axis
    return min(ts), max(ts), L</code></pre>
</details>
<div class="desc"><p>Project bbox corners onto the axis from (x1,y1) to (x2,y2).
Returns (tmin, tmax, L) where:
- L is the axis length
- t are distances along the axis with t=0 at (x1,y1)</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.to_pdf_array"><code class="name flex">
<span>def <span class="ident">to_pdf_array</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L439-L441" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def to_pdf_array(self) -&gt; str:
    &#34;&#34;&#34;Convert bounding box to a PDF array string.&#34;&#34;&#34;
    return f&#34;[{number_to_str(self.x0)} {number_to_str(self.y0)} {number_to_str(self.x1)} {number_to_str(self.y1)}]&#34;</code></pre>
</details>
<div class="desc"><p>Convert bounding box to a PDF array string.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.to_tuple"><code class="name flex">
<span>def <span class="ident">to_tuple</span></span>(<span>self) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L435-L437" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def to_tuple(self) -&gt; tuple[float, float, float, float]:
    &#34;&#34;&#34;Convert bounding box to a 4-tuple.&#34;&#34;&#34;
    return (self.x0, self.y0, self.x1, self.y1)</code></pre>
</details>
<div class="desc"><p>Convert bounding box to a 4-tuple.</p></div>
</dd>
<dt id="fpdf.drawing.BoundingBox.transformed"><code class="name flex">
<span>def <span class="ident">transformed</span></span>(<span>self,<br>tf: <a title="fpdf.drawing_primitives.Transform" href="drawing_primitives.html#fpdf.drawing_primitives.Transform">Transform</a>) ‑> <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L379-L390" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def transformed(self, tf: Transform) -&gt; &#34;BoundingBox&#34;:
    &#34;&#34;&#34;
    Return a new bounding box resulting from applying a transform to this one.
    &#34;&#34;&#34;
    corners = [
        Point(self.x0, self.y0),
        Point(self.x1, self.y0),
        Point(self.x0, self.y1),
        Point(self.x1, self.y1),
    ]
    transformed_points = [pt @ tf for pt in corners]
    return BoundingBox.from_points(transformed_points)</code></pre>
</details>
<div class="desc"><p>Return a new bounding box resulting from applying a transform to this one.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.ClippingPath"><code class="flex name class">
<span>class <span class="ident">ClippingPath</span></span>
<span>(</span><span>x=0, y=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4068-L4175" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class ClippingPath(PaintedPath):
    &#34;&#34;&#34;
    The PaintedPath API but to be used to create clipping paths.

    .. warning::
        Unless you really know what you&#39;re doing, changing attributes of the clipping
        path style is likely to produce unexpected results. This is because the
        clipping path styles override implicit style inheritance of the `PaintedPath`
        it applies to.

        For example, `clippath.style.stroke_width = 2` can unexpectedly override
        `paintpath.style.stroke_width = GraphicsStyle.INHERIT` and cause the painted
        path to be rendered with a stroke of 2 instead of what it would have normally
        inherited. Because a `ClippingPath` can be painted like a normal `PaintedPath`,
        it would be overly restrictive to remove the ability to style it, so instead
        this warning is here.
    &#34;&#34;&#34;

    __slots__ = ()  # no new attributes; preserve slotted layout from PaintedPath

    # because clipping paths can be painted, we inherit from PaintedPath. However, when
    # setting the styling on the clipping path, those values will also be applied to
    # the PaintedPath the ClippingPath is applied to unless they are explicitly set for
    # that painted path. This is not ideal, but there&#39;s no way to really fix it from
    # the PDF rendering model, and trying to track the appropriate state/defaults seems
    # similarly error prone.

    # In general, the expectation is that painted clipping paths are likely to be very
    # uncommon, so it&#39;s an edge case that isn&#39;t worth worrying too much about.

    def __init__(self, x=0, y=0):
        super().__init__(x=x, y=y)
        self.paint_rule = PathPaintRule.DONT_PAINT

    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        # painting the clipping path outside of its root graphics context allows it to
        # be transformed without affecting the transform of the graphics context of the
        # path it is being used to clip. This is because, unlike all of the other style
        # settings, transformations immediately affect the points following them,
        # rather than only affecting them at painting time. stroke settings and color
        # settings are applied only at paint time.

        if debug_stream:
            debug_stream.write(&#34;&lt;ClippingPath&gt; &#34;)

        (
            render_list,
            last_item,
            initial_point,
        ) = self._root_graphics_context.build_render_list(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=False,
        )

        merged_style = GraphicsStyle.merge(style, self.style)
        # we should never get a collision error here
        intersection_rule = merged_style.intersection_rule
        if intersection_rule is merged_style.INHERIT:
            intersection_rule = ClippingPathIntersectionRule.NONZERO
        else:
            intersection_rule = ClippingPathIntersectionRule[
                intersection_rule.name  # pylint: disable=no-member, useless-suppression
            ]

        paint_rule = merged_style.resolve_paint_rule()

        render_list.append(intersection_rule.value)
        render_list.append(paint_rule.value)

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `ClippingPath.render`.
        &#34;&#34;&#34;
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>The PaintedPath API but to be used to create clipping paths.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unless you really know what you're doing, changing attributes of the clipping
path style is likely to produce unexpected results. This is because the
clipping path styles override implicit style inheritance of the <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>
it applies to.</p>
<p>For example, <code>clippath.style.stroke_width = 2</code> can unexpectedly override
<code>paintpath.style.stroke_width = GraphicsStyle.INHERIT</code> and cause the painted
path to be rendered with a stroke of 2 instead of what it would have normally
inherited. Because a <code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code> can be painted like a normal <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>,
it would be overly restrictive to remove the ability to style it, so instead
this warning is here.</p>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.ClippingPath.auto_close"><code class="name">prop <span class="ident">auto_close</span> : bool</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.auto_close" href="#fpdf.drawing.PaintedPath.auto_close">auto_close</a></code>
</p>
<div class="desc inherited"><p>If true, the path should automatically close itself before painting.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.clipping_path"><code class="name">prop <span class="ident">clipping_path</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.clipping_path" href="#fpdf.drawing.PaintedPath.clipping_path">clipping_path</a></code>
</p>
<div class="desc inherited"><p>Set the clipping path for this path.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.paint_rule"><code class="name">prop <span class="ident">paint_rule</span> : <a title="fpdf.enums.PathPaintRule" href="enums.html#fpdf.enums.PathPaintRule">PathPaintRule</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.paint_rule" href="#fpdf.drawing.PaintedPath.paint_rule">paint_rule</a></code>
</p>
<div class="desc inherited"><p>Manually specify the <code>PathPaintRule</code> to use for rendering the path.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.style"><code class="name">prop <span class="ident">style</span> : <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.style" href="#fpdf.drawing.PaintedPath.style">style</a></code>
</p>
<div class="desc inherited"><p>The <code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code> applied to all elements of this path.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.transform"><code class="name">prop <span class="ident">transform</span> : <a title="fpdf.drawing_primitives.Transform" href="drawing_primitives.html#fpdf.drawing_primitives.Transform">Transform</a> | None</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.transform" href="#fpdf.drawing.PaintedPath.transform">transform</a></code>
</p>
<div class="desc inherited"><p>The <code>Transform</code> that applies to all of the elements of this path.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.ClippingPath.add_path_element"><code class="name flex">
<span>def <span class="ident">add_path_element</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.add_path_element" href="#fpdf.drawing.PaintedPath.add_path_element">add_path_element</a></code>
</p>
<div class="desc inherited"><p>Add the given element as a path item of this path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.arc_relative"><code class="name flex">
<span>def <span class="ident">arc_relative</span></span>(<span>self, rx, ry, rotation, large_arc, positive_sweep, dx, dy)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.arc_relative" href="#fpdf.drawing.PaintedPath.arc_relative">arc_relative</a></code>
</p>
<div class="desc inherited"><p>Append an elliptical arc from the end of the previous path point to an offset
point …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.arc_to"><code class="name flex">
<span>def <span class="ident">arc_to</span></span>(<span>self, rx, ry, rotation, large_arc, positive_sweep, x, y)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.arc_to" href="#fpdf.drawing.PaintedPath.arc_to">arc_to</a></code>
</p>
<div class="desc inherited"><p>Append an elliptical arc from the end of the previous path point to the
specified end point …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>expand_for_stroke=True) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.bounding_box" href="#fpdf.drawing.PaintedPath.bounding_box">bounding_box</a></code>
</p>
<div class="desc inherited"><p>Compute the bounding box of this painted path, including nested contexts and transformations.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, cx, cy, r)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.circle" href="#fpdf.drawing.PaintedPath.circle">circle</a></code>
</p>
<div class="desc inherited"><p>Append a circle as a closed subpath to the current path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.close" href="#fpdf.drawing.PaintedPath.close">close</a></code>
</p>
<div class="desc inherited"><p>Explicitly close the current (sub)path.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.curve_relative"><code class="name flex">
<span>def <span class="ident">curve_relative</span></span>(<span>self, dx1, dy1, dx2, dy2, dx3, dy3)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.curve_relative" href="#fpdf.drawing.PaintedPath.curve_relative">curve_relative</a></code>
</p>
<div class="desc inherited"><p>Append a cubic Bézier curve whose points are expressed relative to the
end point of the previous path element …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.curve_to"><code class="name flex">
<span>def <span class="ident">curve_to</span></span>(<span>self, x1, y1, x2, y2, x3, y3)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.curve_to" href="#fpdf.drawing.PaintedPath.curve_to">curve_to</a></code>
</p>
<div class="desc inherited"><p>Append a cubic Bézier curve to this path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, cx, cy, rx, ry)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.ellipse" href="#fpdf.drawing.PaintedPath.ellipse">ellipse</a></code>
</p>
<div class="desc inherited"><p>Append an ellipse as a closed subpath to the current path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.horizontal_line_relative"><code class="name flex">
<span>def <span class="ident">horizontal_line_relative</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.horizontal_line_relative" href="#fpdf.drawing.PaintedPath.horizontal_line_relative">horizontal_line_relative</a></code>
</p>
<div class="desc inherited"><p>Append a straight horizontal line to the given offset from the previous path
element. The ordinate is retrieved from the end point of the previous …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.horizontal_line_to"><code class="name flex">
<span>def <span class="ident">horizontal_line_to</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.horizontal_line_to" href="#fpdf.drawing.PaintedPath.horizontal_line_to">horizontal_line_to</a></code>
</p>
<div class="desc inherited"><p>Append a straight horizontal line to the given abscissa. The ordinate is
retrieved from the end point of the previous path element …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.line_relative"><code class="name flex">
<span>def <span class="ident">line_relative</span></span>(<span>self, dx, dy)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.line_relative" href="#fpdf.drawing.PaintedPath.line_relative">line_relative</a></code>
</p>
<div class="desc inherited"><p>Append a straight line whose end is computed as an offset from the end of the
previous path element …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.line_to"><code class="name flex">
<span>def <span class="ident">line_to</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.line_to" href="#fpdf.drawing.PaintedPath.line_to">line_to</a></code>
</p>
<div class="desc inherited"><p>Append a straight line to this path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.move_relative"><code class="name flex">
<span>def <span class="ident">move_relative</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.move_relative" href="#fpdf.drawing.PaintedPath.move_relative">move_relative</a></code>
</p>
<div class="desc inherited"><p>Start a new subpath or move the path start point relative to the previous point …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.move_to" href="#fpdf.drawing.PaintedPath.move_to">move_to</a></code>
</p>
<div class="desc inherited"><p>Start a new subpath or move the path starting point …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.quadratic_curve_relative"><code class="name flex">
<span>def <span class="ident">quadratic_curve_relative</span></span>(<span>self, dx1, dy1, dx2, dy2)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.quadratic_curve_relative" href="#fpdf.drawing.PaintedPath.quadratic_curve_relative">quadratic_curve_relative</a></code>
</p>
<div class="desc inherited"><p>Append a cubic Bézier curve mimicking the specified quadratic Bézier curve …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.quadratic_curve_to"><code class="name flex">
<span>def <span class="ident">quadratic_curve_to</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.quadratic_curve_to" href="#fpdf.drawing.PaintedPath.quadratic_curve_to">quadratic_curve_to</a></code>
</p>
<div class="desc inherited"><p>Append a cubic Bézier curve mimicking the specified quadratic Bézier curve …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.rectangle"><code class="name flex">
<span>def <span class="ident">rectangle</span></span>(<span>self, x, y, w, h, rx=0, ry=0)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.rectangle" href="#fpdf.drawing.PaintedPath.rectangle">rectangle</a></code>
</p>
<div class="desc inherited"><p>Append a rectangle as a closed subpath to the current path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4102-L4150" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry,
    style,
    last_item,
    initial_point,
    debug_stream=None,
    pfx=None,
):
    # painting the clipping path outside of its root graphics context allows it to
    # be transformed without affecting the transform of the graphics context of the
    # path it is being used to clip. This is because, unlike all of the other style
    # settings, transformations immediately affect the points following them,
    # rather than only affecting them at painting time. stroke settings and color
    # settings are applied only at paint time.

    if debug_stream:
        debug_stream.write(&#34;&lt;ClippingPath&gt; &#34;)

    (
        render_list,
        last_item,
        initial_point,
    ) = self._root_graphics_context.build_render_list(
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=False,
    )

    merged_style = GraphicsStyle.merge(style, self.style)
    # we should never get a collision error here
    intersection_rule = merged_style.intersection_rule
    if intersection_rule is merged_style.INHERIT:
        intersection_rule = ClippingPathIntersectionRule.NONZERO
    else:
        intersection_rule = ClippingPathIntersectionRule[
            intersection_rule.name  # pylint: disable=no-member, useless-suppression
        ]

    paint_rule = merged_style.resolve_paint_rule()

    render_list.append(intersection_rule.value)
    render_list.append(paint_rule.value)

    return &#34; &#34;.join(render_list), last_item, initial_point</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4152-L4175" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `ClippingPath.render`.
    &#34;&#34;&#34;
    return self.render(
        resource_registry, style, last_item, initial_point, debug_stream, pfx
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.ClippingPath.render" href="#fpdf.drawing.ClippingPath.render">ClippingPath.render()</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self,<br>x: float,<br>y: float,<br>content: str,<br>*,<br>font_family: str = 'helvetica',<br>font_style: str = '',<br>font_size: float = 12.0,<br>text_anchor: str = 'start')</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.text" href="#fpdf.drawing.PaintedPath.text">text</a></code>
</p>
<div class="desc inherited"><p>Append a text run at (x, y) to this path …</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.transform_group"><code class="name flex">
<span>def <span class="ident">transform_group</span></span>(<span>self, transform)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.transform_group" href="#fpdf.drawing.PaintedPath.transform_group">transform_group</a></code>
</p>
<div class="desc inherited"><p>Apply the provided <code>Transform</code> to all points added within this context.</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.vertical_line_relative"><code class="name flex">
<span>def <span class="ident">vertical_line_relative</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.vertical_line_relative" href="#fpdf.drawing.PaintedPath.vertical_line_relative">vertical_line_relative</a></code>
</p>
<div class="desc inherited"><p>Append a straight vertical line to the given offset from the previous path
element. The abscissa is retrieved from the end point of the previous path
…</p></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.vertical_line_to"><code class="name flex">
<span>def <span class="ident">vertical_line_to</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.<code><a title="fpdf.drawing.PaintedPath.vertical_line_to" href="#fpdf.drawing.PaintedPath.vertical_line_to">vertical_line_to</a></code>
</p>
<div class="desc inherited"><p>Append a straight vertical line to the given ordinate. The abscissa is
retrieved from the end point of the previous path element …</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Close"><code class="flex name class">
<span>class <span class="ident">Close</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3110-L3180" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Close(NamedTuple):
    &#34;&#34;&#34;
    A path close element.

    Instructs the renderer to draw a straight line from the end of the last path element
    to the start of the current path.

    See: `PaintedPath.close`
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Return an empty bounding box; Close does not affect the geometry.&#34;&#34;&#34;
        return BoundingBox.empty(), start

    # pylint: disable=no-self-use
    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old
            last_item was.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return &#34;h&#34;, Move(initial_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Close.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path close element.</p>
<p>Instructs the renderer to draw a straight line from the end of the last path element
to the start of the current path.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.close" href="#fpdf.drawing.PaintedPath.close">PaintedPath.close()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Close.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3121-L3123" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Return an empty bounding box; Close does not affect the geometry.&#34;&#34;&#34;
    return BoundingBox.empty(), start</code></pre>
</details>
<div class="desc"><p>Return an empty bounding box; Close does not affect the geometry.</p></div>
</dd>
<dt id="fpdf.drawing.Close.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3126-L3149" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old
        last_item was.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    return &#34;h&#34;, Move(initial_point), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is whatever the old
last_item was.</p></div>
</dd>
<dt id="fpdf.drawing.Close.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3151-L3180" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `Close.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(str(self) + &#34;\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.Close.render" href="#fpdf.drawing.Close.render">Close.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.DrawingContext"><code class="flex name class">
<span>class <span class="ident">DrawingContext</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3225-L3429" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class DrawingContext:
    &#34;&#34;&#34;
    Base context for a drawing in a PDF

    This context is not stylable and is mainly responsible for transforming path
    drawing coordinates into user coordinates (i.e. it ensures that the output drawing
    is correctly scaled).
    &#34;&#34;&#34;

    __slots__ = (&#34;_subitems&#34;,)

    def __init__(self):
        self._subitems: list[Union[GraphicsContext, PaintedPath, PaintComposite]] = []

    def add_item(
        self,
        item: Union[&#34;GraphicsContext&#34;, &#34;PaintedPath&#34;, &#34;PaintComposite&#34;],
        _copy: bool = True,
    ) -&gt; None:
        &#34;&#34;&#34;
        Append an item to this drawing context

        Args:
            item (GraphicsContext, PaintedPath): the item to be appended.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;

        if not isinstance(item, (GraphicsContext, PaintedPath, PaintComposite)):
            raise TypeError(f&#34;{item} doesn&#39;t belong in a DrawingContext&#34;)

        if _copy:
            item = deepcopy(item)

        self._subitems.append(item)

    @staticmethod
    def _setup_render_prereqs(
        style, first_point: Point, scale: float, height: float
    ) -&gt; tuple[list[str], GraphicsStyle, Renderable]:
        style.auto_close = True
        style.paint_rule = PathPaintRule.AUTO
        style.intersection_rule = IntersectionRule.NONZERO

        last_item = Move(first_point)
        scale, last_item = (
            Transform.scaling(x=1, y=-1)
            .about(x=0, y=height / 2)
            .scale(scale)
            .render(last_item)
        )

        render_list = [&#34;q&#34;, scale]

        return render_list, style, last_item

    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        first_point: Point,
        scale: float,
        height: float,
        starting_style: GraphicsStyle,
    ) -&gt; str:
        &#34;&#34;&#34;
        Render the drawing context to PDF format.

        Args:
            resource_registry (ResourceCatalog): the parent document&#39;s graphics
                state registry.
            first_point (Point): the starting point to use if the first path element is
                a relative element.
            scale (Number): the scale factor to convert from PDF pt units into the
                document&#39;s semantic units (e.g. mm or in).
            height (Number): the page height. This is used to remap the coordinates to
                be from the top-left corner of the page (matching fpdf&#39;s behavior)
                instead of the PDF native behavior of bottom-left.
            starting_style (GraphicsStyle): the base style for this drawing context,
                derived from the document&#39;s current style defaults.

        Returns:
            A string composed of the PDF representation of all the paths and groups in
            this context (an empty string is returned if there are no paths or groups)
        &#34;&#34;&#34;
        if not self._subitems:
            return &#34;&#34;

        render_list, style, last_item = self._setup_render_prereqs(
            starting_style, first_point, scale, height
        )

        for item in self._subitems:
            rendered, last_item, first_point = item.render(
                resource_registry, style, last_item, first_point
            )
            if rendered:
                render_list.append(rendered)

        # there was nothing to render: the only items are the start group and scale
        # transform.
        if len(render_list) == 2:
            return &#34;&#34;

        if (
            style.soft_mask
            and style.soft_mask is not GraphicsStyle.INHERIT
            and style.soft_mask.object_id == 0
        ):
            style.soft_mask.object_id = resource_registry.register_soft_mask(
                style.soft_mask
            )
        style_dict_name = resource_registry.register_graphics_style(style)
        if style_dict_name is not None:
            render_list.insert(2, f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)
            render_list.insert(
                3,
                render_pdf_primitive(style.stroke_dash_pattern)
                + f&#34; {number_to_str(style.stroke_dash_phase)} d&#34;,
            )

        render_list.append(&#34;Q&#34;)

        return &#34; &#34;.join(render_list)

    def render_debug(
        self,
        resource_registry,
        first_point,
        scale,
        height,
        starting_style,
        debug_stream,
    ):
        &#34;&#34;&#34;
        Render the drawing context to PDF format.

        Args:
            resource_registry (ResourceCatalog): the parent document&#39;s graphics
                state registry.
            first_point (Point): the starting point to use if the first path element is
                a relative element.
            scale (Number): the scale factor to convert from PDF pt units into the
                document&#39;s semantic units (e.g. mm or in).
            height (Number): the page height. This is used to remap the coordinates to
                be from the top-left corner of the page (matching fpdf&#39;s behavior)
                instead of the PDF native behavior of bottom-left.
            starting_style (GraphicsStyle): the base style for this drawing context,
                derived from the document&#39;s current style defaults.
            debug_stream (TextIO): a text stream to which a debug representation of the
                drawing structure will be written.

        Returns:
            A string composed of the PDF representation of all the paths and groups in
            this context (an empty string is returned if there are no paths or groups)
        &#34;&#34;&#34;
        render_list, style, last_item = self._setup_render_prereqs(
            starting_style, first_point, scale, height
        )

        debug_stream.write(&#34;ROOT\n&#34;)
        for child in self._subitems[:-1]:
            debug_stream.write(&#34; ├─ &#34;)
            rendered, last_item = child.render_debug(
                resource_registry, style, last_item, debug_stream, &#34; │  &#34;
            )
            if rendered:
                render_list.append(rendered)

        if self._subitems:
            debug_stream.write(&#34; └─ &#34;)
            rendered, last_item, first_point = self._subitems[-1].render_debug(
                resource_registry, style, last_item, first_point, debug_stream, &#34;    &#34;
            )
            if rendered:
                render_list.append(rendered)

            # there was nothing to render: the only items are the start group and scale
            # transform.
            if len(render_list) == 2:
                return &#34;&#34;

            if (
                style.soft_mask
                and style.soft_mask is not GraphicsStyle.INHERIT
                and style.soft_mask.object_id == 0
            ):
                style.soft_mask.object_id = resource_registry.register_soft_mask(
                    style.soft_mask
                )
            style_dict_name = resource_registry.register_graphics_style(style)
            if style_dict_name is not None:
                render_list.insert(2, f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)
                render_list.insert(
                    3,
                    render_pdf_primitive(style.stroke_dash_pattern)
                    + f&#34; {number_to_str(style.stroke_dash_phase)} d&#34;,
                )

            render_list.append(&#34;Q&#34;)

            return &#34; &#34;.join(render_list)

        return &#34;&#34;</code></pre>
</details>
<div class="desc"><p>Base context for a drawing in a PDF</p>
<p>This context is not stylable and is mainly responsible for transforming path
drawing coordinates into user coordinates (i.e. it ensures that the output drawing
is correctly scaled).</p></div>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.DrawingContext.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self,<br>item: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a> | <a title="fpdf.drawing.PaintComposite" href="#fpdf.drawing.PaintComposite">PaintComposite</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3239-L3261" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_item(
    self,
    item: Union[&#34;GraphicsContext&#34;, &#34;PaintedPath&#34;, &#34;PaintComposite&#34;],
    _copy: bool = True,
) -&gt; None:
    &#34;&#34;&#34;
    Append an item to this drawing context

    Args:
        item (GraphicsContext, PaintedPath): the item to be appended.
        _copy (bool): if true (the default), the item will be copied before being
            appended. This prevents modifications to a referenced object from
            &#34;retroactively&#34; altering its style/shape and should be disabled with
            caution.
    &#34;&#34;&#34;

    if not isinstance(item, (GraphicsContext, PaintedPath, PaintComposite)):
        raise TypeError(f&#34;{item} doesn&#39;t belong in a DrawingContext&#34;)

    if _copy:
        item = deepcopy(item)

    self._subitems.append(item)</code></pre>
</details>
<div class="desc"><p>Append an item to this drawing context</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a>, <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code></dt>
<dd>the item to be appended.</dd>
<dt><strong><code>_copy</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true (the default), the item will be copied before being
appended. This prevents modifications to a referenced object from
"retroactively" altering its style/shape and should be disabled with
caution.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.DrawingContext.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>first_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>scale: float,<br>height: float,<br>starting_style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3283-L3349" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    first_point: Point,
    scale: float,
    height: float,
    starting_style: GraphicsStyle,
) -&gt; str:
    &#34;&#34;&#34;
    Render the drawing context to PDF format.

    Args:
        resource_registry (ResourceCatalog): the parent document&#39;s graphics
            state registry.
        first_point (Point): the starting point to use if the first path element is
            a relative element.
        scale (Number): the scale factor to convert from PDF pt units into the
            document&#39;s semantic units (e.g. mm or in).
        height (Number): the page height. This is used to remap the coordinates to
            be from the top-left corner of the page (matching fpdf&#39;s behavior)
            instead of the PDF native behavior of bottom-left.
        starting_style (GraphicsStyle): the base style for this drawing context,
            derived from the document&#39;s current style defaults.

    Returns:
        A string composed of the PDF representation of all the paths and groups in
        this context (an empty string is returned if there are no paths or groups)
    &#34;&#34;&#34;
    if not self._subitems:
        return &#34;&#34;

    render_list, style, last_item = self._setup_render_prereqs(
        starting_style, first_point, scale, height
    )

    for item in self._subitems:
        rendered, last_item, first_point = item.render(
            resource_registry, style, last_item, first_point
        )
        if rendered:
            render_list.append(rendered)

    # there was nothing to render: the only items are the start group and scale
    # transform.
    if len(render_list) == 2:
        return &#34;&#34;

    if (
        style.soft_mask
        and style.soft_mask is not GraphicsStyle.INHERIT
        and style.soft_mask.object_id == 0
    ):
        style.soft_mask.object_id = resource_registry.register_soft_mask(
            style.soft_mask
        )
    style_dict_name = resource_registry.register_graphics_style(style)
    if style_dict_name is not None:
        render_list.insert(2, f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)
        render_list.insert(
            3,
            render_pdf_primitive(style.stroke_dash_pattern)
            + f&#34; {number_to_str(style.stroke_dash_phase)} d&#34;,
        )

    render_list.append(&#34;Q&#34;)

    return &#34; &#34;.join(render_list)</code></pre>
</details>
<div class="desc"><p>Render the drawing context to PDF format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the parent document's graphics
state registry.</dd>
<dt><strong><code>first_point</code></strong> :&ensp;<code>Point</code></dt>
<dd>the starting point to use if the first path element is
a relative element.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scale factor to convert from PDF pt units into the
document's semantic units (e.g. mm or in).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Number</code></dt>
<dd>the page height. This is used to remap the coordinates to
be from the top-left corner of the page (matching fpdf's behavior)
instead of the PDF native behavior of bottom-left.</dd>
<dt><strong><code>starting_style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the base style for this drawing context,
derived from the document's current style defaults.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string composed of the PDF representation of all the paths and groups in
this context (an empty string is returned if there are no paths or groups)</p></div>
</dd>
<dt id="fpdf.drawing.DrawingContext.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, first_point, scale, height, starting_style, debug_stream)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3351-L3429" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_debug(
    self,
    resource_registry,
    first_point,
    scale,
    height,
    starting_style,
    debug_stream,
):
    &#34;&#34;&#34;
    Render the drawing context to PDF format.

    Args:
        resource_registry (ResourceCatalog): the parent document&#39;s graphics
            state registry.
        first_point (Point): the starting point to use if the first path element is
            a relative element.
        scale (Number): the scale factor to convert from PDF pt units into the
            document&#39;s semantic units (e.g. mm or in).
        height (Number): the page height. This is used to remap the coordinates to
            be from the top-left corner of the page (matching fpdf&#39;s behavior)
            instead of the PDF native behavior of bottom-left.
        starting_style (GraphicsStyle): the base style for this drawing context,
            derived from the document&#39;s current style defaults.
        debug_stream (TextIO): a text stream to which a debug representation of the
            drawing structure will be written.

    Returns:
        A string composed of the PDF representation of all the paths and groups in
        this context (an empty string is returned if there are no paths or groups)
    &#34;&#34;&#34;
    render_list, style, last_item = self._setup_render_prereqs(
        starting_style, first_point, scale, height
    )

    debug_stream.write(&#34;ROOT\n&#34;)
    for child in self._subitems[:-1]:
        debug_stream.write(&#34; ├─ &#34;)
        rendered, last_item = child.render_debug(
            resource_registry, style, last_item, debug_stream, &#34; │  &#34;
        )
        if rendered:
            render_list.append(rendered)

    if self._subitems:
        debug_stream.write(&#34; └─ &#34;)
        rendered, last_item, first_point = self._subitems[-1].render_debug(
            resource_registry, style, last_item, first_point, debug_stream, &#34;    &#34;
        )
        if rendered:
            render_list.append(rendered)

        # there was nothing to render: the only items are the start group and scale
        # transform.
        if len(render_list) == 2:
            return &#34;&#34;

        if (
            style.soft_mask
            and style.soft_mask is not GraphicsStyle.INHERIT
            and style.soft_mask.object_id == 0
        ):
            style.soft_mask.object_id = resource_registry.register_soft_mask(
                style.soft_mask
            )
        style_dict_name = resource_registry.register_graphics_style(style)
        if style_dict_name is not None:
            render_list.insert(2, f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)
            render_list.insert(
                3,
                render_pdf_primitive(style.stroke_dash_pattern)
                + f&#34; {number_to_str(style.stroke_dash_phase)} d&#34;,
            )

        render_list.append(&#34;Q&#34;)

        return &#34; &#34;.join(render_list)

    return &#34;&#34;</code></pre>
</details>
<div class="desc"><p>Render the drawing context to PDF format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the parent document's graphics
state registry.</dd>
<dt><strong><code>first_point</code></strong> :&ensp;<code>Point</code></dt>
<dd>the starting point to use if the first path element is
a relative element.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scale factor to convert from PDF pt units into the
document's semantic units (e.g. mm or in).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Number</code></dt>
<dd>the page height. This is used to remap the coordinates to
be from the top-left corner of the page (matching fpdf's behavior)
instead of the PDF native behavior of bottom-left.</dd>
<dt><strong><code>starting_style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the base style for this drawing context,
derived from the document's current style defaults.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>a text stream to which a debug representation of the
drawing structure will be written.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string composed of the PDF representation of all the paths and groups in
this context (an empty string is returned if there are no paths or groups)</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Ellipse"><code class="flex name class">
<span>class <span class="ident">Ellipse</span></span>
<span>(</span><span>radii: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>center: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2644-L2771" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Ellipse(NamedTuple):
    &#34;&#34;&#34;
    An ellipse.

    See: `PaintedPath.ellipse`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;The x- and y-radii of the ellipse&#34;&#34;&#34;
    center: Point
    &#34;&#34;&#34;The abscissa and ordinate of the center of the ellipse&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        rx = abs(self.radii.x)
        ry = abs(self.radii.y)
        cx, cy = self.center

        arc_rad = Point(rx, ry)

        # this isn&#39;t the most efficient way to do this, computationally, but it&#39;s
        # internally consistent.
        if (rx != 0) and (ry != 0):
            items.append(Move(Point(cx + rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes
        of its components.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.center

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Move` to the center of the ellipse.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Ellipse.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point</code></pre>
</details>
<div class="desc"><p>An ellipse.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.ellipse" href="#fpdf.drawing.PaintedPath.ellipse">PaintedPath.ellipse()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Ellipse.center"><code class="name">var <span class="ident">center</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2644-L2771" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Ellipse(NamedTuple):
    &#34;&#34;&#34;
    An ellipse.

    See: `PaintedPath.ellipse`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;The x- and y-radii of the ellipse&#34;&#34;&#34;
    center: Point
    &#34;&#34;&#34;The abscissa and ordinate of the center of the ellipse&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        rx = abs(self.radii.x)
        ry = abs(self.radii.y)
        cx, cy = self.center

        arc_rad = Point(rx, ry)

        # this isn&#39;t the most efficient way to do this, computationally, but it&#39;s
        # internally consistent.
        if (rx != 0) and (ry != 0):
            items.append(Move(Point(cx + rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes
        of its components.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.center

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Move` to the center of the ellipse.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Ellipse.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point</code></pre>
</details>
<div class="desc"><p>The abscissa and ordinate of the center of the ellipse</p></div>
</dd>
<dt id="fpdf.drawing.Ellipse.radii"><code class="name">var <span class="ident">radii</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2644-L2771" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Ellipse(NamedTuple):
    &#34;&#34;&#34;
    An ellipse.

    See: `PaintedPath.ellipse`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;The x- and y-radii of the ellipse&#34;&#34;&#34;
    center: Point
    &#34;&#34;&#34;The abscissa and ordinate of the center of the ellipse&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        rx = abs(self.radii.x)
        ry = abs(self.radii.y)
        cx, cy = self.center

        arc_rad = Point(rx, ry)

        # this isn&#39;t the most efficient way to do this, computationally, but it&#39;s
        # internally consistent.
        if (rx != 0) and (ry != 0):
            items.append(Move(Point(cx + rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes
        of its components.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.center

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Move` to the center of the ellipse.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Ellipse.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point</code></pre>
</details>
<div class="desc"><p>The x- and y-radii of the ellipse</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Ellipse.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2677-L2689" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;
    Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes
    of its components.
    &#34;&#34;&#34;
    bbox = BoundingBox.empty()
    current_point = start

    for item in self._decompose():
        b, current_point = item.bounding_box(current_point)
        bbox = bbox.merge(b)

    return bbox, self.center</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this ellipse by decomposing it and merging the bounding boxes
of its components.</p></div>
</dd>
<dt id="fpdf.drawing.Ellipse.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2691-L2725" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
        `Move` to the center of the ellipse.
    &#34;&#34;&#34;
    components = self._decompose()

    if not components:
        return &#34;&#34;, last_item, initial_point

    render_list = []
    for item in components:
        rendered, last_item, initial_point = item.render(
            resource_registry, style, last_item, initial_point
        )
        render_list.append(rendered)

    return &#34; &#34;.join(render_list), Move(self.center), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is a resolved
<code><a title="fpdf.drawing.Move" href="#fpdf.drawing.Move">Move</a></code> to the center of the ellipse.</p></div>
</dd>
<dt id="fpdf.drawing.Ellipse.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2727-L2771" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `Ellipse.render`.
    &#34;&#34;&#34;
    components = self._decompose()

    debug_stream.write(f&#34;{self} resolved to:\n&#34;)
    if not components:
        debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
        return &#34;&#34;, last_item, initial_point

    render_list = []
    for item in components[:-1]:
        rendered, last_item, initial_point = item.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
        render_list.append(rendered)

    rendered, last_item, initial_point = components[-1].render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
    render_list.append(rendered)

    return &#34; &#34;.join(render_list), Move(self.center), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.Ellipse.render" href="#fpdf.drawing.Ellipse.render">Ellipse.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.GlyphPathPen"><code class="flex name class">
<span>class <span class="ident">GlyphPathPen</span></span>
<span>(</span><span>pdf_path, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5273-L5282" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GlyphPathPen(PathPen):
    &#34;&#34;&#34;A pen that can be used to draw glyphs into a `PaintedPath`.&#34;&#34;&#34;

    def _closePath(self):
        &#34;&#34;&#34;
        The difference between GlyphPathPen and PathPen is that GlyphPathPen does not
        remove the last path element before closing the path.
        This last line back to start point is necessary for correctly rendering glyphs.
        &#34;&#34;&#34;
        self.pdf_path.close()</code></pre>
</details>
<div class="desc"><p>A pen that can be used to draw glyphs into a <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.</p>
<p>Takes a 'glyphSet' argument (dict), in which the glyphs that are referenced
as components are looked up by their name.</p>
<p>If the optional 'reverseFlipped' argument is True, components whose transformation
matrix has a negative determinant will be decomposed with a reversed path direction
to compensate for the flip.</p>
<p>The optional 'skipMissingComponents' argument can be set to True/False to
override the homonymous class attribute for a given pen instance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.drawing.PathPen" href="#fpdf.drawing.PathPen">PathPen</a></li>
<li>fontTools.pens.basePen.BasePen</li>
<li>fontTools.pens.basePen.DecomposingPen</li>
<li>fontTools.pens.basePen.LoggingPen</li>
<li>fontTools.misc.loggingTools.LogMixin</li>
<li>fontTools.pens.basePen.AbstractPen</li>
</ul>
</dd>
<dt id="fpdf.drawing.GradientPaint"><code class="flex name class">
<span>class <span class="ident">GradientPaint</span></span>
<span>(</span><span>gradient: Gradient,<br>units: <a title="fpdf.enums.GradientUnits" href="enums.html#fpdf.enums.GradientUnits">GradientUnits</a> | str = GradientUnits.USER_SPACE_ON_USE,<br>gradient_transform: Transform | None = None,<br>apply_page_ctm: bool = True,<br>spread_method: str | <a title="fpdf.enums.GradientSpreadMethod" href="enums.html#fpdf.enums.GradientSpreadMethod">GradientSpreadMethod</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"><p>Fill/stroke paint using a gradient</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fpdf.drawing._AlphaGradientPaint</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.GradientPaint.apply_page_ctm"><code class="name">var <span class="ident">apply_page_ctm</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.gradient"><code class="name">var <span class="ident">gradient</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.gradient_transform"><code class="name">var <span class="ident">gradient_transform</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.skip_alpha"><code class="name">var <span class="ident">skip_alpha</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.spread_method"><code class="name">var <span class="ident">spread_method</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.units"><code class="name">var <span class="ident">units</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L133-L307" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GradientPaint:
    &#34;&#34;&#34;Fill/stroke paint using a gradient&#34;&#34;&#34;

    __slots__ = (
        &#34;gradient&#34;,
        &#34;units&#34;,
        &#34;gradient_transform&#34;,
        &#34;apply_page_ctm&#34;,
        &#34;skip_alpha&#34;,
        &#34;spread_method&#34;,
    )

    def __init__(
        self,
        gradient: &#34;Gradient&#34;,
        units: Union[GradientUnits, str] = GradientUnits.USER_SPACE_ON_USE,
        gradient_transform: Optional[&#34;Transform&#34;] = None,
        apply_page_ctm: bool = True,
        spread_method: Optional[Union[str, GradientSpreadMethod]] = None,
    ):
        self.gradient = gradient
        self.units = GradientUnits.coerce(units)
        self.gradient_transform = gradient_transform or Transform.identity()
        self.apply_page_ctm = apply_page_ctm
        self.skip_alpha = False
        self.spread_method = (
            GradientSpreadMethod.coerce(spread_method)
            if spread_method is not None
            else GradientSpreadMethod.PAD
        )

    def _matrix_for(self, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; &#34;Transform&#34;:
        &#34;&#34;&#34;Return the final /Matrix for this gradient, given an optional bbox.&#34;&#34;&#34;
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX:
            if bbox is None:
                raise RuntimeError(
                    &#34;GradientPaint requires bbox for objectBoundingBox units&#34;
                )
            # Map [0,1]x[0,1] object space, then apply gradient_transform
            matrix_bbox = Transform(
                a=bbox.width, b=0, c=0, d=bbox.height, e=bbox.x0, f=bbox.y0
            )
            return self.gradient_transform @ matrix_bbox
        # userSpaceOnUse: only the provided gradient_transform
        return self.gradient_transform

    def _register_pattern(self, resource_catalog, gradient, matrix: &#34;Transform&#34;) -&gt; str:
        &#34;&#34;&#34;Create a Pattern with the given matrix, register shading+pattern, return pattern name.&#34;&#34;&#34;
        resource_catalog.add(PDFResourceType.SHADING, gradient, None)
        pattern = Pattern(gradient).set_matrix(matrix)
        pattern.set_apply_page_ctm(self.apply_page_ctm)
        return resource_catalog.add(PDFResourceType.PATTERN, pattern, None)

    def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern cs /{pattern_name} scn&#34;

    def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
        domain_bbox = (
            BoundingBox(0.0, 0.0, 1.0, 1.0)
            if self.units == GradientUnits.OBJECT_BOUNDING_BOX
            else bbox
        )
        gradient = self._get_gradient_with_spread_method(domain_bbox)
        matrix = self._matrix_for(bbox)
        pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
        return f&#34;/Pattern CS /{pattern_name} SCN&#34;

    def has_alpha(self) -&gt; bool:
        return self.gradient and self.gradient.has_alpha() and not self.skip_alpha

    def _register_alpha_pattern(
        self, resource_catalog, matrix: &#34;Transform&#34;, bbox: &#34;BoundingBox&#34;
    ) -&gt; str:
        alpha_shading = self.gradient.get_alpha_shading_object(bbox)
        if alpha_shading is None:
            raise RuntimeError(&#34;Alpha gradient requested but no alpha ramp found&#34;)
        # Register the shading and wrap it into a Pattern using the same matrix
        resource_catalog.add(PDFResourceType.SHADING, alpha_shading, None)
        alpha_pattern = Pattern(alpha_shading).set_matrix(matrix)
        alpha_pattern.set_apply_page_ctm(False)
        return resource_catalog.add(PDFResourceType.PATTERN, alpha_pattern, None)

    def _get_gradient_with_spread_method(self, bbox: &#34;BoundingBox&#34;) -&gt; Gradient:
        &#34;&#34;&#34;
        Now that the bbox is known, we can construct a new gradient stop line to apply
        the spread method reflect or repeat.
        &#34;&#34;&#34;

        if isinstance(self.gradient, SweepGradient):
            self.gradient.spread_method = self.spread_method
            return self.gradient.get_shading_object(bbox)

        if self.spread_method == GradientSpreadMethod.PAD:
            return self.gradient  # nothing to do

        if isinstance(self.gradient, LinearGradient):
            x1, y1, x2, y2 = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops

            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_linear_gradient(
                x1,
                y1,
                x2,
                y2,
                stops,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        if isinstance(self.gradient, RadialGradient):
            (fx, fy, fr, cx, cy, r) = self.gradient.coords
            raw_stops = getattr(self.gradient, &#34;raw_stops&#34;, None)
            if raw_stops is None:
                colors = self.gradient.colors
                bounds = self.gradient.bounds
                stops = (
                    [(0.0, colors[0])]
                    + list(zip(bounds, colors[1:-1]))
                    + [(1.0, colors[-1])]
                )
            else:
                stops = raw_stops
            spread_bbox = bbox
            if (
                bbox is not None
                and self.units == GradientUnits.USER_SPACE_ON_USE
                and self.gradient_transform is not None
            ):
                try:
                    spread_bbox = bbox.transformed(self.gradient_transform.inverse())
                except ValueError:
                    spread_bbox = bbox

            return shape_radial_gradient(
                cx,
                cy,
                r,
                stops,
                fx=fx,
                fy=fy,
                fr=fr,
                spread_method=self.spread_method,
                bbox=spread_bbox,
            )

        return self.gradient  # unknown gradient type, return as is</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.GradientPaint.emit_fill"><code class="name flex">
<span>def <span class="ident">emit_fill</span></span>(<span>self,<br>resource_catalog,<br>bbox: <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a> | None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L186-L195" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def emit_fill(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
    domain_bbox = (
        BoundingBox(0.0, 0.0, 1.0, 1.0)
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX
        else bbox
    )
    gradient = self._get_gradient_with_spread_method(domain_bbox)
    matrix = self._matrix_for(bbox)
    pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
    return f&#34;/Pattern cs /{pattern_name} scn&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.emit_stroke"><code class="name flex">
<span>def <span class="ident">emit_stroke</span></span>(<span>self,<br>resource_catalog,<br>bbox: <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a> | None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L197-L206" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def emit_stroke(self, resource_catalog, bbox: Optional[&#34;BoundingBox&#34;]) -&gt; str:
    domain_bbox = (
        BoundingBox(0.0, 0.0, 1.0, 1.0)
        if self.units == GradientUnits.OBJECT_BOUNDING_BOX
        else bbox
    )
    gradient = self._get_gradient_with_spread_method(domain_bbox)
    matrix = self._matrix_for(bbox)
    pattern_name = self._register_pattern(resource_catalog, gradient, matrix)
    return f&#34;/Pattern CS /{pattern_name} SCN&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GradientPaint.has_alpha"><code class="name flex">
<span>def <span class="ident">has_alpha</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L208-L209" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def has_alpha(self) -&gt; bool:
    return self.gradient and self.gradient.has_alpha() and not self.skip_alpha</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.GraphicsContext"><code class="flex name class">
<span>class <span class="ident">GraphicsContext</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4178-L4628" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsContext:
    &#34;&#34;&#34;
    Page-level container that collects drawable items and renders them into a PDF
    content stream.

    Converts model coordinates to PDF user space by applying the provided
    `scale` and a vertical flip so (0, 0) is the top-left of the page.

    Wraps output in a saved graphics state (`q … Q`) and registers any
    required resources (graphics state dictionaries, soft masks, dash pattern).

    Child items are typically `GraphicsContext`, `PaintedPath`, or `PaintComposite`
    objects added via `add_item()`. By default, items are deep-copied on insert to
    avoid later mutations affecting the emitted stream.
    &#34;&#34;&#34;

    __slots__ = (&#34;style&#34;, &#34;path_items&#34;, &#34;_transform&#34;, &#34;_clipping_path&#34;)

    def __init__(self):
        self.style: GraphicsStyle = GraphicsStyle()
        self.path_items: list[Renderable] = []

        self._transform: Optional[Transform] = None
        self._clipping_path: Optional[ClippingPath] = None

    def __deepcopy__(self, memo):
        copied = self.__class__()
        copied.style = deepcopy(self.style, memo)
        copied.path_items = deepcopy(self.path_items, memo)
        copied._transform = deepcopy(self.transform, memo)
        copied._clipping_path = deepcopy(self.clipping_path, memo)
        return copied

    @property
    def transform(self) -&gt; Optional[Transform]:
        return self._transform

    @transform.setter
    def transform(self, tf: Transform) -&gt; None:
        self._transform = tf

    @property
    def clipping_path(self) -&gt; Optional[ClippingPath]:
        &#34;&#34;&#34;The `ClippingPath` for this graphics context.&#34;&#34;&#34;
        return self._clipping_path

    @clipping_path.setter
    def clipping_path(self, new_clipath: ClippingPath) -&gt; None:
        self._clipping_path = new_clipath

    def add_item(self, item: Renderable, _copy: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Add a path element to this graphics context.

        Args:
            item: the path element to add. May be a primitive element or another
                `GraphicsContext` or a `PaintedPath`.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;
        if _copy:
            item = deepcopy(item)

        self.path_items.append(item)

    def remove_last_item(self) -&gt; None:
        del self.path_items[-1]

    def merge(self, other_context: &#34;GraphicsContext&#34;) -&gt; None:
        &#34;&#34;&#34;Copy another `GraphicsContext`&#39;s path items into this one.&#34;&#34;&#34;
        self.path_items.extend(other_context.path_items)

    @force_nodocument
    def build_render_list(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
        debug_stream=None,
        pfx: Optional[str] = None,
        _push_stack: bool = True,
    ):
        &#34;&#34;&#34;
        Build a list composed of all all the individual elements rendered.

        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`
        rendering process while still being able to inject some path specific items
        (e.g. the painting directive) before the render is collapsed into a single
        string.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).
            _push_stack (bool): if True, wrap the resulting render list in a push/pop
                graphics stack directive pair.

        Returns:
            `tuple[list[str], last_item]` where `last_item` is the past path element in
            this `GraphicsContext`
        &#34;&#34;&#34;
        render_list = []

        if self.path_items:
            if debug_stream is not None:
                debug_stream.write(f&#34;{self.__class__.__name__}&#34;)

            merged_style = style.__class__.merge(style, self.style)

            if debug_stream is not None:
                if self._transform:
                    debug_stream.write(f&#34;({self._transform})&#34;)

                styles_dbg = []
                for attr in merged_style.MERGE_PROPERTIES:
                    val = getattr(merged_style, attr)
                    if val is not merged_style.INHERIT:
                        if getattr(self.style, attr) is merged_style.INHERIT:
                            inherited = &#34; (inherited)&#34;
                        else:
                            inherited = &#34;&#34;
                        styles_dbg.append(f&#34;{attr}: {val}{inherited}&#34;)

                if styles_dbg:
                    debug_stream.write(&#34; {\n&#34;)
                    for style_dbg_line in styles_dbg:
                        debug_stream.write(pfx + &#34;    &#34;)
                        debug_stream.write(style_dbg_line)
                        debug_stream.write(&#34;\n&#34;)

                    debug_stream.write(pfx + &#34;}┐\n&#34;)
                else:
                    debug_stream.write(&#34;\n&#34;)

            NO_EMIT_SET = (None, merged_style.INHERIT)

            emit_style = self.style
            if merged_style.allow_transparency != self.style.allow_transparency:
                emit_style = deepcopy(self.style)
                emit_style.allow_transparency = merged_style.allow_transparency

            # in order to decouple the dash pattern and the dash phase at the API layer,
            # we have to perform additional logic here to recombine them. We can rely
            # on these being serializable because we always get a sane style on the
            # drawing context.
            dash_pattern = merged_style.stroke_dash_pattern
            dash_phase = merged_style.stroke_dash_phase
            emit_dash = None
            if (
                dash_pattern != style.stroke_dash_pattern
                or dash_phase != style.stroke_dash_phase
            ):
                if emit_style is self.style:
                    emit_style = deepcopy(emit_style)
                emit_style.stroke_dash_pattern = dash_pattern
                emit_style.stroke_dash_phase = dash_phase
                emit_dash = (dash_pattern, dash_phase)

            if (
                emit_style.soft_mask
                and emit_style.soft_mask is not GraphicsStyle.INHERIT
                and emit_style.soft_mask.object_id == 0
            ):
                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                    emit_style.soft_mask
                )
            # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now
            # Compute bbox once so mask and color share the same mapping
            bbox_for_units = self.bounding_box(
                initial_point, style=self.style, expand_for_stroke=False
            )[0]

            def _attach_alpha_mask_if_needed(paint_obj: GradientPaint):
                if not isinstance(paint_obj, GradientPaint):
                    return
                if not paint_obj.has_alpha():
                    return
                # bbox in content space (shared by color &amp; mask)
                bbox_for_units = self.bounding_box(
                    initial_point,
                    style=self.style,
                    expand_for_stroke=False,
                    transformed=False,
                )[0]
                # rectangular mask covering the painted area
                mask_rect = PaintedPath()
                mask_rect.rectangle(
                    bbox_for_units.x0,
                    bbox_for_units.y0,
                    bbox_for_units.width,
                    bbox_for_units.height,
                )
                # paint that rectangle with the grayscale alpha gradient
                alpha_paint = _AlphaGradientPaint(
                    paint_obj.gradient,
                    paint_obj.units,
                    gradient_transform=paint_obj.gradient_transform,
                )
                alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm
                mask_rect.style.fill_color = alpha_paint
                mask_rect.style.stroke_color = None
                mask_rect.style.stroke_width = 0
                mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                mask_gc = GraphicsContext()
                mask_gc.add_item(mask_rect, _copy=False)

                # use luminosity so gray intensity drives coverage
                sm = PaintSoftMask(
                    mask_gc,
                    invert=False,
                    use_luminosity=True,
                    matrix=paint_obj.gradient_transform,
                )

                nonlocal emit_style
                if emit_style.allow_transparency is False:
                    return
                if emit_style is self.style:
                    emit_style = deepcopy(self.style)
                emit_style.soft_mask = sm
                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                    emit_style.soft_mask
                )

            # Decide whether to attach a soft mask from fill or stroke gradient alpha.
            # Priority: fill first (most common), otherwise stroke.
            if isinstance(emit_style.fill_color, GradientPaint) and (
                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
            ):
                _attach_alpha_mask_if_needed(self.style.fill_color)
            elif isinstance(emit_style.stroke_color, GradientPaint) and (
                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
            ):
                _attach_alpha_mask_if_needed(self.style.stroke_color)

            style_dict_name = resource_registry.register_graphics_style(emit_style)

            if style_dict_name is not None:
                render_list.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

            # we can&#39;t set color in the graphics state context dictionary, so we have to
            # manually inherit it and emit it here.
            fill_color = self.style.fill_color
            stroke_color = self.style.stroke_color

            if fill_color not in NO_EMIT_SET:
                if isinstance(fill_color, GradientPaint):
                    render_list.append(
                        fill_color.emit_fill(resource_registry, bbox_for_units)
                    )
                else:
                    render_list.append(fill_color.serialize().lower())

            if stroke_color not in NO_EMIT_SET:
                if isinstance(stroke_color, GradientPaint):
                    render_list.append(
                        stroke_color.emit_stroke(resource_registry, bbox_for_units)
                    )
                else:
                    render_list.append(stroke_color.serialize().upper())

            if emit_dash is not None:
                render_list.append(
                    render_pdf_primitive(emit_dash[0])
                    + f&#34; {number_to_str(emit_dash[1])} d&#34;
                )

            if debug_stream:
                if self.clipping_path is not None:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered_cpath, _, __ = self.clipping_path.render_debug(
                        resource_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items[:-1]:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered, last_item, initial_point = item.render_debug(
                        resource_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )

                    if rendered:
                        render_list.append(rendered)

                debug_stream.write(pfx + &#34; └─ &#34;)
                rendered, last_item, initial_point = self.path_items[-1].render_debug(
                    resource_registry,
                    merged_style,
                    last_item,
                    initial_point,
                    debug_stream,
                    pfx + &#34;    &#34;,
                )

                if rendered:
                    render_list.append(rendered)

            else:
                if self.clipping_path is not None:
                    rendered_cpath, _, __ = self.clipping_path.render(
                        resource_registry, merged_style, last_item, initial_point
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items:
                    rendered, last_item, initial_point = item.render(
                        resource_registry, merged_style, last_item, initial_point
                    )

                    if rendered:
                        render_list.append(rendered)

            # insert transform before points
            if self.transform is not None:
                render_list.insert(0, self.transform.render(last_item)[0])

            if _push_stack:
                render_list.insert(0, &#34;q&#34;)
                render_list.append(&#34;Q&#34;)

        return render_list, last_item, initial_point

    def bounding_box(
        self,
        start: Point,
        style: Optional[GraphicsStyle] = None,
        expand_for_stroke: bool = True,
        transformed: bool = True,
    ) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute bbox of all path items. We:
        1) recurse with accumulated CTM,
        2) merge child bboxes already transformed to this level,
        3) at the end, expand once for stroke using the worst-case CTM row norms.
        &#34;&#34;&#34;
        identity = Transform.identity()

        def walk(
            ctx: &#34;GraphicsContext&#34;,
            current_point: Point,
            ambient_style: Optional[GraphicsStyle],
            accum_tf: Transform,
        ) -&gt; tuple[BoundingBox, Point, float, float]:
            bbox = BoundingBox.empty()
            tf = accum_tf @ (ctx.transform or identity)
            if not transformed:
                tf = identity

            merged_style = (
                ambient_style.__class__.merge(ambient_style, ctx.style)
                if ambient_style
                else ctx.style
            )

            max_nx, max_ny = tf.row_norms()

            for item in ctx.path_items:
                if isinstance(item, GraphicsContext):
                    child_bbox, end_point, cnx, cny = walk(
                        item, current_point, merged_style, tf
                    )
                    bbox = bbox.merge(child_bbox)  # child bbox already in this space
                    current_point = end_point
                    max_nx = max(max_nx, cnx)
                    max_ny = max(max_ny, cny)
                elif hasattr(item, &#34;bounding_box&#34;):
                    item_bbox, end_point = item.bounding_box(current_point)
                    bbox = bbox.merge(item_bbox.transformed(tf))
                    current_point = end_point

            return bbox, current_point, max_nx, max_ny

        # 1) geometric + collect CTM scales
        geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)

        final_bbox = geom_bbox

        if expand_for_stroke:
            # 2) expand once for stroke with the effective style at *this* level
            effective_style = (
                style.__class__.merge(style, self.style) if style else self.style
            )
            final_bbox = geom_bbox.expanded_to_stroke(
                effective_style, row_norms=(nx, ny)
            )
        return final_bbox, end_pt

    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
        debug_stream=None,
        pfx=None,
        _push_stack=True,
    ) -&gt; tuple[str, Renderable, Point]:
        render_list, last_item, initial_point = self.build_render_list(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=True,
    ):
        return self.render(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )</code></pre>
</details>
<div class="desc"><p>Page-level container that collects drawable items and renders them into a PDF
content stream.</p>
<p>Converts model coordinates to PDF user space by applying the provided
<code>scale</code> and a vertical flip so (0, 0) is the top-left of the page.</p>
<p>Wraps output in a saved graphics state (<code>q … Q</code>) and registers any
required resources (graphics state dictionaries, soft masks, dash pattern).</p>
<p>Child items are typically <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>, <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>, or <code><a title="fpdf.drawing.PaintComposite" href="#fpdf.drawing.PaintComposite">PaintComposite</a></code>
objects added via <code>add_item()</code>. By default, items are deep-copied on insert to
avoid later mutations affecting the emitted stream.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.GraphicsContext.clipping_path"><code class="name">prop <span class="ident">clipping_path</span> : <a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4219-L4222" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def clipping_path(self) -&gt; Optional[ClippingPath]:
    &#34;&#34;&#34;The `ClippingPath` for this graphics context.&#34;&#34;&#34;
    return self._clipping_path</code></pre>
</details>
<div class="desc"><p>The <code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code> for this graphics context.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.path_items"><code class="name">var <span class="ident">path_items</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4178-L4628" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsContext:
    &#34;&#34;&#34;
    Page-level container that collects drawable items and renders them into a PDF
    content stream.

    Converts model coordinates to PDF user space by applying the provided
    `scale` and a vertical flip so (0, 0) is the top-left of the page.

    Wraps output in a saved graphics state (`q … Q`) and registers any
    required resources (graphics state dictionaries, soft masks, dash pattern).

    Child items are typically `GraphicsContext`, `PaintedPath`, or `PaintComposite`
    objects added via `add_item()`. By default, items are deep-copied on insert to
    avoid later mutations affecting the emitted stream.
    &#34;&#34;&#34;

    __slots__ = (&#34;style&#34;, &#34;path_items&#34;, &#34;_transform&#34;, &#34;_clipping_path&#34;)

    def __init__(self):
        self.style: GraphicsStyle = GraphicsStyle()
        self.path_items: list[Renderable] = []

        self._transform: Optional[Transform] = None
        self._clipping_path: Optional[ClippingPath] = None

    def __deepcopy__(self, memo):
        copied = self.__class__()
        copied.style = deepcopy(self.style, memo)
        copied.path_items = deepcopy(self.path_items, memo)
        copied._transform = deepcopy(self.transform, memo)
        copied._clipping_path = deepcopy(self.clipping_path, memo)
        return copied

    @property
    def transform(self) -&gt; Optional[Transform]:
        return self._transform

    @transform.setter
    def transform(self, tf: Transform) -&gt; None:
        self._transform = tf

    @property
    def clipping_path(self) -&gt; Optional[ClippingPath]:
        &#34;&#34;&#34;The `ClippingPath` for this graphics context.&#34;&#34;&#34;
        return self._clipping_path

    @clipping_path.setter
    def clipping_path(self, new_clipath: ClippingPath) -&gt; None:
        self._clipping_path = new_clipath

    def add_item(self, item: Renderable, _copy: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Add a path element to this graphics context.

        Args:
            item: the path element to add. May be a primitive element or another
                `GraphicsContext` or a `PaintedPath`.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;
        if _copy:
            item = deepcopy(item)

        self.path_items.append(item)

    def remove_last_item(self) -&gt; None:
        del self.path_items[-1]

    def merge(self, other_context: &#34;GraphicsContext&#34;) -&gt; None:
        &#34;&#34;&#34;Copy another `GraphicsContext`&#39;s path items into this one.&#34;&#34;&#34;
        self.path_items.extend(other_context.path_items)

    @force_nodocument
    def build_render_list(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
        debug_stream=None,
        pfx: Optional[str] = None,
        _push_stack: bool = True,
    ):
        &#34;&#34;&#34;
        Build a list composed of all all the individual elements rendered.

        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`
        rendering process while still being able to inject some path specific items
        (e.g. the painting directive) before the render is collapsed into a single
        string.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).
            _push_stack (bool): if True, wrap the resulting render list in a push/pop
                graphics stack directive pair.

        Returns:
            `tuple[list[str], last_item]` where `last_item` is the past path element in
            this `GraphicsContext`
        &#34;&#34;&#34;
        render_list = []

        if self.path_items:
            if debug_stream is not None:
                debug_stream.write(f&#34;{self.__class__.__name__}&#34;)

            merged_style = style.__class__.merge(style, self.style)

            if debug_stream is not None:
                if self._transform:
                    debug_stream.write(f&#34;({self._transform})&#34;)

                styles_dbg = []
                for attr in merged_style.MERGE_PROPERTIES:
                    val = getattr(merged_style, attr)
                    if val is not merged_style.INHERIT:
                        if getattr(self.style, attr) is merged_style.INHERIT:
                            inherited = &#34; (inherited)&#34;
                        else:
                            inherited = &#34;&#34;
                        styles_dbg.append(f&#34;{attr}: {val}{inherited}&#34;)

                if styles_dbg:
                    debug_stream.write(&#34; {\n&#34;)
                    for style_dbg_line in styles_dbg:
                        debug_stream.write(pfx + &#34;    &#34;)
                        debug_stream.write(style_dbg_line)
                        debug_stream.write(&#34;\n&#34;)

                    debug_stream.write(pfx + &#34;}┐\n&#34;)
                else:
                    debug_stream.write(&#34;\n&#34;)

            NO_EMIT_SET = (None, merged_style.INHERIT)

            emit_style = self.style
            if merged_style.allow_transparency != self.style.allow_transparency:
                emit_style = deepcopy(self.style)
                emit_style.allow_transparency = merged_style.allow_transparency

            # in order to decouple the dash pattern and the dash phase at the API layer,
            # we have to perform additional logic here to recombine them. We can rely
            # on these being serializable because we always get a sane style on the
            # drawing context.
            dash_pattern = merged_style.stroke_dash_pattern
            dash_phase = merged_style.stroke_dash_phase
            emit_dash = None
            if (
                dash_pattern != style.stroke_dash_pattern
                or dash_phase != style.stroke_dash_phase
            ):
                if emit_style is self.style:
                    emit_style = deepcopy(emit_style)
                emit_style.stroke_dash_pattern = dash_pattern
                emit_style.stroke_dash_phase = dash_phase
                emit_dash = (dash_pattern, dash_phase)

            if (
                emit_style.soft_mask
                and emit_style.soft_mask is not GraphicsStyle.INHERIT
                and emit_style.soft_mask.object_id == 0
            ):
                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                    emit_style.soft_mask
                )
            # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now
            # Compute bbox once so mask and color share the same mapping
            bbox_for_units = self.bounding_box(
                initial_point, style=self.style, expand_for_stroke=False
            )[0]

            def _attach_alpha_mask_if_needed(paint_obj: GradientPaint):
                if not isinstance(paint_obj, GradientPaint):
                    return
                if not paint_obj.has_alpha():
                    return
                # bbox in content space (shared by color &amp; mask)
                bbox_for_units = self.bounding_box(
                    initial_point,
                    style=self.style,
                    expand_for_stroke=False,
                    transformed=False,
                )[0]
                # rectangular mask covering the painted area
                mask_rect = PaintedPath()
                mask_rect.rectangle(
                    bbox_for_units.x0,
                    bbox_for_units.y0,
                    bbox_for_units.width,
                    bbox_for_units.height,
                )
                # paint that rectangle with the grayscale alpha gradient
                alpha_paint = _AlphaGradientPaint(
                    paint_obj.gradient,
                    paint_obj.units,
                    gradient_transform=paint_obj.gradient_transform,
                )
                alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm
                mask_rect.style.fill_color = alpha_paint
                mask_rect.style.stroke_color = None
                mask_rect.style.stroke_width = 0
                mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                mask_gc = GraphicsContext()
                mask_gc.add_item(mask_rect, _copy=False)

                # use luminosity so gray intensity drives coverage
                sm = PaintSoftMask(
                    mask_gc,
                    invert=False,
                    use_luminosity=True,
                    matrix=paint_obj.gradient_transform,
                )

                nonlocal emit_style
                if emit_style.allow_transparency is False:
                    return
                if emit_style is self.style:
                    emit_style = deepcopy(self.style)
                emit_style.soft_mask = sm
                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                    emit_style.soft_mask
                )

            # Decide whether to attach a soft mask from fill or stroke gradient alpha.
            # Priority: fill first (most common), otherwise stroke.
            if isinstance(emit_style.fill_color, GradientPaint) and (
                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
            ):
                _attach_alpha_mask_if_needed(self.style.fill_color)
            elif isinstance(emit_style.stroke_color, GradientPaint) and (
                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
            ):
                _attach_alpha_mask_if_needed(self.style.stroke_color)

            style_dict_name = resource_registry.register_graphics_style(emit_style)

            if style_dict_name is not None:
                render_list.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

            # we can&#39;t set color in the graphics state context dictionary, so we have to
            # manually inherit it and emit it here.
            fill_color = self.style.fill_color
            stroke_color = self.style.stroke_color

            if fill_color not in NO_EMIT_SET:
                if isinstance(fill_color, GradientPaint):
                    render_list.append(
                        fill_color.emit_fill(resource_registry, bbox_for_units)
                    )
                else:
                    render_list.append(fill_color.serialize().lower())

            if stroke_color not in NO_EMIT_SET:
                if isinstance(stroke_color, GradientPaint):
                    render_list.append(
                        stroke_color.emit_stroke(resource_registry, bbox_for_units)
                    )
                else:
                    render_list.append(stroke_color.serialize().upper())

            if emit_dash is not None:
                render_list.append(
                    render_pdf_primitive(emit_dash[0])
                    + f&#34; {number_to_str(emit_dash[1])} d&#34;
                )

            if debug_stream:
                if self.clipping_path is not None:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered_cpath, _, __ = self.clipping_path.render_debug(
                        resource_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items[:-1]:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered, last_item, initial_point = item.render_debug(
                        resource_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )

                    if rendered:
                        render_list.append(rendered)

                debug_stream.write(pfx + &#34; └─ &#34;)
                rendered, last_item, initial_point = self.path_items[-1].render_debug(
                    resource_registry,
                    merged_style,
                    last_item,
                    initial_point,
                    debug_stream,
                    pfx + &#34;    &#34;,
                )

                if rendered:
                    render_list.append(rendered)

            else:
                if self.clipping_path is not None:
                    rendered_cpath, _, __ = self.clipping_path.render(
                        resource_registry, merged_style, last_item, initial_point
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items:
                    rendered, last_item, initial_point = item.render(
                        resource_registry, merged_style, last_item, initial_point
                    )

                    if rendered:
                        render_list.append(rendered)

            # insert transform before points
            if self.transform is not None:
                render_list.insert(0, self.transform.render(last_item)[0])

            if _push_stack:
                render_list.insert(0, &#34;q&#34;)
                render_list.append(&#34;Q&#34;)

        return render_list, last_item, initial_point

    def bounding_box(
        self,
        start: Point,
        style: Optional[GraphicsStyle] = None,
        expand_for_stroke: bool = True,
        transformed: bool = True,
    ) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute bbox of all path items. We:
        1) recurse with accumulated CTM,
        2) merge child bboxes already transformed to this level,
        3) at the end, expand once for stroke using the worst-case CTM row norms.
        &#34;&#34;&#34;
        identity = Transform.identity()

        def walk(
            ctx: &#34;GraphicsContext&#34;,
            current_point: Point,
            ambient_style: Optional[GraphicsStyle],
            accum_tf: Transform,
        ) -&gt; tuple[BoundingBox, Point, float, float]:
            bbox = BoundingBox.empty()
            tf = accum_tf @ (ctx.transform or identity)
            if not transformed:
                tf = identity

            merged_style = (
                ambient_style.__class__.merge(ambient_style, ctx.style)
                if ambient_style
                else ctx.style
            )

            max_nx, max_ny = tf.row_norms()

            for item in ctx.path_items:
                if isinstance(item, GraphicsContext):
                    child_bbox, end_point, cnx, cny = walk(
                        item, current_point, merged_style, tf
                    )
                    bbox = bbox.merge(child_bbox)  # child bbox already in this space
                    current_point = end_point
                    max_nx = max(max_nx, cnx)
                    max_ny = max(max_ny, cny)
                elif hasattr(item, &#34;bounding_box&#34;):
                    item_bbox, end_point = item.bounding_box(current_point)
                    bbox = bbox.merge(item_bbox.transformed(tf))
                    current_point = end_point

            return bbox, current_point, max_nx, max_ny

        # 1) geometric + collect CTM scales
        geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)

        final_bbox = geom_bbox

        if expand_for_stroke:
            # 2) expand once for stroke with the effective style at *this* level
            effective_style = (
                style.__class__.merge(style, self.style) if style else self.style
            )
            final_bbox = geom_bbox.expanded_to_stroke(
                effective_style, row_norms=(nx, ny)
            )
        return final_bbox, end_pt

    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
        debug_stream=None,
        pfx=None,
        _push_stack=True,
    ) -&gt; tuple[str, Renderable, Point]:
        render_list, last_item, initial_point = self.build_render_list(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=True,
    ):
        return self.render(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.style"><code class="name">var <span class="ident">style</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4178-L4628" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsContext:
    &#34;&#34;&#34;
    Page-level container that collects drawable items and renders them into a PDF
    content stream.

    Converts model coordinates to PDF user space by applying the provided
    `scale` and a vertical flip so (0, 0) is the top-left of the page.

    Wraps output in a saved graphics state (`q … Q`) and registers any
    required resources (graphics state dictionaries, soft masks, dash pattern).

    Child items are typically `GraphicsContext`, `PaintedPath`, or `PaintComposite`
    objects added via `add_item()`. By default, items are deep-copied on insert to
    avoid later mutations affecting the emitted stream.
    &#34;&#34;&#34;

    __slots__ = (&#34;style&#34;, &#34;path_items&#34;, &#34;_transform&#34;, &#34;_clipping_path&#34;)

    def __init__(self):
        self.style: GraphicsStyle = GraphicsStyle()
        self.path_items: list[Renderable] = []

        self._transform: Optional[Transform] = None
        self._clipping_path: Optional[ClippingPath] = None

    def __deepcopy__(self, memo):
        copied = self.__class__()
        copied.style = deepcopy(self.style, memo)
        copied.path_items = deepcopy(self.path_items, memo)
        copied._transform = deepcopy(self.transform, memo)
        copied._clipping_path = deepcopy(self.clipping_path, memo)
        return copied

    @property
    def transform(self) -&gt; Optional[Transform]:
        return self._transform

    @transform.setter
    def transform(self, tf: Transform) -&gt; None:
        self._transform = tf

    @property
    def clipping_path(self) -&gt; Optional[ClippingPath]:
        &#34;&#34;&#34;The `ClippingPath` for this graphics context.&#34;&#34;&#34;
        return self._clipping_path

    @clipping_path.setter
    def clipping_path(self, new_clipath: ClippingPath) -&gt; None:
        self._clipping_path = new_clipath

    def add_item(self, item: Renderable, _copy: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Add a path element to this graphics context.

        Args:
            item: the path element to add. May be a primitive element or another
                `GraphicsContext` or a `PaintedPath`.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;
        if _copy:
            item = deepcopy(item)

        self.path_items.append(item)

    def remove_last_item(self) -&gt; None:
        del self.path_items[-1]

    def merge(self, other_context: &#34;GraphicsContext&#34;) -&gt; None:
        &#34;&#34;&#34;Copy another `GraphicsContext`&#39;s path items into this one.&#34;&#34;&#34;
        self.path_items.extend(other_context.path_items)

    @force_nodocument
    def build_render_list(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
        debug_stream=None,
        pfx: Optional[str] = None,
        _push_stack: bool = True,
    ):
        &#34;&#34;&#34;
        Build a list composed of all all the individual elements rendered.

        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`
        rendering process while still being able to inject some path specific items
        (e.g. the painting directive) before the render is collapsed into a single
        string.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).
            _push_stack (bool): if True, wrap the resulting render list in a push/pop
                graphics stack directive pair.

        Returns:
            `tuple[list[str], last_item]` where `last_item` is the past path element in
            this `GraphicsContext`
        &#34;&#34;&#34;
        render_list = []

        if self.path_items:
            if debug_stream is not None:
                debug_stream.write(f&#34;{self.__class__.__name__}&#34;)

            merged_style = style.__class__.merge(style, self.style)

            if debug_stream is not None:
                if self._transform:
                    debug_stream.write(f&#34;({self._transform})&#34;)

                styles_dbg = []
                for attr in merged_style.MERGE_PROPERTIES:
                    val = getattr(merged_style, attr)
                    if val is not merged_style.INHERIT:
                        if getattr(self.style, attr) is merged_style.INHERIT:
                            inherited = &#34; (inherited)&#34;
                        else:
                            inherited = &#34;&#34;
                        styles_dbg.append(f&#34;{attr}: {val}{inherited}&#34;)

                if styles_dbg:
                    debug_stream.write(&#34; {\n&#34;)
                    for style_dbg_line in styles_dbg:
                        debug_stream.write(pfx + &#34;    &#34;)
                        debug_stream.write(style_dbg_line)
                        debug_stream.write(&#34;\n&#34;)

                    debug_stream.write(pfx + &#34;}┐\n&#34;)
                else:
                    debug_stream.write(&#34;\n&#34;)

            NO_EMIT_SET = (None, merged_style.INHERIT)

            emit_style = self.style
            if merged_style.allow_transparency != self.style.allow_transparency:
                emit_style = deepcopy(self.style)
                emit_style.allow_transparency = merged_style.allow_transparency

            # in order to decouple the dash pattern and the dash phase at the API layer,
            # we have to perform additional logic here to recombine them. We can rely
            # on these being serializable because we always get a sane style on the
            # drawing context.
            dash_pattern = merged_style.stroke_dash_pattern
            dash_phase = merged_style.stroke_dash_phase
            emit_dash = None
            if (
                dash_pattern != style.stroke_dash_pattern
                or dash_phase != style.stroke_dash_phase
            ):
                if emit_style is self.style:
                    emit_style = deepcopy(emit_style)
                emit_style.stroke_dash_pattern = dash_pattern
                emit_style.stroke_dash_phase = dash_phase
                emit_dash = (dash_pattern, dash_phase)

            if (
                emit_style.soft_mask
                and emit_style.soft_mask is not GraphicsStyle.INHERIT
                and emit_style.soft_mask.object_id == 0
            ):
                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                    emit_style.soft_mask
                )
            # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now
            # Compute bbox once so mask and color share the same mapping
            bbox_for_units = self.bounding_box(
                initial_point, style=self.style, expand_for_stroke=False
            )[0]

            def _attach_alpha_mask_if_needed(paint_obj: GradientPaint):
                if not isinstance(paint_obj, GradientPaint):
                    return
                if not paint_obj.has_alpha():
                    return
                # bbox in content space (shared by color &amp; mask)
                bbox_for_units = self.bounding_box(
                    initial_point,
                    style=self.style,
                    expand_for_stroke=False,
                    transformed=False,
                )[0]
                # rectangular mask covering the painted area
                mask_rect = PaintedPath()
                mask_rect.rectangle(
                    bbox_for_units.x0,
                    bbox_for_units.y0,
                    bbox_for_units.width,
                    bbox_for_units.height,
                )
                # paint that rectangle with the grayscale alpha gradient
                alpha_paint = _AlphaGradientPaint(
                    paint_obj.gradient,
                    paint_obj.units,
                    gradient_transform=paint_obj.gradient_transform,
                )
                alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm
                mask_rect.style.fill_color = alpha_paint
                mask_rect.style.stroke_color = None
                mask_rect.style.stroke_width = 0
                mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                mask_gc = GraphicsContext()
                mask_gc.add_item(mask_rect, _copy=False)

                # use luminosity so gray intensity drives coverage
                sm = PaintSoftMask(
                    mask_gc,
                    invert=False,
                    use_luminosity=True,
                    matrix=paint_obj.gradient_transform,
                )

                nonlocal emit_style
                if emit_style.allow_transparency is False:
                    return
                if emit_style is self.style:
                    emit_style = deepcopy(self.style)
                emit_style.soft_mask = sm
                emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                    emit_style.soft_mask
                )

            # Decide whether to attach a soft mask from fill or stroke gradient alpha.
            # Priority: fill first (most common), otherwise stroke.
            if isinstance(emit_style.fill_color, GradientPaint) and (
                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
            ):
                _attach_alpha_mask_if_needed(self.style.fill_color)
            elif isinstance(emit_style.stroke_color, GradientPaint) and (
                emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
            ):
                _attach_alpha_mask_if_needed(self.style.stroke_color)

            style_dict_name = resource_registry.register_graphics_style(emit_style)

            if style_dict_name is not None:
                render_list.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

            # we can&#39;t set color in the graphics state context dictionary, so we have to
            # manually inherit it and emit it here.
            fill_color = self.style.fill_color
            stroke_color = self.style.stroke_color

            if fill_color not in NO_EMIT_SET:
                if isinstance(fill_color, GradientPaint):
                    render_list.append(
                        fill_color.emit_fill(resource_registry, bbox_for_units)
                    )
                else:
                    render_list.append(fill_color.serialize().lower())

            if stroke_color not in NO_EMIT_SET:
                if isinstance(stroke_color, GradientPaint):
                    render_list.append(
                        stroke_color.emit_stroke(resource_registry, bbox_for_units)
                    )
                else:
                    render_list.append(stroke_color.serialize().upper())

            if emit_dash is not None:
                render_list.append(
                    render_pdf_primitive(emit_dash[0])
                    + f&#34; {number_to_str(emit_dash[1])} d&#34;
                )

            if debug_stream:
                if self.clipping_path is not None:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered_cpath, _, __ = self.clipping_path.render_debug(
                        resource_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items[:-1]:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered, last_item, initial_point = item.render_debug(
                        resource_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )

                    if rendered:
                        render_list.append(rendered)

                debug_stream.write(pfx + &#34; └─ &#34;)
                rendered, last_item, initial_point = self.path_items[-1].render_debug(
                    resource_registry,
                    merged_style,
                    last_item,
                    initial_point,
                    debug_stream,
                    pfx + &#34;    &#34;,
                )

                if rendered:
                    render_list.append(rendered)

            else:
                if self.clipping_path is not None:
                    rendered_cpath, _, __ = self.clipping_path.render(
                        resource_registry, merged_style, last_item, initial_point
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items:
                    rendered, last_item, initial_point = item.render(
                        resource_registry, merged_style, last_item, initial_point
                    )

                    if rendered:
                        render_list.append(rendered)

            # insert transform before points
            if self.transform is not None:
                render_list.insert(0, self.transform.render(last_item)[0])

            if _push_stack:
                render_list.insert(0, &#34;q&#34;)
                render_list.append(&#34;Q&#34;)

        return render_list, last_item, initial_point

    def bounding_box(
        self,
        start: Point,
        style: Optional[GraphicsStyle] = None,
        expand_for_stroke: bool = True,
        transformed: bool = True,
    ) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute bbox of all path items. We:
        1) recurse with accumulated CTM,
        2) merge child bboxes already transformed to this level,
        3) at the end, expand once for stroke using the worst-case CTM row norms.
        &#34;&#34;&#34;
        identity = Transform.identity()

        def walk(
            ctx: &#34;GraphicsContext&#34;,
            current_point: Point,
            ambient_style: Optional[GraphicsStyle],
            accum_tf: Transform,
        ) -&gt; tuple[BoundingBox, Point, float, float]:
            bbox = BoundingBox.empty()
            tf = accum_tf @ (ctx.transform or identity)
            if not transformed:
                tf = identity

            merged_style = (
                ambient_style.__class__.merge(ambient_style, ctx.style)
                if ambient_style
                else ctx.style
            )

            max_nx, max_ny = tf.row_norms()

            for item in ctx.path_items:
                if isinstance(item, GraphicsContext):
                    child_bbox, end_point, cnx, cny = walk(
                        item, current_point, merged_style, tf
                    )
                    bbox = bbox.merge(child_bbox)  # child bbox already in this space
                    current_point = end_point
                    max_nx = max(max_nx, cnx)
                    max_ny = max(max_ny, cny)
                elif hasattr(item, &#34;bounding_box&#34;):
                    item_bbox, end_point = item.bounding_box(current_point)
                    bbox = bbox.merge(item_bbox.transformed(tf))
                    current_point = end_point

            return bbox, current_point, max_nx, max_ny

        # 1) geometric + collect CTM scales
        geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)

        final_bbox = geom_bbox

        if expand_for_stroke:
            # 2) expand once for stroke with the effective style at *this* level
            effective_style = (
                style.__class__.merge(style, self.style) if style else self.style
            )
            final_bbox = geom_bbox.expanded_to_stroke(
                effective_style, row_norms=(nx, ny)
            )
        return final_bbox, end_pt

    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
        debug_stream=None,
        pfx=None,
        _push_stack=True,
    ) -&gt; tuple[str, Renderable, Point]:
        render_list, last_item, initial_point = self.build_render_list(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=True,
    ):
        return self.render(
            resource_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.transform"><code class="name">prop <span class="ident">transform</span> : <a title="fpdf.drawing_primitives.Transform" href="drawing_primitives.html#fpdf.drawing_primitives.Transform">Transform</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4211-L4213" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def transform(self) -&gt; Optional[Transform]:
    return self._transform</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsContext.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self,<br>item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4228-L4243" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_item(self, item: Renderable, _copy: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Add a path element to this graphics context.

    Args:
        item: the path element to add. May be a primitive element or another
            `GraphicsContext` or a `PaintedPath`.
        _copy (bool): if true (the default), the item will be copied before being
            appended. This prevents modifications to a referenced object from
            &#34;retroactively&#34; altering its style/shape and should be disabled with
            caution.
    &#34;&#34;&#34;
    if _copy:
        item = deepcopy(item)

    self.path_items.append(item)</code></pre>
</details>
<div class="desc"><p>Add a path element to this graphics context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>the path element to add. May be a primitive element or another
<code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code> or a <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.</dd>
<dt><strong><code>_copy</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true (the default), the item will be copied before being
appended. This prevents modifications to a referenced object from
"retroactively" altering its style/shape and should be disabled with
caution.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a> | None = None,<br>expand_for_stroke: bool = True,<br>transformed: bool = True) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4523-L4586" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(
    self,
    start: Point,
    style: Optional[GraphicsStyle] = None,
    expand_for_stroke: bool = True,
    transformed: bool = True,
) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;
    Compute bbox of all path items. We:
    1) recurse with accumulated CTM,
    2) merge child bboxes already transformed to this level,
    3) at the end, expand once for stroke using the worst-case CTM row norms.
    &#34;&#34;&#34;
    identity = Transform.identity()

    def walk(
        ctx: &#34;GraphicsContext&#34;,
        current_point: Point,
        ambient_style: Optional[GraphicsStyle],
        accum_tf: Transform,
    ) -&gt; tuple[BoundingBox, Point, float, float]:
        bbox = BoundingBox.empty()
        tf = accum_tf @ (ctx.transform or identity)
        if not transformed:
            tf = identity

        merged_style = (
            ambient_style.__class__.merge(ambient_style, ctx.style)
            if ambient_style
            else ctx.style
        )

        max_nx, max_ny = tf.row_norms()

        for item in ctx.path_items:
            if isinstance(item, GraphicsContext):
                child_bbox, end_point, cnx, cny = walk(
                    item, current_point, merged_style, tf
                )
                bbox = bbox.merge(child_bbox)  # child bbox already in this space
                current_point = end_point
                max_nx = max(max_nx, cnx)
                max_ny = max(max_ny, cny)
            elif hasattr(item, &#34;bounding_box&#34;):
                item_bbox, end_point = item.bounding_box(current_point)
                bbox = bbox.merge(item_bbox.transformed(tf))
                current_point = end_point

        return bbox, current_point, max_nx, max_ny

    # 1) geometric + collect CTM scales
    geom_bbox, end_pt, nx, ny = walk(self, start, style, identity)

    final_bbox = geom_bbox

    if expand_for_stroke:
        # 2) expand once for stroke with the effective style at *this* level
        effective_style = (
            style.__class__.merge(style, self.style) if style else self.style
        )
        final_bbox = geom_bbox.expanded_to_stroke(
            effective_style, row_norms=(nx, ny)
        )
    return final_bbox, end_pt</code></pre>
</details>
<div class="desc"><p>Compute bbox of all path items. We:
1) recurse with accumulated CTM,
2) merge child bboxes already transformed to this level,
3) at the end, expand once for stroke using the worst-case CTM row norms.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.build_render_list"><code class="name flex">
<span>def <span class="ident">build_render_list</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>debug_stream=None,<br>pfx: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4252-L4521" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def build_render_list(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
    debug_stream=None,
    pfx: Optional[str] = None,
    _push_stack: bool = True,
):
    &#34;&#34;&#34;
    Build a list composed of all all the individual elements rendered.

    This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`
    rendering process while still being able to inject some path specific items
    (e.g. the painting directive) before the render is collapsed into a single
    string.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).
        _push_stack (bool): if True, wrap the resulting render list in a push/pop
            graphics stack directive pair.

    Returns:
        `tuple[list[str], last_item]` where `last_item` is the past path element in
        this `GraphicsContext`
    &#34;&#34;&#34;
    render_list = []

    if self.path_items:
        if debug_stream is not None:
            debug_stream.write(f&#34;{self.__class__.__name__}&#34;)

        merged_style = style.__class__.merge(style, self.style)

        if debug_stream is not None:
            if self._transform:
                debug_stream.write(f&#34;({self._transform})&#34;)

            styles_dbg = []
            for attr in merged_style.MERGE_PROPERTIES:
                val = getattr(merged_style, attr)
                if val is not merged_style.INHERIT:
                    if getattr(self.style, attr) is merged_style.INHERIT:
                        inherited = &#34; (inherited)&#34;
                    else:
                        inherited = &#34;&#34;
                    styles_dbg.append(f&#34;{attr}: {val}{inherited}&#34;)

            if styles_dbg:
                debug_stream.write(&#34; {\n&#34;)
                for style_dbg_line in styles_dbg:
                    debug_stream.write(pfx + &#34;    &#34;)
                    debug_stream.write(style_dbg_line)
                    debug_stream.write(&#34;\n&#34;)

                debug_stream.write(pfx + &#34;}┐\n&#34;)
            else:
                debug_stream.write(&#34;\n&#34;)

        NO_EMIT_SET = (None, merged_style.INHERIT)

        emit_style = self.style
        if merged_style.allow_transparency != self.style.allow_transparency:
            emit_style = deepcopy(self.style)
            emit_style.allow_transparency = merged_style.allow_transparency

        # in order to decouple the dash pattern and the dash phase at the API layer,
        # we have to perform additional logic here to recombine them. We can rely
        # on these being serializable because we always get a sane style on the
        # drawing context.
        dash_pattern = merged_style.stroke_dash_pattern
        dash_phase = merged_style.stroke_dash_phase
        emit_dash = None
        if (
            dash_pattern != style.stroke_dash_pattern
            or dash_phase != style.stroke_dash_phase
        ):
            if emit_style is self.style:
                emit_style = deepcopy(emit_style)
            emit_style.stroke_dash_pattern = dash_pattern
            emit_style.stroke_dash_phase = dash_phase
            emit_dash = (dash_pattern, dash_phase)

        if (
            emit_style.soft_mask
            and emit_style.soft_mask is not GraphicsStyle.INHERIT
            and emit_style.soft_mask.object_id == 0
        ):
            emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                emit_style.soft_mask
            )
        # ---- If fill/stroke use a GradientPaint with alpha, synthesize a soft mask now
        # Compute bbox once so mask and color share the same mapping
        bbox_for_units = self.bounding_box(
            initial_point, style=self.style, expand_for_stroke=False
        )[0]

        def _attach_alpha_mask_if_needed(paint_obj: GradientPaint):
            if not isinstance(paint_obj, GradientPaint):
                return
            if not paint_obj.has_alpha():
                return
            # bbox in content space (shared by color &amp; mask)
            bbox_for_units = self.bounding_box(
                initial_point,
                style=self.style,
                expand_for_stroke=False,
                transformed=False,
            )[0]
            # rectangular mask covering the painted area
            mask_rect = PaintedPath()
            mask_rect.rectangle(
                bbox_for_units.x0,
                bbox_for_units.y0,
                bbox_for_units.width,
                bbox_for_units.height,
            )
            # paint that rectangle with the grayscale alpha gradient
            alpha_paint = _AlphaGradientPaint(
                paint_obj.gradient,
                paint_obj.units,
                gradient_transform=paint_obj.gradient_transform,
            )
            alpha_paint.apply_page_ctm = paint_obj.apply_page_ctm
            mask_rect.style.fill_color = alpha_paint
            mask_rect.style.stroke_color = None
            mask_rect.style.stroke_width = 0
            mask_rect.style.paint_rule = PathPaintRule.FILL_NONZERO

            mask_gc = GraphicsContext()
            mask_gc.add_item(mask_rect, _copy=False)

            # use luminosity so gray intensity drives coverage
            sm = PaintSoftMask(
                mask_gc,
                invert=False,
                use_luminosity=True,
                matrix=paint_obj.gradient_transform,
            )

            nonlocal emit_style
            if emit_style.allow_transparency is False:
                return
            if emit_style is self.style:
                emit_style = deepcopy(self.style)
            emit_style.soft_mask = sm
            emit_style.soft_mask.object_id = resource_registry.register_soft_mask(
                emit_style.soft_mask
            )

        # Decide whether to attach a soft mask from fill or stroke gradient alpha.
        # Priority: fill first (most common), otherwise stroke.
        if isinstance(emit_style.fill_color, GradientPaint) and (
            emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
        ):
            _attach_alpha_mask_if_needed(self.style.fill_color)
        elif isinstance(emit_style.stroke_color, GradientPaint) and (
            emit_style.soft_mask in (None, GraphicsStyle.INHERIT)
        ):
            _attach_alpha_mask_if_needed(self.style.stroke_color)

        style_dict_name = resource_registry.register_graphics_style(emit_style)

        if style_dict_name is not None:
            render_list.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

        # we can&#39;t set color in the graphics state context dictionary, so we have to
        # manually inherit it and emit it here.
        fill_color = self.style.fill_color
        stroke_color = self.style.stroke_color

        if fill_color not in NO_EMIT_SET:
            if isinstance(fill_color, GradientPaint):
                render_list.append(
                    fill_color.emit_fill(resource_registry, bbox_for_units)
                )
            else:
                render_list.append(fill_color.serialize().lower())

        if stroke_color not in NO_EMIT_SET:
            if isinstance(stroke_color, GradientPaint):
                render_list.append(
                    stroke_color.emit_stroke(resource_registry, bbox_for_units)
                )
            else:
                render_list.append(stroke_color.serialize().upper())

        if emit_dash is not None:
            render_list.append(
                render_pdf_primitive(emit_dash[0])
                + f&#34; {number_to_str(emit_dash[1])} d&#34;
            )

        if debug_stream:
            if self.clipping_path is not None:
                debug_stream.write(pfx + &#34; ├─ &#34;)
                rendered_cpath, _, __ = self.clipping_path.render_debug(
                    resource_registry,
                    merged_style,
                    last_item,
                    initial_point,
                    debug_stream,
                    pfx + &#34; │  &#34;,
                )
                if rendered_cpath:
                    render_list.append(rendered_cpath)

            for item in self.path_items[:-1]:
                debug_stream.write(pfx + &#34; ├─ &#34;)
                rendered, last_item, initial_point = item.render_debug(
                    resource_registry,
                    merged_style,
                    last_item,
                    initial_point,
                    debug_stream,
                    pfx + &#34; │  &#34;,
                )

                if rendered:
                    render_list.append(rendered)

            debug_stream.write(pfx + &#34; └─ &#34;)
            rendered, last_item, initial_point = self.path_items[-1].render_debug(
                resource_registry,
                merged_style,
                last_item,
                initial_point,
                debug_stream,
                pfx + &#34;    &#34;,
            )

            if rendered:
                render_list.append(rendered)

        else:
            if self.clipping_path is not None:
                rendered_cpath, _, __ = self.clipping_path.render(
                    resource_registry, merged_style, last_item, initial_point
                )
                if rendered_cpath:
                    render_list.append(rendered_cpath)

            for item in self.path_items:
                rendered, last_item, initial_point = item.render(
                    resource_registry, merged_style, last_item, initial_point
                )

                if rendered:
                    render_list.append(rendered)

        # insert transform before points
        if self.transform is not None:
            render_list.insert(0, self.transform.render(last_item)[0])

        if _push_stack:
            render_list.insert(0, &#34;q&#34;)
            render_list.append(&#34;Q&#34;)

    return render_list, last_item, initial_point</code></pre>
</details>
<div class="desc"><p>Build a list composed of all all the individual elements rendered.</p>
<p>This is used by <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code> and <code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code> to reuse the <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>
rendering process while still being able to inject some path specific items
(e.g. the painting directive) before the render is collapsed into a single
string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
<dt><strong><code>_push_stack</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, wrap the resulting render list in a push/pop
graphics stack directive pair.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple[list[str], last_item]</code> where <code>last_item</code> is the past path element in
this <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code></p></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self,<br>other_context: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4248-L4250" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def merge(self, other_context: &#34;GraphicsContext&#34;) -&gt; None:
    &#34;&#34;&#34;Copy another `GraphicsContext`&#39;s path items into this one.&#34;&#34;&#34;
    self.path_items.extend(other_context.path_items)</code></pre>
</details>
<div class="desc"><p>Copy another <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>'s path items into this one.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.remove_last_item"><code class="name flex">
<span>def <span class="ident">remove_last_item</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4245-L4246" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def remove_last_item(self) -&gt; None:
    del self.path_items[-1]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>debug_stream=None,<br>pfx=None) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4588-L4608" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
    debug_stream=None,
    pfx=None,
    _push_stack=True,
) -&gt; tuple[str, Renderable, Point]:
    render_list, last_item, initial_point = self.build_render_list(
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=_push_stack,
    )

    return &#34; &#34;.join(render_list), last_item, initial_point</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4610-L4628" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_debug(
    self,
    resource_registry,
    style,
    last_item,
    initial_point,
    debug_stream,
    pfx,
    _push_stack=True,
):
    return self.render(
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=_push_stack,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.GraphicsStyle"><code class="flex name class">
<span>class <span class="ident">GraphicsStyle</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"><p>A class representing various style attributes that determine drawing appearance.</p>
<p>This class uses the convention that the global Python singleton ellipsis (<code>&hellip;</code>) is
exclusively used to represent values that are inherited from the parent style. This
is to disambiguate the value None which is used for several values to signal an
explicitly disabled style. An example of this is the fill/stroke color styles,
which use None as hints to the auto paint style detection code.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.INHERIT"><code class="name">var <span class="ident">INHERIT</span></code></dt>
<dd>
<div class="desc"><p>Singleton specifying a style parameter should be inherited from the parent context.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.MERGE_PROPERTIES"><code class="name">var <span class="ident">MERGE_PROPERTIES</span></code></dt>
<dd>
<div class="desc"><p>An ordered collection of properties to use when merging two GraphicsStyles.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.PDF_STYLE_KEYS"><code class="name">var <span class="ident">PDF_STYLE_KEYS</span></code></dt>
<dd>
<div class="desc"><p>An ordered collection of keys to directly emit when serializing the style.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.TRANSPARENCY_KEYS"><code class="name">var <span class="ident">TRANSPARENCY_KEYS</span></code></dt>
<dd>
<div class="desc"><p>An ordered collection of attributes not to emit in no transparency mode.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>parent: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>child: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>) ‑> <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Merge parent and child into a single GraphicsStyle.</p>
<p>The result contains the properties of the parent as overridden by any properties
explicitly set on the child. If both the parent and the child specify to
inherit a given property, that property will preserve the inherit value.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.BM"><code class="name">var <span class="ident">BM</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.CA"><code class="name">var <span class="ident">CA</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.LC"><code class="name">var <span class="ident">LC</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.LJ"><code class="name">var <span class="ident">LJ</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.LW"><code class="name">var <span class="ident">LW</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.ML"><code class="name">var <span class="ident">ML</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.SA"><code class="name">var <span class="ident">SA</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.SMask"><code class="name">var <span class="ident">SMask</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.allow_transparency"><code class="name">prop <span class="ident">allow_transparency</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L658-L660" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def allow_transparency(self):
    return self._allow_transparency  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.auto_close"><code class="name">prop <span class="ident">auto_close</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L683-L686" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def auto_close(self):
    &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
    return self._auto_close  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>If True, unclosed paths will be automatically closed before stroking.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.blend_mode"><code class="name">prop <span class="ident">blend_mode</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L786-L789" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def blend_mode(self):
    &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.BLEND_MODE.value)</code></pre>
</details>
<div class="desc"><p>The desired blend mode for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.ca"><code class="name">var <span class="ident">ca</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L519-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    _PRIVATE_SLOTS = (
        &#34;_allow_transparency&#34;,
        &#34;_auto_close&#34;,
        &#34;_fill_color&#34;,
        &#34;_intersection_rule&#34;,
        &#34;_paint_rule&#34;,
        &#34;_stroke_color&#34;,
        &#34;_stroke_dash_pattern&#34;,
        &#34;_stroke_dash_phase&#34;,
    )

    __slots__ = _PRIVATE_SLOTS + tuple(
        k.value
        for k in PDFStyleKeys
        # we do not store STROKE_DASH_PATTERN under its PDF key; it&#39;s in _stroke_dash_pattern
        if k is not PDFStyleKeys.STROKE_DASH_PATTERN
    )

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
        &#34;soft_mask&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
        PDFStyleKeys.SOFT_MASK.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent: &#34;GraphicsStyle&#34;, child: &#34;GraphicsStyle&#34;) -&gt; &#34;GraphicsStyle&#34;:
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT
        self.soft_mask = self.INHERIT

    def __deepcopy__(self, memo):
        cls = self.__class__
        new = cls.__new__(cls)  # bypass __init__
        # copy private slots directly
        for s in cls._PRIVATE_SLOTS:
            object.__setattr__(new, s, getattr(self, s, cls.INHERIT))
        # copy PDF-exposed slots (BM, ca, CA, etc.)
        for key in cls.PDF_STYLE_KEYS:
            object.__setattr__(new, key, getattr(self, key, cls.INHERIT))
        return new

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK, GradientPaint)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if getattr(color, &#34;a&#34;, None) is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    @property
    def soft_mask(self):
        return getattr(self, PDFStyleKeys.SOFT_MASK.value)

    @soft_mask.setter
    def soft_mask(self, value):
        if value is self.INHERIT or isinstance(value, PaintSoftMask):
            return super().__setattr__(PDFStyleKeys.SOFT_MASK.value, value)
        raise TypeError(f&#34;{value} isn&#39;t a PaintSoftMask or GraphicsStyle.INHERIT&#34;)

    def serialize(self) -&gt; Optional[Raw]:
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the graphics state registry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.fill_color"><code class="name">prop <span class="ident">fill_color</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L708-L716" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def fill_color(self):
    &#34;&#34;&#34;
    The desired fill color for this path/group.

    When setting this property, if the color specifies an opacity value, that will
    be used to set the fill_opacity property as well.
    &#34;&#34;&#34;
    return self._fill_color  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>The desired fill color for this path/group.</p>
<p>When setting this property, if the color specifies an opacity value, that will
be used to set the fill_opacity property as well.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.fill_opacity"><code class="name">prop <span class="ident">fill_opacity</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L734-L737" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def fill_opacity(self):
    &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.FILL_ALPHA.value)</code></pre>
</details>
<div class="desc"><p>The desired fill opacity for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.intersection_rule"><code class="name">prop <span class="ident">intersection_rule</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L695-L698" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def intersection_rule(self):
    &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
    return self._intersection_rule  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>The desired intersection rule for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.paint_rule"><code class="name">prop <span class="ident">paint_rule</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L669-L672" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def paint_rule(self):
    &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
    return self._paint_rule  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>The paint rule to use for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.soft_mask"><code class="name">prop <span class="ident">soft_mask</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L898-L900" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def soft_mask(self):
    return getattr(self, PDFStyleKeys.SOFT_MASK.value)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_cap_style"><code class="name">prop <span class="ident">stroke_cap_style</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L815-L818" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_cap_style(self):
    &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)</code></pre>
</details>
<div class="desc"><p>The desired stroke cap style for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_color"><code class="name">prop <span class="ident">stroke_color</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L746-L754" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_color(self):
    &#34;&#34;&#34;
    The desired stroke color for this path/group.

    When setting this property, if the color specifies an opacity value, that will
    be used to set the fill_opacity property as well.
    &#34;&#34;&#34;
    return self._stroke_color  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>The desired stroke color for this path/group.</p>
<p>When setting this property, if the color specifies an opacity value, that will
be used to set the fill_opacity property as well.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_dash_pattern"><code class="name">prop <span class="ident">stroke_dash_pattern</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L856-L859" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_dash_pattern(self):
    &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
    return self._stroke_dash_pattern  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>The desired stroke dash pattern for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_dash_phase"><code class="name">prop <span class="ident">stroke_dash_phase</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L886-L889" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_dash_phase(self):
    &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
    return self._stroke_dash_phase  # pylint: disable=no-member</code></pre>
</details>
<div class="desc"><p>The desired stroke dash pattern phase offset for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_join_style"><code class="name">prop <span class="ident">stroke_join_style</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L829-L832" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_join_style(self):
    &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)</code></pre>
</details>
<div class="desc"><p>The desired stroke join style for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_miter_limit"><code class="name">prop <span class="ident">stroke_miter_limit</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L844-L847" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_miter_limit(self):
    &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)</code></pre>
</details>
<div class="desc"><p>The desired stroke miter limit for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_opacity"><code class="name">prop <span class="ident">stroke_opacity</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L774-L777" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_opacity(self):
    &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)</code></pre>
</details>
<div class="desc"><p>The desired stroke opacity for this path/group.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_width"><code class="name">prop <span class="ident">stroke_width</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L800-L803" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def stroke_width(self):
    &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)</code></pre>
</details>
<div class="desc"><p>The desired stroke width for this path/group.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.resolve_paint_rule"><code class="name flex">
<span>def <span class="ident">resolve_paint_rule</span></span>(<span>self) ‑> <a title="fpdf.enums.PathPaintRule" href="enums.html#fpdf.enums.PathPaintRule">PathPaintRule</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L950-L985" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def resolve_paint_rule(self) -&gt; PathPaintRule:
    &#34;&#34;&#34;
    Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

    Returns:
        the resolved `PathPaintRule`.
    &#34;&#34;&#34;
    if self.paint_rule is PathPaintRule.AUTO:
        want = set()
        if self.stroke_width is not None and self.stroke_color is not None:
            want.add(&#34;stroke&#34;)
        if self.fill_color is not None:
            want.add(&#34;fill&#34;)
            # we need to guarantee that this will not be None. The default will
            # be &#34;nonzero&#34;.
            assert self.intersection_rule is not None
            want.add(self.intersection_rule)

        try:
            rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
        except KeyError:
            # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
            # good default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

    elif self.paint_rule is self.INHERIT:
        # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
        # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
        # sane(?) default.
        rule = PathPaintRule.STROKE_FILL_NONZERO

    else:
        rule = self.paint_rule

    return rule</code></pre>
</details>
<div class="desc"><p>Resolve <code>PathPaintRule.AUTO</code> to a real paint rule based on this style.</p>
<h2 id="returns">Returns</h2>
<p>the resolved <code>PathPaintRule</code>.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> <a title="fpdf.syntax.Raw" href="syntax.html#fpdf.syntax.Raw">Raw</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L908-L948" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self) -&gt; Optional[Raw]:
    &#34;&#34;&#34;
    Convert this style object to a PDF dictionary with appropriate style keys.

    Only explicitly specified values are emitted.
    &#34;&#34;&#34;
    result = OrderedDict()

    for key in self.PDF_STYLE_KEYS:
        value = getattr(self, key, self.INHERIT)

        if (value is not self.INHERIT) and (value is not None):
            # None is used for out-of-band signaling on these, e.g. a stroke_width
            # of None doesn&#39;t need to land here because it signals the
            # PathPaintRule auto resolution only.
            result[key] = value

    # There is additional logic in GraphicsContext to ensure that this will work
    if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
        result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
            self.stroke_dash_pattern,
            self.stroke_dash_phase,
        ]

    if self.allow_transparency is False:
        for key in self.TRANSPARENCY_KEYS:
            if key in result:
                del result[key]

    if result:
        # Only insert this key if there is at least one other item in the result so
        # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
        type_name = Name(&#34;Type&#34;)
        result[type_name] = Name(&#34;ExtGState&#34;)
        result.move_to_end(type_name, last=False)

        return render_pdf_primitive(result)

    # this signals to the graphics state registry that there is nothing to
    # register. This is a success case.
    return None</code></pre>
</details>
<div class="desc"><p>Convert this style object to a PDF dictionary with appropriate style keys.</p>
<p>Only explicitly specified values are emitted.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.HorizontalLine"><code class="flex name class">
<span>class <span class="ident">HorizontalLine</span></span>
<span>(</span><span>x: int | float | decimal.Decimal)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1324-L1394" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class HorizontalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its ordinate from the end of the previous element.

    See: `PaintedPath.horizontal_line_to`
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;The abscissa of the horizontal line&#39;s end point.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a horizontal line from the start point to the new x.&#34;&#34;&#34;
        end = Point(float(self.x), start.y)
        return BoundingBox.from_points([start, end]), end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=self.x, y=last_item.end_point.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `HorizontalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path line element that takes its ordinate from the end of the previous element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.horizontal_line_to" href="#fpdf.drawing.PaintedPath.horizontal_line_to">PaintedPath.horizontal_line_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.HorizontalLine.x"><code class="name">var <span class="ident">x</span> : int | float | decimal.Decimal</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1324-L1394" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class HorizontalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its ordinate from the end of the previous element.

    See: `PaintedPath.horizontal_line_to`
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;The abscissa of the horizontal line&#39;s end point.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a horizontal line from the start point to the new x.&#34;&#34;&#34;
        end = Point(float(self.x), start.y)
        return BoundingBox.from_points([start, end]), end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=self.x, y=last_item.end_point.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `HorizontalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The abscissa of the horizontal line's end point.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.HorizontalLine.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1334-L1337" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of a horizontal line from the start point to the new x.&#34;&#34;&#34;
    end = Point(float(self.x), start.y)
    return BoundingBox.from_points([start, end]), end</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of a horizontal line from the start point to the new x.</p></div>
</dd>
<dt id="fpdf.drawing.HorizontalLine.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1339-L1363" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `Line`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    end_point = Point(x=self.x, y=last_item.end_point.y)
    return _render_line(end_point), Line(end_point), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.HorizontalLine.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1365-L1394" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `HorizontalLine.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.HorizontalLine.render" href="#fpdf.drawing.HorizontalLine.render">HorizontalLine.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.ImplicitClose"><code class="flex name class">
<span>class <span class="ident">ImplicitClose</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3038-L3107" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class ImplicitClose(NamedTuple):
    &#34;&#34;&#34;
    A path close element that is conditionally rendered depending on the value of
    `GraphicsStyle.auto_close`.
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Return an empty bounding box; Close does not affect the geometry.&#34;&#34;&#34;
        return BoundingBox.empty(), start

    # pylint: disable=no-self-use
    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old
            last_item was.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        if style.auto_close:
            return &#34;h&#34;, last_item, initial_point

        return &#34;&#34;, last_item, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `ImplicitClose.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path close element that is conditionally rendered depending on the value of
<code><a title="fpdf.drawing.GraphicsStyle.auto_close" href="#fpdf.drawing.GraphicsStyle.auto_close">GraphicsStyle.auto_close</a></code>.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.ImplicitClose.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3045-L3047" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Return an empty bounding box; Close does not affect the geometry.&#34;&#34;&#34;
    return BoundingBox.empty(), start</code></pre>
</details>
<div class="desc"><p>Return an empty bounding box; Close does not affect the geometry.</p></div>
</dd>
<dt id="fpdf.drawing.ImplicitClose.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3050-L3076" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old
        last_item was.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    if style.auto_close:
        return &#34;h&#34;, last_item, initial_point

    return &#34;&#34;, last_item, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is whatever the old
last_item was.</p></div>
</dd>
<dt id="fpdf.drawing.ImplicitClose.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3078-L3107" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `ImplicitClose.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.ImplicitClose.render" href="#fpdf.drawing.ImplicitClose.render">ImplicitClose.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1170-L1245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Line(NamedTuple):
    &#34;&#34;&#34;
    A path line element.

    This draws a straight line from the end point of the previous path element to the
    point specified by `pt`.

    See: `PaintedPath.line_to`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The point to which the line is drawn.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.pt

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a line from the start point to the end point.&#34;&#34;&#34;
        return BoundingBox.from_points([start, self.pt]), self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_line(self.pt), self, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Line.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path line element.</p>
<p>This draws a straight line from the end point of the previous path element to the
point specified by <code>pt</code>.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.line_to" href="#fpdf.drawing.PaintedPath.line_to">PaintedPath.line_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Line.end_point"><code class="name">prop <span class="ident">end_point</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1183-L1186" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def end_point(self) -&gt; Point:
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.pt</code></pre>
</details>
<div class="desc"><p>The end point of this path element.</p></div>
</dd>
<dt id="fpdf.drawing.Line.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1170-L1245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Line(NamedTuple):
    &#34;&#34;&#34;
    A path line element.

    This draws a straight line from the end point of the previous path element to the
    point specified by `pt`.

    See: `PaintedPath.line_to`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The point to which the line is drawn.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.pt

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a line from the start point to the end point.&#34;&#34;&#34;
        return BoundingBox.from_points([start, self.pt]), self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_line(self.pt), self, initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Line.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The point to which the line is drawn.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Line.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1188-L1190" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of a line from the start point to the end point.&#34;&#34;&#34;
    return BoundingBox.from_points([start, self.pt]), self.pt</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of a line from the start point to the end point.</p></div>
</dd>
<dt id="fpdf.drawing.Line.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1192-L1214" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    return _render_line(self.pt), self, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is <code>self</code></p></div>
</dd>
<dt id="fpdf.drawing.Line.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1216-L1245" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `Line.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(str(self) + &#34;\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.Line.render" href="#fpdf.drawing.Line.render">Line.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Move"><code class="flex name class">
<span>class <span class="ident">Move</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1018-L1092" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Move(NamedTuple):
    &#34;&#34;&#34;
    A path move element.

    If a path has been created but not yet painted, this will create a new subpath.

    See: `PaintedPath.move_to`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The point to which to move.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.pt

    # pylint: disable=unused-argument
    def bounding_box(self, start) -&gt; tuple[BoundingBox, Point]:
        bbox = BoundingBox.empty()
        return bbox, self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        return _render_move(self.pt), self, self.pt

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Move.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path move element.</p>
<p>If a path has been created but not yet painted, this will create a new subpath.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.move_to" href="#fpdf.drawing.PaintedPath.move_to">PaintedPath.move_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Move.end_point"><code class="name">prop <span class="ident">end_point</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1030-L1033" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def end_point(self) -&gt; Point:
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.pt</code></pre>
</details>
<div class="desc"><p>The end point of this path element.</p></div>
</dd>
<dt id="fpdf.drawing.Move.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1018-L1092" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Move(NamedTuple):
    &#34;&#34;&#34;
    A path move element.

    If a path has been created but not yet painted, this will create a new subpath.

    See: `PaintedPath.move_to`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The point to which to move.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.pt

    # pylint: disable=unused-argument
    def bounding_box(self, start) -&gt; tuple[BoundingBox, Point]:
        bbox = BoundingBox.empty()
        return bbox, self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        return _render_move(self.pt), self, self.pt

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Move.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The point to which to move.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Move.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self, start) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1036-L1038" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start) -&gt; tuple[BoundingBox, Point]:
    bbox = BoundingBox.empty()
    return bbox, self.pt</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.Move.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1040-L1061" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
    &#34;&#34;&#34;
    return _render_move(self.pt), self, self.pt</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is <code>self</code></p></div>
</dd>
<dt id="fpdf.drawing.Move.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1064-L1092" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `Move.render`.
    &#34;&#34;&#34;
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(str(self) + &#34;\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.Move.render" href="#fpdf.drawing.Move.render">Move.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.PaintBlendComposite"><code class="flex name class">
<span>class <span class="ident">PaintBlendComposite</span></span>
<span>(</span><span>backdrop: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a>,<br>source: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a>,<br>blend_mode: <a title="fpdf.enums.BlendMode" href="enums.html#fpdf.enums.BlendMode">BlendMode</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5150-L5215" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintBlendComposite:
    __slots__ = (&#34;backdrop&#34;, &#34;source&#34;, &#34;blend_mode&#34;, &#34;_form_index&#34;)

    def __init__(
        self,
        backdrop: Union[GraphicsContext, PaintedPath],
        source: Union[GraphicsContext, PaintedPath],
        blend_mode: BlendMode,
    ):
        if not isinstance(backdrop, (PaintedPath, GraphicsContext)) or not isinstance(
            source, (PaintedPath, GraphicsContext)
        ):
            raise TypeError(
                &#34;PaintBlendComposite requires PaintedPath or GraphicsContext operands.&#34;
            )
        self.backdrop = backdrop
        self.source = source
        self.blend_mode = blend_mode
        self._form_index: Optional[int] = None

    def _ensure_form_index(self, resource_registry, base_style: GraphicsStyle) -&gt; int:
        if self._form_index is not None:
            return self._form_index

        group = GraphicsContext()
        backdrop_node = self.backdrop
        source_node = self.source

        if hasattr(source_node, &#34;style&#34;):
            source_node.style.blend_mode = self.blend_mode
            if source_node.style.allow_transparency is False:
                source_node.style.allow_transparency = GraphicsStyle.INHERIT

        group.add_item(backdrop_node, _copy=False)
        group.add_item(source_node, _copy=False)

        effective_style = (
            base_style if isinstance(base_style, GraphicsStyle) else GraphicsStyle()
        )
        blend_group = _BlendGroup(group, effective_style)
        self._form_index = resource_registry.register_blend_form(blend_group)
        self.backdrop = None
        self.source = None
        return self._form_index

    # pylint: disable=unused-argument
    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        form_index = self._ensure_form_index(resource_registry, style)
        rendered = f&#34;q /I{form_index} Do Q&#34;
        return rendered, last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        debug_stream.write(f&#34;{pfx}&lt;PaintBlendComposite mode={self.blend_mode}&gt;\n&#34;)
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.PaintBlendComposite.backdrop"><code class="name">var <span class="ident">backdrop</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5150-L5215" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintBlendComposite:
    __slots__ = (&#34;backdrop&#34;, &#34;source&#34;, &#34;blend_mode&#34;, &#34;_form_index&#34;)

    def __init__(
        self,
        backdrop: Union[GraphicsContext, PaintedPath],
        source: Union[GraphicsContext, PaintedPath],
        blend_mode: BlendMode,
    ):
        if not isinstance(backdrop, (PaintedPath, GraphicsContext)) or not isinstance(
            source, (PaintedPath, GraphicsContext)
        ):
            raise TypeError(
                &#34;PaintBlendComposite requires PaintedPath or GraphicsContext operands.&#34;
            )
        self.backdrop = backdrop
        self.source = source
        self.blend_mode = blend_mode
        self._form_index: Optional[int] = None

    def _ensure_form_index(self, resource_registry, base_style: GraphicsStyle) -&gt; int:
        if self._form_index is not None:
            return self._form_index

        group = GraphicsContext()
        backdrop_node = self.backdrop
        source_node = self.source

        if hasattr(source_node, &#34;style&#34;):
            source_node.style.blend_mode = self.blend_mode
            if source_node.style.allow_transparency is False:
                source_node.style.allow_transparency = GraphicsStyle.INHERIT

        group.add_item(backdrop_node, _copy=False)
        group.add_item(source_node, _copy=False)

        effective_style = (
            base_style if isinstance(base_style, GraphicsStyle) else GraphicsStyle()
        )
        blend_group = _BlendGroup(group, effective_style)
        self._form_index = resource_registry.register_blend_form(blend_group)
        self.backdrop = None
        self.source = None
        return self._form_index

    # pylint: disable=unused-argument
    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        form_index = self._ensure_form_index(resource_registry, style)
        rendered = f&#34;q /I{form_index} Do Q&#34;
        return rendered, last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        debug_stream.write(f&#34;{pfx}&lt;PaintBlendComposite mode={self.blend_mode}&gt;\n&#34;)
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintBlendComposite.blend_mode"><code class="name">var <span class="ident">blend_mode</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5150-L5215" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintBlendComposite:
    __slots__ = (&#34;backdrop&#34;, &#34;source&#34;, &#34;blend_mode&#34;, &#34;_form_index&#34;)

    def __init__(
        self,
        backdrop: Union[GraphicsContext, PaintedPath],
        source: Union[GraphicsContext, PaintedPath],
        blend_mode: BlendMode,
    ):
        if not isinstance(backdrop, (PaintedPath, GraphicsContext)) or not isinstance(
            source, (PaintedPath, GraphicsContext)
        ):
            raise TypeError(
                &#34;PaintBlendComposite requires PaintedPath or GraphicsContext operands.&#34;
            )
        self.backdrop = backdrop
        self.source = source
        self.blend_mode = blend_mode
        self._form_index: Optional[int] = None

    def _ensure_form_index(self, resource_registry, base_style: GraphicsStyle) -&gt; int:
        if self._form_index is not None:
            return self._form_index

        group = GraphicsContext()
        backdrop_node = self.backdrop
        source_node = self.source

        if hasattr(source_node, &#34;style&#34;):
            source_node.style.blend_mode = self.blend_mode
            if source_node.style.allow_transparency is False:
                source_node.style.allow_transparency = GraphicsStyle.INHERIT

        group.add_item(backdrop_node, _copy=False)
        group.add_item(source_node, _copy=False)

        effective_style = (
            base_style if isinstance(base_style, GraphicsStyle) else GraphicsStyle()
        )
        blend_group = _BlendGroup(group, effective_style)
        self._form_index = resource_registry.register_blend_form(blend_group)
        self.backdrop = None
        self.source = None
        return self._form_index

    # pylint: disable=unused-argument
    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        form_index = self._ensure_form_index(resource_registry, style)
        rendered = f&#34;q /I{form_index} Do Q&#34;
        return rendered, last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        debug_stream.write(f&#34;{pfx}&lt;PaintBlendComposite mode={self.blend_mode}&gt;\n&#34;)
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintBlendComposite.source"><code class="name">var <span class="ident">source</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5150-L5215" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintBlendComposite:
    __slots__ = (&#34;backdrop&#34;, &#34;source&#34;, &#34;blend_mode&#34;, &#34;_form_index&#34;)

    def __init__(
        self,
        backdrop: Union[GraphicsContext, PaintedPath],
        source: Union[GraphicsContext, PaintedPath],
        blend_mode: BlendMode,
    ):
        if not isinstance(backdrop, (PaintedPath, GraphicsContext)) or not isinstance(
            source, (PaintedPath, GraphicsContext)
        ):
            raise TypeError(
                &#34;PaintBlendComposite requires PaintedPath or GraphicsContext operands.&#34;
            )
        self.backdrop = backdrop
        self.source = source
        self.blend_mode = blend_mode
        self._form_index: Optional[int] = None

    def _ensure_form_index(self, resource_registry, base_style: GraphicsStyle) -&gt; int:
        if self._form_index is not None:
            return self._form_index

        group = GraphicsContext()
        backdrop_node = self.backdrop
        source_node = self.source

        if hasattr(source_node, &#34;style&#34;):
            source_node.style.blend_mode = self.blend_mode
            if source_node.style.allow_transparency is False:
                source_node.style.allow_transparency = GraphicsStyle.INHERIT

        group.add_item(backdrop_node, _copy=False)
        group.add_item(source_node, _copy=False)

        effective_style = (
            base_style if isinstance(base_style, GraphicsStyle) else GraphicsStyle()
        )
        blend_group = _BlendGroup(group, effective_style)
        self._form_index = resource_registry.register_blend_form(blend_group)
        self.backdrop = None
        self.source = None
        return self._form_index

    # pylint: disable=unused-argument
    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        form_index = self._ensure_form_index(resource_registry, style)
        rendered = f&#34;q /I{form_index} Do Q&#34;
        return rendered, last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        debug_stream.write(f&#34;{pfx}&lt;PaintBlendComposite mode={self.blend_mode}&gt;\n&#34;)
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.PaintBlendComposite.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5196-L5207" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry,
    style,
    last_item,
    initial_point,
    debug_stream=None,
    pfx=None,
):
    form_index = self._ensure_form_index(resource_registry, style)
    rendered = f&#34;q /I{form_index} Do Q&#34;
    return rendered, last_item, initial_point</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintBlendComposite.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5209-L5215" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    debug_stream.write(f&#34;{pfx}&lt;PaintBlendComposite mode={self.blend_mode}&gt;\n&#34;)
    return self.render(
        resource_registry, style, last_item, initial_point, debug_stream, pfx
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.PaintComposite"><code class="flex name class">
<span>class <span class="ident">PaintComposite</span></span>
<span>(</span><span>backdrop,<br>source,<br>operation: <a title="fpdf.enums.CompositingOperation" href="enums.html#fpdf.enums.CompositingOperation">CompositingOperation</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4943-L5054" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintComposite:

    @dataclass(frozen=True)
    class _Step:
        draw: str  # &#34;source&#34; or &#34;backdrop&#34;
        mask_from: Optional[str]  # &#34;source&#34; | &#34;backdrop&#34; | None
        invert: bool = False

    _MODES = {
        CompositingOperation.SOURCE: (_Step(&#34;source&#34;, None),),
        CompositingOperation.DESTINATION: (_Step(&#34;backdrop&#34;, None),),
        CompositingOperation.SOURCE_OVER: (
            _Step(&#34;backdrop&#34;, None),
            _Step(&#34;source&#34;, None),
        ),
        CompositingOperation.DESTINATION_OVER: (
            _Step(&#34;source&#34;, None),
            _Step(&#34;backdrop&#34;, None),
        ),
        CompositingOperation.SOURCE_IN: (_Step(&#34;source&#34;, &#34;backdrop&#34;),),
        CompositingOperation.DESTINATION_IN: (_Step(&#34;backdrop&#34;, &#34;source&#34;),),
        CompositingOperation.SOURCE_OUT: (_Step(&#34;source&#34;, &#34;backdrop&#34;, True),),
        CompositingOperation.DESTINATION_OUT: (_Step(&#34;backdrop&#34;, &#34;source&#34;, True),),
        CompositingOperation.SOURCE_ATOP: (
            _Step(&#34;backdrop&#34;, &#34;source&#34;, True),
            _Step(&#34;source&#34;, &#34;backdrop&#34;),
        ),
        CompositingOperation.DESTINATION_ATOP: (
            _Step(&#34;source&#34;, &#34;backdrop&#34;, True),
            _Step(&#34;backdrop&#34;, &#34;source&#34;),
        ),
        CompositingOperation.XOR: (
            _Step(&#34;source&#34;, &#34;backdrop&#34;, True),
            _Step(&#34;backdrop&#34;, &#34;source&#34;, True),
        ),
        CompositingOperation.CLEAR: tuple(),
    }

    def __init__(self, backdrop, source, operation: CompositingOperation):
        if not isinstance(backdrop, (PaintedPath, GraphicsContext)) or not isinstance(
            source, (PaintedPath, GraphicsContext)
        ):
            raise TypeError(&#34;PaintComposite requires two PaintedPath instances.&#34;)
        self.backdrop = backdrop
        self.source = source
        self.mode = operation

        if self.mode not in self._MODES:
            raise NotImplementedError(
                f&#34;Compositing mode &#39;{self.mode.value}&#39; is not yet supported.&#34;
            )

    @classmethod
    def _with_mask(
        cls,
        path: Union[PaintedPath, GraphicsContext],
        mask_from: Union[PaintedPath, GraphicsContext],
        invert: bool,
        resource_registry,
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        p = deepcopy(path)

        A = PaintSoftMask.alpha_layers_from(p)
        B = PaintSoftMask.coverage_white(mask_from)

        bb_p = p.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
        bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
        region_bbox = bb_p.merge(bb_B)

        sm = PaintSoftMask.from_AB(
            A, B, invert, resource_registry, region_bbox=region_bbox
        )
        p.style.soft_mask = sm
        _disable_auto_alpha(p)
        return p

    def _pick(self, which: str) -&gt; Union[PaintedPath, GraphicsContext]:
        return self.source if which == &#34;source&#34; else self.backdrop

    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        steps = self._MODES[self.mode]
        if not steps:  # CLEAR
            return &#34;&#34;, last_item, initial_point

        parts = []
        for st in steps:
            node = self._pick(st.draw)
            if st.mask_from is not None:
                node = self._with_mask(
                    node, self._pick(st.mask_from), st.invert, resource_registry
                )
            s, last_item, initial_point = node.render(
                resource_registry, style, last_item, initial_point, debug_stream, pfx
            )
            parts.append(s)
        return &#34; &#34;.join(parts), last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        debug_stream.write(f&#34;{pfx}&lt;PaintComposite mode={self.mode}&gt;\n&#34;)
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.PaintComposite.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5022-L5046" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry,
    style,
    last_item,
    initial_point,
    debug_stream=None,
    pfx=None,
):
    steps = self._MODES[self.mode]
    if not steps:  # CLEAR
        return &#34;&#34;, last_item, initial_point

    parts = []
    for st in steps:
        node = self._pick(st.draw)
        if st.mask_from is not None:
            node = self._with_mask(
                node, self._pick(st.mask_from), st.invert, resource_registry
            )
        s, last_item, initial_point = node.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )
        parts.append(s)
    return &#34; &#34;.join(parts), last_item, initial_point</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintComposite.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5048-L5054" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    debug_stream.write(f&#34;{pfx}&lt;PaintComposite mode={self.mode}&gt;\n&#34;)
    return self.render(
        resource_registry, style, last_item, initial_point, debug_stream, pfx
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.PaintSoftMask"><code class="flex name class">
<span>class <span class="ident">PaintSoftMask</span></span>
<span>(</span><span>mask_path: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a>,<br>invert: bool = False,<br>use_luminosity=False,<br>matrix=Transform(a=1, b=0, c=0, d=1, e=0, f=0))</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"><p>Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
graphics state.</p>
<p>The provided <code>mask_path</code> is deep-copied and forced to render as an opaque
grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
rendering, the mask’s content stream is generated and its resource
dictionary is collected so it can be embedded as a Form XObject and
referenced from an ExtGState.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.drawing.PaintSoftMask.alpha_layers_from"><code class="name flex">
<span>def <span class="ident">alpha_layers_from</span></span>(<span>node) ‑> <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4773-L4820" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
    &#34;&#34;&#34;
    Build a GraphicsContext that encodes the *alpha ramps* contributed by any
    `GradientPaint` used by *node*. Each contributing PaintedPath yields one
    rectangle covering its content-space bounding box; that rectangle is filled
    with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
    Rectangles are stacked with `BM=Multiply` so multiple alpha sources
    combine multiplicatively.
    &#34;&#34;&#34;
    layers = []
    for n in _iter_nodes(node):
        if isinstance(n, PaintedPath):
            for paint in (n.style.fill_color, n.style.stroke_color):
                if (
                    isinstance(paint, GradientPaint)
                    and paint.gradient
                    and paint.gradient.has_alpha()
                ):
                    bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                    if bb.width &lt;= 0 or bb.height &lt;= 0:
                        continue
                    rect = PaintedPath()
                    rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                    alpha_paint = _AlphaGradientPaint(
                        gradient=paint.gradient,
                        units=paint.units,
                        gradient_transform=paint.gradient_transform,
                        apply_page_ctm=paint.apply_page_ctm,
                    )
                    rect.style.fill_color = alpha_paint
                    rect.style.stroke_color = None
                    rect.style.stroke_width = 0
                    rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                    layer_gc = GraphicsContext()
                    layer_gc.add_item(rect, _copy=False)
                    # multiply multiple alpha contributors together
                    layer_gc.style.blend_mode = BlendMode.MULTIPLY
                    layers.append(layer_gc)

    if not layers:
        return None

    A = GraphicsContext()
    for layer in layers:
        A.add_item(layer)
    return A</code></pre>
</details>
<div class="desc"><p>Build a GraphicsContext that encodes the <em>alpha ramps</em> contributed by any
<code><a title="fpdf.drawing.GradientPaint" href="#fpdf.drawing.GradientPaint">GradientPaint</a></code> used by <em>node</em>. Each contributing PaintedPath yields one
rectangle covering its content-space bounding box; that rectangle is filled
with an <code>_AlphaGradientPaint</code> (the gradient’s <em>alpha channel only</em>).
Rectangles are stacked with <code>BM=Multiply</code> so multiple alpha sources
combine multiplicatively.</p></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.coverage_white"><code class="name flex">
<span>def <span class="ident">coverage_white</span></span>(<span>node: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a>) ‑> <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4728-L4771" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def coverage_white(
    node: Union[PaintedPath, GraphicsContext],
) -&gt; Union[PaintedPath, GraphicsContext]:
    &#34;&#34;&#34;
    Return a deep-copied version of *node* whose appearance encodes only its
    geometric coverage: every shape is converted to an **opaque white fill**
    (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

    The transform/clipping/structure of the original node is preserved; only
    paint-related attributes are normalized. This is intended for building the
    “B” term of soft-mask expressions (coverage), where inside = 1 and
    outside = 0.
    &#34;&#34;&#34;

    def _force_white(gc: GraphicsContext):
        # normalize the GC&#39;s own style
        gc.style.paint_rule = PathPaintRule.FILL_NONZERO
        gc.style.fill_color = &#34;#ffffff&#34;
        gc.style.fill_opacity = 1
        gc.style.stroke_color = None
        gc.style.blend_mode = GraphicsStyle.INHERIT
        gc.style.soft_mask = GraphicsStyle.INHERIT

        # recurse into children
        for child in gc.path_items:
            if isinstance(child, GraphicsContext):
                _force_white(child)
            elif isinstance(child, PaintedPath):
                child.style.paint_rule = PathPaintRule.FILL_NONZERO
                child.style.fill_color = &#34;#ffffff&#34;
                child.style.fill_opacity = 1
                child.style.stroke_color = None
                child.style.blend_mode = GraphicsStyle.INHERIT
                child.style.soft_mask = GraphicsStyle.INHERIT

    new_node = clone_structure(node)
    gc = (
        new_node
        if isinstance(new_node, GraphicsContext)
        else new_node.get_graphics_context()
    )
    _force_white(gc)
    return new_node</code></pre>
</details>
<div class="desc"><p>Return a deep-copied version of <em>node</em> whose appearance encodes only its
geometric coverage: every shape is converted to an <strong>opaque white fill</strong>
(nonzero rule), with <strong>no stroke</strong>, no soft mask, and inherited blend mode.</p>
<p>The transform/clipping/structure of the original node is preserved; only
paint-related attributes are normalized. This is intended for building the
“B” term of soft-mask expressions (coverage), where inside = 1 and
outside = 0.</p></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.from_AB"><code class="name flex">
<span>def <span class="ident">from_AB</span></span>(<span>A: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | None,<br>B: <a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a> | <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a>,<br>invert: bool,<br>registry,<br>region_bbox: <a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a> | None = None) ‑> <a title="fpdf.drawing.PaintSoftMask" href="#fpdf.drawing.PaintSoftMask">PaintSoftMask</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a <strong>luminosity soft mask</strong> from two ingredients:</p>
<ul>
<li><strong>A</strong>: Optional GraphicsContext encoding alpha ramps (e.g., the result of
:meth:<code>alpha_layers_from</code>). If <code>None</code>, the effective alpha is 1.</li>
<li><strong>B</strong>: Coverage term (e.g., the result of :meth:<code>coverage_white</code>).</li>
</ul>
<p>The mask luminance is:
- <code>A × B</code>
when <code>invert = False</code>
- <code>A × (1 − B)</code>
when <code>invert = True</code></p>
<p>Implementation outline:
1. Compute the union bbox of A and B (no stroke expansion).
2. Paint a background rectangle: <strong>black</strong> for <code>A×B</code> or <strong>white</strong> for
<code>A×(1−B)</code>.
3. Paint <strong>B</strong>; when <code>invert=True</code>, set <code>BM=Difference</code> to obtain
<code>1−B</code> from the white background.
4. If A is present, paint it with <code>BM=Multiply</code> to apply the alpha ramp.
5. Wrap the result as a Form XObject and attach it as <code>/SMask</code> with
<code>/S /Luminosity</code>.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.PaintSoftMask.invert"><code class="name">var <span class="ident">invert</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.mask_path"><code class="name">var <span class="ident">mask_path</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.matrix"><code class="name">var <span class="ident">matrix</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.object_id"><code class="name">var <span class="ident">object_id</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.use_luminosity"><code class="name">var <span class="ident">use_luminosity</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4631-L4886" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintSoftMask:
    &#34;&#34;&#34;
    Wraps a vector path as a PDF soft mask (SMask) that can be attached to a
    graphics state.

    The provided `mask_path` is deep-copied and forced to render as an opaque
    grayscale fill (white, alpha=1, nonzero rule, transparency disabled). During
    rendering, the mask’s content stream is generated and its resource
    dictionary is collected so it can be embedded as a Form XObject and
    referenced from an ExtGState.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;mask_path&#34;,
        &#34;invert&#34;,
        &#34;resources&#34;,
        &#34;use_luminosity&#34;,
        &#34;object_id&#34;,
        &#34;matrix&#34;,
    )

    def __init__(
        self,
        mask_path: Union[PaintedPath, GraphicsContext],
        invert: bool = False,
        use_luminosity=False,
        matrix=Transform.identity(),
    ):
        self.mask_path = deepcopy(mask_path)
        self.invert = invert
        self.use_luminosity = use_luminosity
        self.resources = set()
        self.object_id = 0
        self.matrix = matrix

        if not self.use_luminosity:
            # Pure alpha mask -&gt; force opaque white so shape defines coverage
            self.mask_path.style.paint_rule = PathPaintRule.FILL_NONZERO
            self.mask_path.style.fill_opacity = 1
            self.mask_path.style.fill_color = &#34;#ffffff&#34;

    def serialize(self):
        tr = (
            &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
            if self.invert
            else &#34;&#34;
        )
        mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
        return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;

    def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
        bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
        return bounding_box.to_tuple()

    def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
        &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
        resources_registered: dict[str, list] = {}
        for resource_type, resource_id in self.resources:
            resources_registered.setdefault(resource_type.value, set()).add(resource_id)

        parts: list[str] = []

        # ExtGState
        if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
            parts.append(
                Name(&#34;ExtGState&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                    for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )

        # Pattern
        if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
            parts.append(
                Name(&#34;Pattern&#34;).serialize()
                + &#34;&lt;&lt;&#34;
                + &#34;&#34;.join(
                    f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                    for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
                )
                + &#34;&gt;&gt;&#34;
            )
        return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;

    def render(self, resource_registry):
        stream, _, _ = self.mask_path.render(
            resource_registry,
            style=GraphicsStyle(),
            last_item=None,
            initial_point=Point(0, 0),
        )
        self.resources = resource_registry.scan_stream(stream)
        return stream

    @staticmethod
    def coverage_white(
        node: Union[PaintedPath, GraphicsContext],
    ) -&gt; Union[PaintedPath, GraphicsContext]:
        &#34;&#34;&#34;
        Return a deep-copied version of *node* whose appearance encodes only its
        geometric coverage: every shape is converted to an **opaque white fill**
        (nonzero rule), with **no stroke**, no soft mask, and inherited blend mode.

        The transform/clipping/structure of the original node is preserved; only
        paint-related attributes are normalized. This is intended for building the
        “B” term of soft-mask expressions (coverage), where inside = 1 and
        outside = 0.
        &#34;&#34;&#34;

        def _force_white(gc: GraphicsContext):
            # normalize the GC&#39;s own style
            gc.style.paint_rule = PathPaintRule.FILL_NONZERO
            gc.style.fill_color = &#34;#ffffff&#34;
            gc.style.fill_opacity = 1
            gc.style.stroke_color = None
            gc.style.blend_mode = GraphicsStyle.INHERIT
            gc.style.soft_mask = GraphicsStyle.INHERIT

            # recurse into children
            for child in gc.path_items:
                if isinstance(child, GraphicsContext):
                    _force_white(child)
                elif isinstance(child, PaintedPath):
                    child.style.paint_rule = PathPaintRule.FILL_NONZERO
                    child.style.fill_color = &#34;#ffffff&#34;
                    child.style.fill_opacity = 1
                    child.style.stroke_color = None
                    child.style.blend_mode = GraphicsStyle.INHERIT
                    child.style.soft_mask = GraphicsStyle.INHERIT

        new_node = clone_structure(node)
        gc = (
            new_node
            if isinstance(new_node, GraphicsContext)
            else new_node.get_graphics_context()
        )
        _force_white(gc)
        return new_node

    @staticmethod
    def alpha_layers_from(node) -&gt; Optional[GraphicsContext]:
        &#34;&#34;&#34;
        Build a GraphicsContext that encodes the *alpha ramps* contributed by any
        `GradientPaint` used by *node*. Each contributing PaintedPath yields one
        rectangle covering its content-space bounding box; that rectangle is filled
        with an `_AlphaGradientPaint` (the gradient’s *alpha channel only*).
        Rectangles are stacked with `BM=Multiply` so multiple alpha sources
        combine multiplicatively.
        &#34;&#34;&#34;
        layers = []
        for n in _iter_nodes(node):
            if isinstance(n, PaintedPath):
                for paint in (n.style.fill_color, n.style.stroke_color):
                    if (
                        isinstance(paint, GradientPaint)
                        and paint.gradient
                        and paint.gradient.has_alpha()
                    ):
                        bb = n.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
                        if bb.width &lt;= 0 or bb.height &lt;= 0:
                            continue
                        rect = PaintedPath()
                        rect.rectangle(bb.x0, bb.y0, bb.width, bb.height)
                        alpha_paint = _AlphaGradientPaint(
                            gradient=paint.gradient,
                            units=paint.units,
                            gradient_transform=paint.gradient_transform,
                            apply_page_ctm=paint.apply_page_ctm,
                        )
                        rect.style.fill_color = alpha_paint
                        rect.style.stroke_color = None
                        rect.style.stroke_width = 0
                        rect.style.paint_rule = PathPaintRule.FILL_NONZERO

                        layer_gc = GraphicsContext()
                        layer_gc.add_item(rect, _copy=False)
                        # multiply multiple alpha contributors together
                        layer_gc.style.blend_mode = BlendMode.MULTIPLY
                        layers.append(layer_gc)

        if not layers:
            return None

        A = GraphicsContext()
        for layer in layers:
            A.add_item(layer)
        return A

    @classmethod
    def from_AB(
        cls,
        A: Optional[GraphicsContext],
        B: Union[PaintedPath, GraphicsContext],
        invert: bool,
        registry,
        region_bbox: Optional[&#34;BoundingBox&#34;] = None,
    ) -&gt; &#34;PaintSoftMask&#34;:
        &#34;&#34;&#34;
        Construct a **luminosity soft mask** from two ingredients:

        - **A**: Optional GraphicsContext encoding alpha ramps (e.g., the result of
        :meth:`alpha_layers_from`). If ``None``, the effective alpha is 1.
        - **B**: Coverage term (e.g., the result of :meth:`coverage_white`).

        The mask luminance is:
            - ``A × B``        when ``invert = False``
            - ``A × (1 − B)``  when ``invert = True``

        Implementation outline:
        1. Compute the union bbox of A and B (no stroke expansion).
        2. Paint a background rectangle: **black** for ``A×B`` or **white** for
        ``A×(1−B)``.
        3. Paint **B**; when ``invert=True``, set ``BM=Difference`` to obtain
        ``1−B`` from the white background.
        4. If A is present, paint it with ``BM=Multiply`` to apply the alpha ramp.
        5. Wrap the result as a Form XObject and attach it as ``/SMask`` with
        ``/S /Luminosity``.
        &#34;&#34;&#34;

        # Decide the canvas/BBox for the soft mask
        if region_bbox is not None:
            union = region_bbox
        else:
            bb_A = (
                A.bounding_box(Point(0, 0), expand_for_stroke=False)[0] if A else None
            )
            bb_B = B.bounding_box(Point(0, 0), expand_for_stroke=False)[0]
            union = bb_B if bb_A is None else bb_A.merge(bb_B)

        canvas = GraphicsContext()

        # Background: black for A×B, white for A×(1−B)
        bg = PaintedPath()
        bg.rectangle(union.x0, union.y0, union.width, union.height)
        bg.style.fill_color = &#34;#000000&#34; if not invert else &#34;#ffffff&#34;
        bg.style.fill_opacity = 1
        bg.style.stroke_color = None
        canvas.add_item(bg)

        # Paint B (optionally build 1−B using Difference on white bg)
        if invert:
            B.style.blend_mode = BlendMode.DIFFERENCE
        canvas.add_item(B)

        # Multiply by A if present
        if A is not None:
            A.style.blend_mode = BlendMode.MULTIPLY
            canvas.add_item(A)

        sm = cls(canvas, invert=False, use_luminosity=True)
        _ = sm.render(registry)
        sm.object_id = registry.register_soft_mask(sm)
        return sm</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.PaintSoftMask.get_bounding_box"><code class="name flex">
<span>def <span class="ident">get_bounding_box</span></span>(<span>self) ‑> tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4681-L4683" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_bounding_box(self) -&gt; tuple[float, float, float, float]:
    bounding_box, _ = self.mask_path.bounding_box(Point(0, 0))
    return bounding_box.to_tuple()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.get_resource_dictionary"><code class="name flex">
<span>def <span class="ident">get_resource_dictionary</span></span>(<span>self, gfxstate_objs_per_name, pattern_objs_per_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4685-L4716" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_resource_dictionary(self, gfxstate_objs_per_name, pattern_objs_per_name):
    &#34;&#34;&#34;Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.&#34;&#34;&#34;
    resources_registered: dict[str, list] = {}
    for resource_type, resource_id in self.resources:
        resources_registered.setdefault(resource_type.value, set()).add(resource_id)

    parts: list[str] = []

    # ExtGState
    if &#34;ExtGState&#34; in resources_registered and resources_registered[&#34;ExtGState&#34;]:
        parts.append(
            Name(&#34;ExtGState&#34;).serialize()
            + &#34;&lt;&lt;&#34;
            + &#34;&#34;.join(
                f&#34;{Name(gs_name).serialize()} {gfxstate_objs_per_name[gs_name].id} 0 R&#34;
                for gs_name in sorted(resources_registered[&#34;ExtGState&#34;])
            )
            + &#34;&gt;&gt;&#34;
        )

    # Pattern
    if &#34;Pattern&#34; in resources_registered and resources_registered[&#34;Pattern&#34;]:
        parts.append(
            Name(&#34;Pattern&#34;).serialize()
            + &#34;&lt;&lt;&#34;
            + &#34;&#34;.join(
                f&#34;{Name(pat_name).serialize()} {pattern_objs_per_name[pat_name].id} 0 R&#34;
                for pat_name in sorted(resources_registered[&#34;Pattern&#34;])
            )
            + &#34;&gt;&gt;&#34;
        )
    return &#34;&lt;&lt;&#34; + &#34;&#34;.join(parts) + &#34;&gt;&gt;&#34;</code></pre>
</details>
<div class="desc"><p>Build the resource dictionary for this soft mask, resolving GS &amp; Pattern ids.</p></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, resource_registry)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4718-L4726" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(self, resource_registry):
    stream, _, _ = self.mask_path.render(
        resource_registry,
        style=GraphicsStyle(),
        last_item=None,
        initial_point=Point(0, 0),
    )
    self.resources = resource_registry.scan_stream(stream)
    return stream</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintSoftMask.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4672-L4679" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def serialize(self):
    tr = (
        &#34; /TR &lt;&lt;/FunctionType 2 /Domain [0 1] /Range [0 1] /C0 [1] /C1 [0] /N 1&gt;&gt;&#34;
        if self.invert
        else &#34;&#34;
    )
    mask_type = &#34;/Luminosity&#34; if self.use_luminosity else &#34;/Alpha&#34;
    return f&#34;&lt;&lt;/S {mask_type} /G {self.object_id} 0 R{tr}&gt;&gt;&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.PaintedPath"><code class="flex name class">
<span>class <span class="ident">PaintedPath</span></span>
<span>(</span><span>x: float = 0, y: float = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3432-L4065" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PaintedPath:
    &#34;&#34;&#34;
    A path to be drawn by the PDF renderer.

    A painted path is defined by a style and an arbitrary sequence of path elements,
    which include the primitive path elements (`Move`, `Line`, `BezierCurve`, ...) as
    well as arbitrarily nested `GraphicsContext` containing their own sequence of
    primitive path elements and `GraphicsContext`.
    &#34;&#34;&#34;

    __slots__ = (
        &#34;_root_graphics_context&#34;,
        &#34;_graphics_context&#34;,
        &#34;_closed&#34;,
        &#34;_close_context&#34;,
        &#34;_starter_move&#34;,
    )

    def __init__(self, x: float = 0, y: float = 0) -&gt; None:
        self._root_graphics_context: GraphicsContext = GraphicsContext()
        self._graphics_context: GraphicsContext = self._root_graphics_context

        self._closed: bool = True
        self._close_context: GraphicsContext = self._graphics_context

        self._starter_move: Renderable = Move(Point(x, y))

    def __deepcopy__(self, memo):
        # there&#39;s no real way to recover the matching current _graphics_context after
        # copying the root context, but that&#39;s ok because we can just disallow copying
        # of paths under modification as that is almost certainly wrong usage.
        if self._graphics_context is not self._root_graphics_context:
            raise RuntimeError(f&#34;cannot copy path {self} while it is being modified&#34;)

        copied = self.__class__()
        copied._root_graphics_context = deepcopy(self._root_graphics_context, memo)
        copied._graphics_context = copied._root_graphics_context
        copied._closed = self._closed
        copied._close_context = copied._graphics_context

        return copied

    @property
    def style(self) -&gt; GraphicsStyle:
        &#34;&#34;&#34;The `GraphicsStyle` applied to all elements of this path.&#34;&#34;&#34;
        return self._root_graphics_context.style

    @property
    def transform(self) -&gt; Optional[Transform]:
        &#34;&#34;&#34;The `Transform` that applies to all of the elements of this path.&#34;&#34;&#34;
        return self._root_graphics_context.transform

    @transform.setter
    def transform(self, tf: Transform) -&gt; None:
        self._root_graphics_context.transform = tf

    @property
    def auto_close(self) -&gt; bool:
        &#34;&#34;&#34;If true, the path should automatically close itself before painting.&#34;&#34;&#34;
        return self.style.auto_close

    @auto_close.setter
    def auto_close(self, should: bool) -&gt; None:
        self.style.auto_close = should

    @property
    def paint_rule(self) -&gt; PathPaintRule:
        &#34;&#34;&#34;Manually specify the `PathPaintRule` to use for rendering the path.&#34;&#34;&#34;
        return self.style.paint_rule

    @paint_rule.setter
    def paint_rule(self, style: PathPaintRule) -&gt; None:
        self.style.paint_rule = style

    @property
    def clipping_path(self):
        &#34;&#34;&#34;Set the clipping path for this path.&#34;&#34;&#34;
        return self._root_graphics_context.clipping_path

    @clipping_path.setter
    def clipping_path(self, new_clipath):
        self._root_graphics_context.clipping_path = new_clipath

    def get_graphics_context(self):
        return self._graphics_context

    @contextmanager
    def _new_graphics_context(self, _attach=True):
        old_graphics_context = self._graphics_context
        new_graphics_context = GraphicsContext()
        self._graphics_context = new_graphics_context
        try:
            yield new_graphics_context
            if _attach:
                old_graphics_context.add_item(new_graphics_context)
        finally:
            self._graphics_context = old_graphics_context

    @contextmanager
    def transform_group(self, transform):
        &#34;&#34;&#34;
        Apply the provided `Transform` to all points added within this context.
        &#34;&#34;&#34;
        with self._new_graphics_context() as ctxt:
            ctxt.transform = transform
            yield self

    def add_path_element(self, item, _copy=True):
        &#34;&#34;&#34;
        Add the given element as a path item of this path.

        Args:
            item: the item to add to this path.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;
        if self._starter_move is not None:
            self._closed = False
            self._graphics_context.add_item(self._starter_move, _copy=False)
            self._close_context = self._graphics_context
            self._starter_move = None

        self._graphics_context.add_item(item, _copy=_copy)

    def remove_last_path_element(self):
        self._graphics_context.remove_last_item()

    def rectangle(self, x, y, w, h, rx=0, ry=0):
        &#34;&#34;&#34;
        Append a rectangle as a closed subpath to the current path.

        If the width or the height are 0, the rectangle will be collapsed to a line
        (unless they&#39;re both 0, in which case it&#39;s collapsed to nothing).

        Args:
            x (Number): the abscissa of the starting corner of the rectangle.
            y (Number): the ordinate of the starting corner of the rectangle.
            w (Number): the width of the rectangle (if 0, the rectangle will be
                rendered as a vertical line).
            h (Number): the height of the rectangle (if 0, the rectangle will be
                rendered as a horizontal line).
            rx (Number): the x-radius of the rectangle rounded corner (if 0 the corners
                will not be rounded).
            ry (Number): the y-radius of the rectangle rounded corner (if 0 the corners
                will not be rounded).

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;

        self._insert_implicit_close_if_open()
        self.add_path_element(
            RoundedRectangle(Point(x, y), Point(w, h), Point(rx, ry)), _copy=False
        )
        self._closed = True
        self.move_to(x, y)

        return self

    def circle(self, cx, cy, r):
        &#34;&#34;&#34;
        Append a circle as a closed subpath to the current path.

        Args:
            cx (Number): the abscissa of the circle&#39;s center point.
            cy (Number): the ordinate of the circle&#39;s center point.
            r (Number): the radius of the circle.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        return self.ellipse(cx, cy, r, r)

    def ellipse(self, cx, cy, rx, ry):
        &#34;&#34;&#34;
        Append an ellipse as a closed subpath to the current path.

        Args:
            cx (Number): the abscissa of the ellipse&#39;s center point.
            cy (Number): the ordinate of the ellipse&#39;s center point.
            rx (Number): the x-radius of the ellipse.
            ry (Number): the y-radius of the ellipse.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self._insert_implicit_close_if_open()
        self.add_path_element(Ellipse(Point(rx, ry), Point(cx, cy)), _copy=False)
        self._closed = True
        self.move_to(cx, cy)

        return self

    def move_to(self, x, y):
        &#34;&#34;&#34;
        Start a new subpath or move the path starting point.

        If no path elements have been added yet, this will change the path starting
        point. If path elements have been added, this will insert an implicit close in
        order to start a new subpath.

        Args:
            x (Number): abscissa of the (sub)path starting point.
            y (Number): ordinate of the (sub)path starting point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self._insert_implicit_close_if_open()
        self._starter_move = Move(Point(x, y))
        return self

    def move_relative(self, x, y):
        &#34;&#34;&#34;
        Start a new subpath or move the path start point relative to the previous point.

        If no path elements have been added yet, this will change the path starting
        point. If path elements have been added, this will insert an implicit close in
        order to start a new subpath.

        This will overwrite an absolute move_to as long as no non-move path items have
        been appended. The relative position is resolved from the previous item when
        the path is being rendered, or from 0, 0 if it is the first item.

        Args:
            x (Number): abscissa of the (sub)path starting point relative to the previous point.
            y (Number): ordinate of the (sub)path starting point relative to the previous point.
        &#34;&#34;&#34;
        self._insert_implicit_close_if_open()
        if self._starter_move is not None:
            self._closed = False
            self._graphics_context.add_item(self._starter_move, _copy=False)
            self._close_context = self._graphics_context
        self._starter_move = RelativeMove(Point(x, y))
        return self

    def line_to(self, x, y):
        &#34;&#34;&#34;
        Append a straight line to this path.

        Args:
            x (Number): abscissa the line&#39;s end point.
            y (Number): ordinate of the line&#39;s end point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(Line(Point(x, y)), _copy=False)
        return self

    def line_relative(self, dx, dy):
        &#34;&#34;&#34;
        Append a straight line whose end is computed as an offset from the end of the
        previous path element.

        Args:
            x (Number): abscissa the line&#39;s end point relative to the end point of the
                previous path element.
            y (Number): ordinate of the line&#39;s end point relative to the end point of
                the previous path element.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(RelativeLine(Point(dx, dy)), _copy=False)
        return self

    def horizontal_line_to(self, x):
        &#34;&#34;&#34;
        Append a straight horizontal line to the given abscissa. The ordinate is
        retrieved from the end point of the previous path element.

        Args:
            x (Number): abscissa of the line&#39;s end point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(HorizontalLine(x), _copy=False)
        return self

    def horizontal_line_relative(self, dx):
        &#34;&#34;&#34;
        Append a straight horizontal line to the given offset from the previous path
        element. The ordinate is retrieved from the end point of the previous path
        element.

        Args:
            x (Number): abscissa of the line&#39;s end point relative to the end point of
                the previous path element.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(RelativeHorizontalLine(dx), _copy=False)
        return self

    def vertical_line_to(self, y):
        &#34;&#34;&#34;
        Append a straight vertical line to the given ordinate. The abscissa is
        retrieved from the end point of the previous path element.

        Args:
            y (Number): ordinate of the line&#39;s end point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(VerticalLine(y), _copy=False)
        return self

    def vertical_line_relative(self, dy):
        &#34;&#34;&#34;
        Append a straight vertical line to the given offset from the previous path
        element. The abscissa is retrieved from the end point of the previous path
        element.

        Args:
            y (Number): ordinate of the line&#39;s end point relative to the end point of
                the previous path element.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(RelativeVerticalLine(dy), _copy=False)
        return self

    def curve_to(self, x1, y1, x2, y2, x3, y3):
        &#34;&#34;&#34;
        Append a cubic Bézier curve to this path.

        Args:
            x1 (Number): abscissa of the first control point
            y1 (Number): ordinate of the first control point
            x2 (Number): abscissa of the second control point
            y2 (Number): ordinate of the second control point
            x3 (Number): abscissa of the end point
            y3 (Number): ordinate of the end point

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        ctrl1 = Point(x1, y1)
        ctrl2 = Point(x2, y2)
        end = Point(x3, y3)

        self.add_path_element(BezierCurve(ctrl1, ctrl2, end), _copy=False)
        return self

    def curve_relative(self, dx1, dy1, dx2, dy2, dx3, dy3):
        &#34;&#34;&#34;
        Append a cubic Bézier curve whose points are expressed relative to the
        end point of the previous path element.

        E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output
        curve would have the points:

        (0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)

        Args:
            dx1 (Number): abscissa of the first control point relative to the end point
                of the previous path element
            dy1 (Number): ordinate of the first control point relative to the end point
                of the previous path element
            dx2 (Number): abscissa offset of the second control point relative to the
                end point of the previous path element
            dy2 (Number): ordinate offset of the second control point relative to the
                end point of the previous path element
            dx3 (Number): abscissa offset of the end point relative to the end point of
                the previous path element
            dy3 (Number): ordinate offset of the end point relative to the end point of
                the previous path element

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        c1d = Point(dx1, dy1)
        c2d = Point(dx2, dy2)
        end = Point(dx3, dy3)

        self.add_path_element(RelativeBezierCurve(c1d, c2d, end), _copy=False)
        return self

    def quadratic_curve_to(self, x1, y1, x2, y2):
        &#34;&#34;&#34;
        Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.

        Args:
            x1 (Number): abscissa of the control point
            y1 (Number): ordinate of the control point
            x2 (Number): abscissa of the end point
            y2 (Number): ordinate of the end point

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        ctrl = Point(x1, y1)
        end = Point(x2, y2)
        self.add_path_element(QuadraticBezierCurve(ctrl, end), _copy=False)
        return self

    def quadratic_curve_relative(self, dx1, dy1, dx2, dy2):
        &#34;&#34;&#34;
        Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.

        Args:
            dx1 (Number): abscissa of the control point relative to the end point of
                the previous path element
            dy1 (Number): ordinate of the control point relative to the end point of
                the previous path element
            dx2 (Number): abscissa offset of the end point relative to the end point of
                the previous path element
            dy2 (Number): ordinate offset of the end point relative to the end point of
                the previous path element

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        ctrl = Point(dx1, dy1)
        end = Point(dx2, dy2)
        self.add_path_element(RelativeQuadraticBezierCurve(ctrl, end), _copy=False)
        return self

    def arc_to(self, rx, ry, rotation, large_arc, positive_sweep, x, y):
        &#34;&#34;&#34;
        Append an elliptical arc from the end of the previous path point to the
        specified end point.

        The arc is approximated using Bézier curves, so it is not perfectly accurate.
        However, the error is small enough to not be noticeable at any reasonable
        (and even most unreasonable) scales, with a worst-case deviation of around 3‱.

        Notes:
            - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their
              absolute values are used instead).
            - If either radius is 0, then a straight line will be emitted instead of an
              arc.
            - If the radii are too small for the arc to reach from the current point to
              the specified end point (`x` and `y`), then they will be proportionally
              scaled up until they are big enough, which will always result in a
              half-ellipse arc (i.e. an 180 degree sweep)

        Args:
            rx (Number): radius in the x-direction.
            ry (Number): radius in the y-direction.
            rotation (Number): angle (in degrees) that the arc should be rotated
                clockwise from the principle axes. This parameter does not have
                a visual effect in the case that `rx == ry`.
            large_arc (bool): if True, the arc will cover a sweep angle of at least 180
                degrees. Otherwise, the sweep angle will be at most 180 degrees.
            positive_sweep (bool): if True, the arc will be swept over a positive angle,
                i.e. clockwise. Otherwise, the arc will be swept over a negative
                angle.
            x (Number): abscissa of the arc&#39;s end point.
            y (Number): ordinate of the arc&#39;s end point.
        &#34;&#34;&#34;

        if rx == 0 or ry == 0:
            return self.line_to(x, y)

        radii = Point(abs(rx), abs(ry))
        large_arc = bool(large_arc)
        rotation = math.radians(rotation)
        positive_sweep = bool(positive_sweep)
        end = Point(x, y)

        self.add_path_element(
            Arc(radii, rotation, large_arc, positive_sweep, end), _copy=False
        )
        return self

    def arc_relative(self, rx, ry, rotation, large_arc, positive_sweep, dx, dy):
        &#34;&#34;&#34;
        Append an elliptical arc from the end of the previous path point to an offset
        point.

        The arc is approximated using Bézier curves, so it is not perfectly accurate.
        However, the error is small enough to not be noticeable at any reasonable
        (and even most unreasonable) scales, with a worst-case deviation of around 3‱.

        Notes:
            - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their
              absolute values are used instead).
            - If either radius is 0, then a straight line will be emitted instead of an
              arc.
            - If the radii are too small for the arc to reach from the current point to
              the specified end point (`x` and `y`), then they will be proportionally
              scaled up until they are big enough, which will always result in a
              half-ellipse arc (i.e. an 180 degree sweep)

        Args:
            rx (Number): radius in the x-direction.
            ry (Number): radius in the y-direction.
            rotation (Number): angle (in degrees) that the arc should be rotated
                clockwise from the principle axes. This parameter does not have
                a visual effect in the case that `rx == ry`.
            large_arc (bool): if True, the arc will cover a sweep angle of at least 180
                degrees. Otherwise, the sweep angle will be at most 180 degrees.
            positive_sweep (bool): if True, the arc will be swept over a positive angle,
                i.e. clockwise. Otherwise, the arc will be swept over a negative
                angle.
            dx (Number): abscissa of the arc&#39;s end point relative to the end point of
                the previous path element.
            dy (Number): ordinate of the arc&#39;s end point relative to the end point of
                the previous path element.
        &#34;&#34;&#34;
        if rx == 0 or ry == 0:
            return self.line_relative(dx, dy)

        radii = Point(abs(rx), abs(ry))
        large_arc = bool(large_arc)
        rotation = math.radians(rotation)
        positive_sweep = bool(positive_sweep)
        end = Point(dx, dy)

        self.add_path_element(
            RelativeArc(radii, rotation, large_arc, positive_sweep, end), _copy=False
        )
        return self

    def text(
        self,
        x: float,
        y: float,
        content: str,
        *,
        font_family: str = &#34;helvetica&#34;,
        font_style: str = &#34;&#34;,  # &#34;&#34;, &#34;B&#34;, &#34;I&#34;, &#34;BI&#34;
        font_size: float = 12.0,
        text_anchor: str = &#34;start&#34;,  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;
    ):
        &#34;&#34;&#34;
        Append a text run at (x, y) to this path.

        The baseline is at (x, y). `text_anchor` controls alignment about x.
        `font_style` accepts &#34;&#34;, &#34;B&#34;, &#34;I&#34;, or &#34;BI&#34;. `font_family` can be a single
        name or a comma-separated fallback list (handled at render-time).

        Returns:
            self (to allow chaining)
        &#34;&#34;&#34;
        # Normalize style just in case e.g. &#34;ib&#34; -&gt; &#34;BI&#34;
        s = &#34;&#34;.join(sorted(font_style.upper()))

        self.add_path_element(
            Text(
                x=x,
                y=y,
                text_runs=(
                    TextRun(
                        text=content,
                        family=font_family,
                        emphasis=s,
                        size=font_size,
                    ),
                ),
                text_anchor=text_anchor,
            ),
            _copy=False,
        )
        return self

    def close(self):
        &#34;&#34;&#34;
        Explicitly close the current (sub)path.
        &#34;&#34;&#34;
        self.add_path_element(Close(), _copy=False)
        self._closed = True
        self.move_relative(0, 0)

    def _insert_implicit_close_if_open(self):
        if not self._closed:
            self._close_context.add_item(ImplicitClose(), _copy=False)
            self._close_context = self._graphics_context
            self._closed = True

    def bounding_box(
        self, start: Point, expand_for_stroke=True
    ) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this painted path, including nested contexts and transformations.&#34;&#34;&#34;
        return self._root_graphics_context.bounding_box(
            start, self.style, expand_for_stroke=expand_for_stroke
        )

    def render(
        self,
        resource_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
    ):
        self._insert_implicit_close_if_open()

        (
            render_list,
            last_item,
            initial_point,
        ) = self._root_graphics_context.build_render_list(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )

        paint_rule = GraphicsStyle.merge(style, self.style).resolve_paint_rule()
        render_list.insert(-1, paint_rule.value)
        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `PaintedPath.render`.
        &#34;&#34;&#34;
        return self.render(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>A path to be drawn by the PDF renderer.</p>
<p>A painted path is defined by a style and an arbitrary sequence of path elements,
which include the primitive path elements (<code><a title="fpdf.drawing.Move" href="#fpdf.drawing.Move">Move</a></code>, <code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>, <code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code>, &hellip;) as
well as arbitrarily nested <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code> containing their own sequence of
primitive path elements and <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.PaintedPath.auto_close"><code class="name">prop <span class="ident">auto_close</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3488-L3491" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def auto_close(self) -&gt; bool:
    &#34;&#34;&#34;If true, the path should automatically close itself before painting.&#34;&#34;&#34;
    return self.style.auto_close</code></pre>
</details>
<div class="desc"><p>If true, the path should automatically close itself before painting.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.clipping_path"><code class="name">prop <span class="ident">clipping_path</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3506-L3509" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def clipping_path(self):
    &#34;&#34;&#34;Set the clipping path for this path.&#34;&#34;&#34;
    return self._root_graphics_context.clipping_path</code></pre>
</details>
<div class="desc"><p>Set the clipping path for this path.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.paint_rule"><code class="name">prop <span class="ident">paint_rule</span> : <a title="fpdf.enums.PathPaintRule" href="enums.html#fpdf.enums.PathPaintRule">PathPaintRule</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3497-L3500" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def paint_rule(self) -&gt; PathPaintRule:
    &#34;&#34;&#34;Manually specify the `PathPaintRule` to use for rendering the path.&#34;&#34;&#34;
    return self.style.paint_rule</code></pre>
</details>
<div class="desc"><p>Manually specify the <code>PathPaintRule</code> to use for rendering the path.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.style"><code class="name">prop <span class="ident">style</span> : <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3474-L3477" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def style(self) -&gt; GraphicsStyle:
    &#34;&#34;&#34;The `GraphicsStyle` applied to all elements of this path.&#34;&#34;&#34;
    return self._root_graphics_context.style</code></pre>
</details>
<div class="desc"><p>The <code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code> applied to all elements of this path.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.transform"><code class="name">prop <span class="ident">transform</span> : <a title="fpdf.drawing_primitives.Transform" href="drawing_primitives.html#fpdf.drawing_primitives.Transform">Transform</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3479-L3482" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def transform(self) -&gt; Optional[Transform]:
    &#34;&#34;&#34;The `Transform` that applies to all of the elements of this path.&#34;&#34;&#34;
    return self._root_graphics_context.transform</code></pre>
</details>
<div class="desc"><p>The <code>Transform</code> that applies to all of the elements of this path.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.PaintedPath.add_path_element"><code class="name flex">
<span>def <span class="ident">add_path_element</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3539-L3556" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def add_path_element(self, item, _copy=True):
    &#34;&#34;&#34;
    Add the given element as a path item of this path.

    Args:
        item: the item to add to this path.
        _copy (bool): if true (the default), the item will be copied before being
            appended. This prevents modifications to a referenced object from
            &#34;retroactively&#34; altering its style/shape and should be disabled with
            caution.
    &#34;&#34;&#34;
    if self._starter_move is not None:
        self._closed = False
        self._graphics_context.add_item(self._starter_move, _copy=False)
        self._close_context = self._graphics_context
        self._starter_move = None

    self._graphics_context.add_item(item, _copy=_copy)</code></pre>
</details>
<div class="desc"><p>Add the given element as a path item of this path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>the item to add to this path.</dd>
<dt><strong><code>_copy</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true (the default), the item will be copied before being
appended. This prevents modifications to a referenced object from
"retroactively" altering its style/shape and should be disabled with
caution.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.arc_relative"><code class="name flex">
<span>def <span class="ident">arc_relative</span></span>(<span>self, rx, ry, rotation, large_arc, positive_sweep, dx, dy)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3905-L3952" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def arc_relative(self, rx, ry, rotation, large_arc, positive_sweep, dx, dy):
    &#34;&#34;&#34;
    Append an elliptical arc from the end of the previous path point to an offset
    point.

    The arc is approximated using Bézier curves, so it is not perfectly accurate.
    However, the error is small enough to not be noticeable at any reasonable
    (and even most unreasonable) scales, with a worst-case deviation of around 3‱.

    Notes:
        - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their
          absolute values are used instead).
        - If either radius is 0, then a straight line will be emitted instead of an
          arc.
        - If the radii are too small for the arc to reach from the current point to
          the specified end point (`x` and `y`), then they will be proportionally
          scaled up until they are big enough, which will always result in a
          half-ellipse arc (i.e. an 180 degree sweep)

    Args:
        rx (Number): radius in the x-direction.
        ry (Number): radius in the y-direction.
        rotation (Number): angle (in degrees) that the arc should be rotated
            clockwise from the principle axes. This parameter does not have
            a visual effect in the case that `rx == ry`.
        large_arc (bool): if True, the arc will cover a sweep angle of at least 180
            degrees. Otherwise, the sweep angle will be at most 180 degrees.
        positive_sweep (bool): if True, the arc will be swept over a positive angle,
            i.e. clockwise. Otherwise, the arc will be swept over a negative
            angle.
        dx (Number): abscissa of the arc&#39;s end point relative to the end point of
            the previous path element.
        dy (Number): ordinate of the arc&#39;s end point relative to the end point of
            the previous path element.
    &#34;&#34;&#34;
    if rx == 0 or ry == 0:
        return self.line_relative(dx, dy)

    radii = Point(abs(rx), abs(ry))
    large_arc = bool(large_arc)
    rotation = math.radians(rotation)
    positive_sweep = bool(positive_sweep)
    end = Point(dx, dy)

    self.add_path_element(
        RelativeArc(radii, rotation, large_arc, positive_sweep, end), _copy=False
    )
    return self</code></pre>
</details>
<div class="desc"><p>Append an elliptical arc from the end of the previous path point to an offset
point.</p>
<p>The arc is approximated using Bézier curves, so it is not perfectly accurate.
However, the error is small enough to not be noticeable at any reasonable
(and even most unreasonable) scales, with a worst-case deviation of around 3‱.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The signs of the radii arguments (<code>rx</code> and <code>ry</code>) are ignored (i.e. their
absolute values are used instead).</li>
<li>If either radius is 0, then a straight line will be emitted instead of an
arc.</li>
<li>If the radii are too small for the arc to reach from the current point to
the specified end point (<code>x</code> and <code>y</code>), then they will be proportionally
scaled up until they are big enough, which will always result in a
half-ellipse arc (i.e. an 180 degree sweep)</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the x-direction.</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the y-direction.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>Number</code></dt>
<dd>angle (in degrees) that the arc should be rotated
clockwise from the principle axes. This parameter does not have
a visual effect in the case that <code>rx == ry</code>.</dd>
<dt><strong><code>large_arc</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will cover a sweep angle of at least 180
degrees. Otherwise, the sweep angle will be at most 180 degrees.</dd>
<dt><strong><code>positive_sweep</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will be swept over a positive angle,
i.e. clockwise. Otherwise, the arc will be swept over a negative
angle.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the arc's end point relative to the end point of
the previous path element.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the arc's end point relative to the end point of
the previous path element.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.arc_to"><code class="name flex">
<span>def <span class="ident">arc_to</span></span>(<span>self, rx, ry, rotation, large_arc, positive_sweep, x, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3857-L3903" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def arc_to(self, rx, ry, rotation, large_arc, positive_sweep, x, y):
    &#34;&#34;&#34;
    Append an elliptical arc from the end of the previous path point to the
    specified end point.

    The arc is approximated using Bézier curves, so it is not perfectly accurate.
    However, the error is small enough to not be noticeable at any reasonable
    (and even most unreasonable) scales, with a worst-case deviation of around 3‱.

    Notes:
        - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their
          absolute values are used instead).
        - If either radius is 0, then a straight line will be emitted instead of an
          arc.
        - If the radii are too small for the arc to reach from the current point to
          the specified end point (`x` and `y`), then they will be proportionally
          scaled up until they are big enough, which will always result in a
          half-ellipse arc (i.e. an 180 degree sweep)

    Args:
        rx (Number): radius in the x-direction.
        ry (Number): radius in the y-direction.
        rotation (Number): angle (in degrees) that the arc should be rotated
            clockwise from the principle axes. This parameter does not have
            a visual effect in the case that `rx == ry`.
        large_arc (bool): if True, the arc will cover a sweep angle of at least 180
            degrees. Otherwise, the sweep angle will be at most 180 degrees.
        positive_sweep (bool): if True, the arc will be swept over a positive angle,
            i.e. clockwise. Otherwise, the arc will be swept over a negative
            angle.
        x (Number): abscissa of the arc&#39;s end point.
        y (Number): ordinate of the arc&#39;s end point.
    &#34;&#34;&#34;

    if rx == 0 or ry == 0:
        return self.line_to(x, y)

    radii = Point(abs(rx), abs(ry))
    large_arc = bool(large_arc)
    rotation = math.radians(rotation)
    positive_sweep = bool(positive_sweep)
    end = Point(x, y)

    self.add_path_element(
        Arc(radii, rotation, large_arc, positive_sweep, end), _copy=False
    )
    return self</code></pre>
</details>
<div class="desc"><p>Append an elliptical arc from the end of the previous path point to the
specified end point.</p>
<p>The arc is approximated using Bézier curves, so it is not perfectly accurate.
However, the error is small enough to not be noticeable at any reasonable
(and even most unreasonable) scales, with a worst-case deviation of around 3‱.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The signs of the radii arguments (<code>rx</code> and <code>ry</code>) are ignored (i.e. their
absolute values are used instead).</li>
<li>If either radius is 0, then a straight line will be emitted instead of an
arc.</li>
<li>If the radii are too small for the arc to reach from the current point to
the specified end point (<code>x</code> and <code>y</code>), then they will be proportionally
scaled up until they are big enough, which will always result in a
half-ellipse arc (i.e. an 180 degree sweep)</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the x-direction.</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the y-direction.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>Number</code></dt>
<dd>angle (in degrees) that the arc should be rotated
clockwise from the principle axes. This parameter does not have
a visual effect in the case that <code>rx == ry</code>.</dd>
<dt><strong><code>large_arc</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will cover a sweep angle of at least 180
degrees. Otherwise, the sweep angle will be at most 180 degrees.</dd>
<dt><strong><code>positive_sweep</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will be swept over a positive angle,
i.e. clockwise. Otherwise, the arc will be swept over a negative
angle.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the arc's end point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the arc's end point.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>expand_for_stroke=True) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4010-L4016" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(
    self, start: Point, expand_for_stroke=True
) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this painted path, including nested contexts and transformations.&#34;&#34;&#34;
    return self._root_graphics_context.bounding_box(
        start, self.style, expand_for_stroke=expand_for_stroke
    )</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this painted path, including nested contexts and transformations.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, cx, cy, r)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3593-L3605" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def circle(self, cx, cy, r):
    &#34;&#34;&#34;
    Append a circle as a closed subpath to the current path.

    Args:
        cx (Number): the abscissa of the circle&#39;s center point.
        cy (Number): the ordinate of the circle&#39;s center point.
        r (Number): the radius of the circle.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    return self.ellipse(cx, cy, r, r)</code></pre>
</details>
<div class="desc"><p>Append a circle as a closed subpath to the current path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the abscissa of the circle's center point.</dd>
<dt><strong><code>cy</code></strong> :&ensp;<code>Number</code></dt>
<dd>the ordinate of the circle's center point.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>Number</code></dt>
<dd>the radius of the circle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3996-L4002" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Explicitly close the current (sub)path.
    &#34;&#34;&#34;
    self.add_path_element(Close(), _copy=False)
    self._closed = True
    self.move_relative(0, 0)</code></pre>
</details>
<div class="desc"><p>Explicitly close the current (sub)path.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.curve_relative"><code class="name flex">
<span>def <span class="ident">curve_relative</span></span>(<span>self, dx1, dy1, dx2, dy2, dx3, dy3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3783-L3815" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def curve_relative(self, dx1, dy1, dx2, dy2, dx3, dy3):
    &#34;&#34;&#34;
    Append a cubic Bézier curve whose points are expressed relative to the
    end point of the previous path element.

    E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output
    curve would have the points:

    (0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)

    Args:
        dx1 (Number): abscissa of the first control point relative to the end point
            of the previous path element
        dy1 (Number): ordinate of the first control point relative to the end point
            of the previous path element
        dx2 (Number): abscissa offset of the second control point relative to the
            end point of the previous path element
        dy2 (Number): ordinate offset of the second control point relative to the
            end point of the previous path element
        dx3 (Number): abscissa offset of the end point relative to the end point of
            the previous path element
        dy3 (Number): ordinate offset of the end point relative to the end point of
            the previous path element

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    c1d = Point(dx1, dy1)
    c2d = Point(dx2, dy2)
    end = Point(dx3, dy3)

    self.add_path_element(RelativeBezierCurve(c1d, c2d, end), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a cubic Bézier curve whose points are expressed relative to the
end point of the previous path element.</p>
<p>E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output
curve would have the points:</p>
<p>(0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dx1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the first control point relative to the end point
of the previous path element</dd>
<dt><strong><code>dy1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the first control point relative to the end point
of the previous path element</dd>
<dt><strong><code>dx2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa offset of the second control point relative to the
end point of the previous path element</dd>
<dt><strong><code>dy2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate offset of the second control point relative to the
end point of the previous path element</dd>
<dt><strong><code>dx3</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa offset of the end point relative to the end point of
the previous path element</dd>
<dt><strong><code>dy3</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate offset of the end point relative to the end point of
the previous path element</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.curve_to"><code class="name flex">
<span>def <span class="ident">curve_to</span></span>(<span>self, x1, y1, x2, y2, x3, y3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3761-L3781" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def curve_to(self, x1, y1, x2, y2, x3, y3):
    &#34;&#34;&#34;
    Append a cubic Bézier curve to this path.

    Args:
        x1 (Number): abscissa of the first control point
        y1 (Number): ordinate of the first control point
        x2 (Number): abscissa of the second control point
        y2 (Number): ordinate of the second control point
        x3 (Number): abscissa of the end point
        y3 (Number): ordinate of the end point

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    ctrl1 = Point(x1, y1)
    ctrl2 = Point(x2, y2)
    end = Point(x3, y3)

    self.add_path_element(BezierCurve(ctrl1, ctrl2, end), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a cubic Bézier curve to this path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the first control point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the first control point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the second control point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the second control point</dd>
<dt><strong><code>x3</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the end point</dd>
<dt><strong><code>y3</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the end point</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, cx, cy, rx, ry)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3607-L3625" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def ellipse(self, cx, cy, rx, ry):
    &#34;&#34;&#34;
    Append an ellipse as a closed subpath to the current path.

    Args:
        cx (Number): the abscissa of the ellipse&#39;s center point.
        cy (Number): the ordinate of the ellipse&#39;s center point.
        rx (Number): the x-radius of the ellipse.
        ry (Number): the y-radius of the ellipse.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self._insert_implicit_close_if_open()
    self.add_path_element(Ellipse(Point(rx, ry), Point(cx, cy)), _copy=False)
    self._closed = True
    self.move_to(cx, cy)

    return self</code></pre>
</details>
<div class="desc"><p>Append an ellipse as a closed subpath to the current path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the abscissa of the ellipse's center point.</dd>
<dt><strong><code>cy</code></strong> :&ensp;<code>Number</code></dt>
<dd>the ordinate of the ellipse's center point.</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the x-radius of the ellipse.</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>the y-radius of the ellipse.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.get_graphics_context"><code class="name flex">
<span>def <span class="ident">get_graphics_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3515-L3516" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def get_graphics_context(self):
    return self._graphics_context</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.horizontal_line_relative"><code class="name flex">
<span>def <span class="ident">horizontal_line_relative</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3715-L3729" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def horizontal_line_relative(self, dx):
    &#34;&#34;&#34;
    Append a straight horizontal line to the given offset from the previous path
    element. The ordinate is retrieved from the end point of the previous path
    element.

    Args:
        x (Number): abscissa of the line&#39;s end point relative to the end point of
            the previous path element.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self.add_path_element(RelativeHorizontalLine(dx), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a straight horizontal line to the given offset from the previous path
element. The ordinate is retrieved from the end point of the previous path
element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the line's end point relative to the end point of
the previous path element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.horizontal_line_to"><code class="name flex">
<span>def <span class="ident">horizontal_line_to</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3701-L3713" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def horizontal_line_to(self, x):
    &#34;&#34;&#34;
    Append a straight horizontal line to the given abscissa. The ordinate is
    retrieved from the end point of the previous path element.

    Args:
        x (Number): abscissa of the line&#39;s end point.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self.add_path_element(HorizontalLine(x), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a straight horizontal line to the given abscissa. The ordinate is
retrieved from the end point of the previous path element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the line's end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.line_relative"><code class="name flex">
<span>def <span class="ident">line_relative</span></span>(<span>self, dx, dy)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3684-L3699" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def line_relative(self, dx, dy):
    &#34;&#34;&#34;
    Append a straight line whose end is computed as an offset from the end of the
    previous path element.

    Args:
        x (Number): abscissa the line&#39;s end point relative to the end point of the
            previous path element.
        y (Number): ordinate of the line&#39;s end point relative to the end point of
            the previous path element.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self.add_path_element(RelativeLine(Point(dx, dy)), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a straight line whose end is computed as an offset from the end of the
previous path element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa the line's end point relative to the end point of the
previous path element.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point relative to the end point of
the previous path element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.line_to"><code class="name flex">
<span>def <span class="ident">line_to</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3670-L3682" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def line_to(self, x, y):
    &#34;&#34;&#34;
    Append a straight line to this path.

    Args:
        x (Number): abscissa the line&#39;s end point.
        y (Number): ordinate of the line&#39;s end point.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self.add_path_element(Line(Point(x, y)), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a straight line to this path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa the line's end point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.move_relative"><code class="name flex">
<span>def <span class="ident">move_relative</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3646-L3668" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def move_relative(self, x, y):
    &#34;&#34;&#34;
    Start a new subpath or move the path start point relative to the previous point.

    If no path elements have been added yet, this will change the path starting
    point. If path elements have been added, this will insert an implicit close in
    order to start a new subpath.

    This will overwrite an absolute move_to as long as no non-move path items have
    been appended. The relative position is resolved from the previous item when
    the path is being rendered, or from 0, 0 if it is the first item.

    Args:
        x (Number): abscissa of the (sub)path starting point relative to the previous point.
        y (Number): ordinate of the (sub)path starting point relative to the previous point.
    &#34;&#34;&#34;
    self._insert_implicit_close_if_open()
    if self._starter_move is not None:
        self._closed = False
        self._graphics_context.add_item(self._starter_move, _copy=False)
        self._close_context = self._graphics_context
    self._starter_move = RelativeMove(Point(x, y))
    return self</code></pre>
</details>
<div class="desc"><p>Start a new subpath or move the path start point relative to the previous point.</p>
<p>If no path elements have been added yet, this will change the path starting
point. If path elements have been added, this will insert an implicit close in
order to start a new subpath.</p>
<p>This will overwrite an absolute move_to as long as no non-move path items have
been appended. The relative position is resolved from the previous item when
the path is being rendered, or from 0, 0 if it is the first item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the (sub)path starting point relative to the previous point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the (sub)path starting point relative to the previous point.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3627-L3644" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def move_to(self, x, y):
    &#34;&#34;&#34;
    Start a new subpath or move the path starting point.

    If no path elements have been added yet, this will change the path starting
    point. If path elements have been added, this will insert an implicit close in
    order to start a new subpath.

    Args:
        x (Number): abscissa of the (sub)path starting point.
        y (Number): ordinate of the (sub)path starting point.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self._insert_implicit_close_if_open()
    self._starter_move = Move(Point(x, y))
    return self</code></pre>
</details>
<div class="desc"><p>Start a new subpath or move the path starting point.</p>
<p>If no path elements have been added yet, this will change the path starting
point. If path elements have been added, this will insert an implicit close in
order to start a new subpath.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the (sub)path starting point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the (sub)path starting point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.quadratic_curve_relative"><code class="name flex">
<span>def <span class="ident">quadratic_curve_relative</span></span>(<span>self, dx1, dy1, dx2, dy2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3835-L3855" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def quadratic_curve_relative(self, dx1, dy1, dx2, dy2):
    &#34;&#34;&#34;
    Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.

    Args:
        dx1 (Number): abscissa of the control point relative to the end point of
            the previous path element
        dy1 (Number): ordinate of the control point relative to the end point of
            the previous path element
        dx2 (Number): abscissa offset of the end point relative to the end point of
            the previous path element
        dy2 (Number): ordinate offset of the end point relative to the end point of
            the previous path element

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    ctrl = Point(dx1, dy1)
    end = Point(dx2, dy2)
    self.add_path_element(RelativeQuadraticBezierCurve(ctrl, end), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dx1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the control point relative to the end point of
the previous path element</dd>
<dt><strong><code>dy1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the control point relative to the end point of
the previous path element</dd>
<dt><strong><code>dx2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa offset of the end point relative to the end point of
the previous path element</dd>
<dt><strong><code>dy2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate offset of the end point relative to the end point of
the previous path element</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.quadratic_curve_to"><code class="name flex">
<span>def <span class="ident">quadratic_curve_to</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3817-L3833" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def quadratic_curve_to(self, x1, y1, x2, y2):
    &#34;&#34;&#34;
    Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.

    Args:
        x1 (Number): abscissa of the control point
        y1 (Number): ordinate of the control point
        x2 (Number): abscissa of the end point
        y2 (Number): ordinate of the end point

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    ctrl = Point(x1, y1)
    end = Point(x2, y2)
    self.add_path_element(QuadraticBezierCurve(ctrl, end), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the control point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the control point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the end point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the end point</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.rectangle"><code class="name flex">
<span>def <span class="ident">rectangle</span></span>(<span>self, x, y, w, h, rx=0, ry=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3561-L3591" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def rectangle(self, x, y, w, h, rx=0, ry=0):
    &#34;&#34;&#34;
    Append a rectangle as a closed subpath to the current path.

    If the width or the height are 0, the rectangle will be collapsed to a line
    (unless they&#39;re both 0, in which case it&#39;s collapsed to nothing).

    Args:
        x (Number): the abscissa of the starting corner of the rectangle.
        y (Number): the ordinate of the starting corner of the rectangle.
        w (Number): the width of the rectangle (if 0, the rectangle will be
            rendered as a vertical line).
        h (Number): the height of the rectangle (if 0, the rectangle will be
            rendered as a horizontal line).
        rx (Number): the x-radius of the rectangle rounded corner (if 0 the corners
            will not be rounded).
        ry (Number): the y-radius of the rectangle rounded corner (if 0 the corners
            will not be rounded).

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;

    self._insert_implicit_close_if_open()
    self.add_path_element(
        RoundedRectangle(Point(x, y), Point(w, h), Point(rx, ry)), _copy=False
    )
    self._closed = True
    self.move_to(x, y)

    return self</code></pre>
</details>
<div class="desc"><p>Append a rectangle as a closed subpath to the current path.</p>
<p>If the width or the height are 0, the rectangle will be collapsed to a line
(unless they're both 0, in which case it's collapsed to nothing).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>the abscissa of the starting corner of the rectangle.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>the ordinate of the starting corner of the rectangle.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>Number</code></dt>
<dd>the width of the rectangle (if 0, the rectangle will be
rendered as a vertical line).</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>Number</code></dt>
<dd>the height of the rectangle (if 0, the rectangle will be
rendered as a horizontal line).</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the x-radius of the rectangle rounded corner (if 0 the corners
will not be rounded).</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>the y-radius of the rectangle rounded corner (if 0 the corners
will not be rounded).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.remove_last_path_element"><code class="name flex">
<span>def <span class="ident">remove_last_path_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3558-L3559" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def remove_last_path_element(self):
    self._graphics_context.remove_last_item()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4018-L4039" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry,
    style,
    last_item,
    initial_point,
    debug_stream=None,
    pfx=None,
):
    self._insert_implicit_close_if_open()

    (
        render_list,
        last_item,
        initial_point,
    ) = self._root_graphics_context.build_render_list(
        resource_registry, style, last_item, initial_point, debug_stream, pfx
    )

    paint_rule = GraphicsStyle.merge(style, self.style).resolve_paint_rule()
    render_list.insert(-1, paint_rule.value)
    return &#34; &#34;.join(render_list), last_item, initial_point</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L4041-L4065" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `PaintedPath.render`.
    &#34;&#34;&#34;
    return self.render(
        resource_registry, style, last_item, initial_point, debug_stream, pfx
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.PaintedPath.render" href="#fpdf.drawing.PaintedPath.render">PaintedPath.render()</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self,<br>x: float,<br>y: float,<br>content: str,<br>*,<br>font_family: str = 'helvetica',<br>font_style: str = '',<br>font_size: float = 12.0,<br>text_anchor: str = 'start')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3954-L3994" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def text(
    self,
    x: float,
    y: float,
    content: str,
    *,
    font_family: str = &#34;helvetica&#34;,
    font_style: str = &#34;&#34;,  # &#34;&#34;, &#34;B&#34;, &#34;I&#34;, &#34;BI&#34;
    font_size: float = 12.0,
    text_anchor: str = &#34;start&#34;,  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;
):
    &#34;&#34;&#34;
    Append a text run at (x, y) to this path.

    The baseline is at (x, y). `text_anchor` controls alignment about x.
    `font_style` accepts &#34;&#34;, &#34;B&#34;, &#34;I&#34;, or &#34;BI&#34;. `font_family` can be a single
    name or a comma-separated fallback list (handled at render-time).

    Returns:
        self (to allow chaining)
    &#34;&#34;&#34;
    # Normalize style just in case e.g. &#34;ib&#34; -&gt; &#34;BI&#34;
    s = &#34;&#34;.join(sorted(font_style.upper()))

    self.add_path_element(
        Text(
            x=x,
            y=y,
            text_runs=(
                TextRun(
                    text=content,
                    family=font_family,
                    emphasis=s,
                    size=font_size,
                ),
            ),
            text_anchor=text_anchor,
        ),
        _copy=False,
    )
    return self</code></pre>
</details>
<div class="desc"><p>Append a text run at (x, y) to this path.</p>
<p>The baseline is at (x, y). <code>text_anchor</code> controls alignment about x.
<code>font_style</code> accepts "", "B", "I", or "BI". <code>font_family</code> can be a single
name or a comma-separated fallback list (handled at render-time).</p>
<h2 id="returns">Returns</h2>
<p>self (to allow chaining)</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.transform_group"><code class="name flex">
<span>def <span class="ident">transform_group</span></span>(<span>self, transform)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3530-L3537" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@contextmanager
def transform_group(self, transform):
    &#34;&#34;&#34;
    Apply the provided `Transform` to all points added within this context.
    &#34;&#34;&#34;
    with self._new_graphics_context() as ctxt:
        ctxt.transform = transform
        yield self</code></pre>
</details>
<div class="desc"><p>Apply the provided <code>Transform</code> to all points added within this context.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.vertical_line_relative"><code class="name flex">
<span>def <span class="ident">vertical_line_relative</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3745-L3759" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def vertical_line_relative(self, dy):
    &#34;&#34;&#34;
    Append a straight vertical line to the given offset from the previous path
    element. The abscissa is retrieved from the end point of the previous path
    element.

    Args:
        y (Number): ordinate of the line&#39;s end point relative to the end point of
            the previous path element.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self.add_path_element(RelativeVerticalLine(dy), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a straight vertical line to the given offset from the previous path
element. The abscissa is retrieved from the end point of the previous path
element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point relative to the end point of
the previous path element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.vertical_line_to"><code class="name flex">
<span>def <span class="ident">vertical_line_to</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3731-L3743" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def vertical_line_to(self, y):
    &#34;&#34;&#34;
    Append a straight vertical line to the given ordinate. The abscissa is
    retrieved from the end point of the previous path element.

    Args:
        y (Number): ordinate of the line&#39;s end point.

    Returns:
        The path, to allow chaining method calls.
    &#34;&#34;&#34;
    self.add_path_element(VerticalLine(y), _copy=False)
    return self</code></pre>
</details>
<div class="desc"><p>Append a straight vertical line to the given ordinate. The abscissa is
retrieved from the end point of the previous path element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.PathPen"><code class="flex name class">
<span>class <span class="ident">PathPen</span></span>
<span>(</span><span>pdf_path, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5218-L5270" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class PathPen(BasePen):
    def __init__(self, pdf_path, *args, **kwargs):
        self.pdf_path = pdf_path
        self.last_was_line_to = False
        self.first_is_move = None
        super().__init__(*args, **kwargs)

    def _moveTo(self, pt):
        self.pdf_path.move_to(*pt)
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = True

    def _lineTo(self, pt):
        self.pdf_path.line_to(*pt)
        self.last_was_line_to = True
        if self.first_is_move is None:
            self.first_is_move = False

    def _curveToOne(self, pt1, pt2, pt3):
        self.pdf_path.curve_to(
            x1=pt1[0], y1=pt1[1], x2=pt2[0], y2=pt2[1], x3=pt3[0], y3=pt3[1]
        )
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = False

    def _qCurveToOne(self, pt1, pt2):
        self.pdf_path.quadratic_curve_to(x1=pt1[0], y1=pt1[1], x2=pt2[0], y2=pt2[1])
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = False

    def arcTo(self, rx, ry, rotation, arc, sweep, end):
        self.pdf_path.arc_to(
            rx=rx,
            ry=ry,
            rotation=rotation,
            large_arc=arc,
            positive_sweep=sweep,
            x=end[0],
            y=end[1],
        )
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = False

    def _closePath(self):
        # The fonttools parser inserts an unnecessary explicit line back to the start
        # point of the path before actually closing it. Let&#39;s get rid of that again.
        if self.last_was_line_to:
            self.pdf_path.remove_last_path_element()
        self.pdf_path.close()</code></pre>
</details>
<div class="desc"><p>Base class for drawing pens. You must override _moveTo, _lineTo and
_curveToOne. You may additionally override _closePath, _endPath,
addComponent, addVarComponent, and/or _qCurveToOne. You should not
override any other methods.</p>
<p>Takes a 'glyphSet' argument (dict), in which the glyphs that are referenced
as components are looked up by their name.</p>
<p>If the optional 'reverseFlipped' argument is True, components whose transformation
matrix has a negative determinant will be decomposed with a reversed path direction
to compensate for the flip.</p>
<p>The optional 'skipMissingComponents' argument can be set to True/False to
override the homonymous class attribute for a given pen instance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fontTools.pens.basePen.BasePen</li>
<li>fontTools.pens.basePen.DecomposingPen</li>
<li>fontTools.pens.basePen.LoggingPen</li>
<li>fontTools.misc.loggingTools.LogMixin</li>
<li>fontTools.pens.basePen.AbstractPen</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.drawing.GlyphPathPen" href="#fpdf.drawing.GlyphPathPen">GlyphPathPen</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.PathPen.arcTo"><code class="name flex">
<span>def <span class="ident">arcTo</span></span>(<span>self, rx, ry, rotation, arc, sweep, end)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L5251-L5263" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def arcTo(self, rx, ry, rotation, arc, sweep, end):
    self.pdf_path.arc_to(
        rx=rx,
        ry=ry,
        rotation=rotation,
        large_arc=arc,
        positive_sweep=sweep,
        x=end[0],
        y=end[1],
    )
    self.last_was_line_to = False
    if self.first_is_move is None:
        self.first_is_move = False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve"><code class="flex name class">
<span>class <span class="ident">QuadraticBezierCurve</span></span>
<span>(</span><span>ctrl: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>end: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1876-L1976" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class QuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, one off-curve control point, and an end point.

    See: `PaintedPath.quadratic_curve_to`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def to_cubic_curve(self, start_point: Point) -&gt; BezierCurve:
        ctrl = self.ctrl
        end = self.end

        ctrl1 = Point(
            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,
            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,
        )
        ctrl2 = Point(
            x=end.x + 2 * (ctrl.x - end.x) / 3,
            y=end.y + 2 * (ctrl.y - end.y) / 3,
        )

        return BezierCurve(ctrl1, ctrl2, end)

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.&#34;&#34;&#34;
        cubic = self.to_cubic_curve(start)
        return cubic.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.
        &#34;&#34;&#34;
        return (
            self.to_cubic_curve(last_item.end_point).render(
                resource_registry, style, last_item, initial_point
            )[0],
            self,
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `QuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {self.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A quadratic Bézier curve path element.</p>
<p>This draws a Bézier curve parameterized by the end point of the previous path
element, one off-curve control point, and an end point.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.quadratic_curve_to" href="#fpdf.drawing.PaintedPath.quadratic_curve_to">PaintedPath.quadratic_curve_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.QuadraticBezierCurve.ctrl"><code class="name">var <span class="ident">ctrl</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1876-L1976" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class QuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, one off-curve control point, and an end point.

    See: `PaintedPath.quadratic_curve_to`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def to_cubic_curve(self, start_point: Point) -&gt; BezierCurve:
        ctrl = self.ctrl
        end = self.end

        ctrl1 = Point(
            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,
            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,
        )
        ctrl2 = Point(
            x=end.x + 2 * (ctrl.x - end.x) / 3,
            y=end.y + 2 * (ctrl.y - end.y) / 3,
        )

        return BezierCurve(ctrl1, ctrl2, end)

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.&#34;&#34;&#34;
        cubic = self.to_cubic_curve(start)
        return cubic.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.
        &#34;&#34;&#34;
        return (
            self.to_cubic_curve(last_item.end_point).render(
                resource_registry, style, last_item, initial_point
            )[0],
            self,
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `QuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {self.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's control point.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1876-L1976" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class QuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, one off-curve control point, and an end point.

    See: `PaintedPath.quadratic_curve_to`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self) -&gt; Point:
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def to_cubic_curve(self, start_point: Point) -&gt; BezierCurve:
        ctrl = self.ctrl
        end = self.end

        ctrl1 = Point(
            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,
            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,
        )
        ctrl2 = Point(
            x=end.x + 2 * (ctrl.x - end.x) / 3,
            y=end.y + 2 * (ctrl.y - end.y) / 3,
        )

        return BezierCurve(ctrl1, ctrl2, end)

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.&#34;&#34;&#34;
        cubic = self.to_cubic_curve(start)
        return cubic.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.
        &#34;&#34;&#34;
        return (
            self.to_cubic_curve(last_item.end_point).render(
                resource_registry, style, last_item, initial_point
            )[0],
            self,
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `QuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {self.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's end point.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.end_point"><code class="name">prop <span class="ident">end_point</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1891-L1894" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@property
def end_point(self) -&gt; Point:
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.end</code></pre>
</details>
<div class="desc"><p>The end point of this path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.QuadraticBezierCurve.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1911-L1914" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.&#34;&#34;&#34;
    cubic = self.to_cubic_curve(start)
    return cubic.bounding_box(start)</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this quadratic Bézier curve by converting it to a cubic Bézier.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1916-L1943" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.
    &#34;&#34;&#34;
    return (
        self.to_cubic_curve(last_item.end_point).render(
            resource_registry, style, last_item, initial_point
        )[0],
        self,
        initial_point,
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is <code>self</code>.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1945-L1976" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `QuadraticBezierCurve.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(
        f&#34;{self} resolved to {self.to_cubic_curve(last_item.end_point)}\n&#34;
    )

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.QuadraticBezierCurve.render" href="#fpdf.drawing.QuadraticBezierCurve.render">QuadraticBezierCurve.render()</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.to_cubic_curve"><code class="name flex">
<span>def <span class="ident">to_cubic_curve</span></span>(<span>self,<br>start_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> <a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1896-L1909" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def to_cubic_curve(self, start_point: Point) -&gt; BezierCurve:
    ctrl = self.ctrl
    end = self.end

    ctrl1 = Point(
        x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,
        y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,
    )
    ctrl2 = Point(
        x=end.x + 2 * (ctrl.x - end.x) / 3,
        y=end.y + 2 * (ctrl.y - end.y) / 3,
    )

    return BezierCurve(ctrl1, ctrl2, end)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Rectangle"><code class="flex name class">
<span>class <span class="ident">Rectangle</span></span>
<span>(</span><span>org: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>size: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2407-L2489" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Rectangle(NamedTuple):
    &#34;&#34;&#34;A pdf primitive rectangle.&#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;

    # pylint: disable=unused-argument
    def bounding_box(self, start=None) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this rectangle.&#34;&#34;&#34;
        x0, y0 = self.org.x, self.org.y
        x1 = float(x0) + float(self.size.x)
        y1 = float(y0) + float(self.size.y)

        bbox = BoundingBox.from_points(
            [
                Point(x0, y0),
                Point(x1, y0),
                Point(x0, y1),
                Point(x1, y1),
            ]
        )
        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to
            the rectangle&#39;s origin.
        &#34;&#34;&#34;

        return (
            f&#34;{self.org.render()} {self.size.render()} re&#34;,
            Line(self.org),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Rectangle.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A pdf primitive rectangle.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Rectangle.org"><code class="name">var <span class="ident">org</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2407-L2489" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Rectangle(NamedTuple):
    &#34;&#34;&#34;A pdf primitive rectangle.&#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;

    # pylint: disable=unused-argument
    def bounding_box(self, start=None) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this rectangle.&#34;&#34;&#34;
        x0, y0 = self.org.x, self.org.y
        x1 = float(x0) + float(self.size.x)
        y1 = float(y0) + float(self.size.y)

        bbox = BoundingBox.from_points(
            [
                Point(x0, y0),
                Point(x1, y0),
                Point(x0, y1),
                Point(x1, y1),
            ]
        )
        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to
            the rectangle&#39;s origin.
        &#34;&#34;&#34;

        return (
            f&#34;{self.org.render()} {self.size.render()} re&#34;,
            Line(self.org),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Rectangle.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The top-left corner of the rectangle.</p></div>
</dd>
<dt id="fpdf.drawing.Rectangle.size"><code class="name">var <span class="ident">size</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2407-L2489" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Rectangle(NamedTuple):
    &#34;&#34;&#34;A pdf primitive rectangle.&#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;

    # pylint: disable=unused-argument
    def bounding_box(self, start=None) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this rectangle.&#34;&#34;&#34;
        x0, y0 = self.org.x, self.org.y
        x1 = float(x0) + float(self.size.x)
        y1 = float(y0) + float(self.size.y)

        bbox = BoundingBox.from_points(
            [
                Point(x0, y0),
                Point(x1, y0),
                Point(x0, y1),
                Point(x1, y1),
            ]
        )
        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to
            the rectangle&#39;s origin.
        &#34;&#34;&#34;

        return (
            f&#34;{self.org.render()} {self.size.render()} re&#34;,
            Line(self.org),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Rectangle.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The width and height of the rectangle.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Rectangle.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self, start=None) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2416-L2430" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start=None) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this rectangle.&#34;&#34;&#34;
    x0, y0 = self.org.x, self.org.y
    x1 = float(x0) + float(self.size.x)
    y1 = float(y0) + float(self.size.y)

    bbox = BoundingBox.from_points(
        [
            Point(x0, y0),
            Point(x1, y0),
            Point(x0, y1),
            Point(x1, y1),
        ]
    )
    return bbox, self.org</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this rectangle.</p></div>
</dd>
<dt id="fpdf.drawing.Rectangle.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2432-L2459" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to
        the rectangle&#39;s origin.
    &#34;&#34;&#34;

    return (
        f&#34;{self.org.render()} {self.size.render()} re&#34;,
        Line(self.org),
        initial_point,
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is a <code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code> back to
the rectangle's origin.</p></div>
</dd>
<dt id="fpdf.drawing.Rectangle.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2461-L2489" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `Rectangle.render`.
    &#34;&#34;&#34;
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.Rectangle.render" href="#fpdf.drawing.Rectangle.render">Rectangle.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeArc"><code class="flex name class">
<span>class <span class="ident">RelativeArc</span></span>
<span>(</span><span>radii: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>rotation: int | float | decimal.Decimal,<br>large: bool,<br>sweep: bool,<br>end: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2305-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
        end_point = start + self.end
        arc = Arc(
            radii=self.radii,
            rotation=self.rotation,
            large=self.large,
            sweep=self.sweep,
            end=end_point,
        )
        return arc.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>An elliptical arc path element.</p>
<p>The arc is drawn from the end of the current path element to its specified end point
using a number of parameters to determine how it is constructed.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.arc_relative" href="#fpdf.drawing.PaintedPath.arc_relative">PaintedPath.arc_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeArc.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2305-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
        end_point = start + self.end
        arc = Arc(
            radii=self.radii,
            rotation=self.rotation,
            large=self.large,
            sweep=self.sweep,
            end=end_point,
        )
        return arc.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>The end point of the arc relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.large"><code class="name">var <span class="ident">large</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2305-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
        end_point = start + self.end
        arc = Arc(
            radii=self.radii,
            rotation=self.rotation,
            large=self.large,
            sweep=self.sweep,
            end=end_point,
        )
        return arc.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>If True, sweep the arc over an angle greater than or equal to 180 degrees.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.radii"><code class="name">var <span class="ident">radii</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2305-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
        end_point = start + self.end
        arc = Arc(
            radii=self.radii,
            rotation=self.rotation,
            large=self.large,
            sweep=self.sweep,
            end=end_point,
        )
        return arc.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>The x- and y-radii of the arc. If <code>radii.x == radii.y</code> the arc will be circular.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.rotation"><code class="name">var <span class="ident">rotation</span> : int | float | decimal.Decimal</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2305-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
        end_point = start + self.end
        arc = Arc(
            radii=self.radii,
            rotation=self.rotation,
            large=self.large,
            sweep=self.sweep,
            end=end_point,
        )
        return arc.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>The rotation of the arc's major/minor axes relative to the coordinate frame.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.sweep"><code class="name">var <span class="ident">sweep</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2305-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
        end_point = start + self.end
        arc = Arc(
            radii=self.radii,
            rotation=self.rotation,
            large=self.large,
            sweep=self.sweep,
            end=end_point,
        )
        return arc.bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(
            resource_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<div class="desc"><p>If True, the arc is swept in the positive angular direction.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeArc.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2328-L2338" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of the resolved arc from the given start point.&#34;&#34;&#34;
    end_point = start + self.end
    arc = Arc(
        radii=self.radii,
        rotation=self.rotation,
        large=self.large,
        sweep=self.sweep,
        end=end_point,
    )
    return arc.bounding_box(start)</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of the resolved arc from the given start point.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2340-L2368" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
        `BezierCurve`.
    &#34;&#34;&#34;
    return Arc(
        self.radii,
        self.rotation,
        self.large,
        self.sweep,
        last_item.end_point + self.end,
    ).render(resource_registry, style, last_item, initial_point)</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is a resolved
<code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2370-L2404" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeArc.render`.
    &#34;&#34;&#34;
    # newline is intentionally missing here
    debug_stream.write(f&#34;{self} resolved to &#34;)

    return Arc(
        self.radii,
        self.rotation,
        self.large,
        self.sweep,
        last_item.end_point + self.end,
    ).render_debug(
        resource_registry, style, last_item, initial_point, debug_stream, pfx
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeArc.render" href="#fpdf.drawing.RelativeArc.render">RelativeArc.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve"><code class="flex name class">
<span>class <span class="ident">RelativeBezierCurve</span></span>
<span>(</span><span>c1: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>c2: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>end: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1757-L1873" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.curve_relative`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;
    The curve&#39;s first control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;
    The curve&#39;s second control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this relative cubic Bézier curve.

        Args:
            start (Point): The starting point of the curve (i.e., the end of the previous path element).

        Returns:
            A tuple containing:
                - BoundingBox: the axis-aligned bounding box containing the entire curve.
                - Point: the end point of the curve.
        &#34;&#34;&#34;
        # Resolve absolute coordinates
        p0 = start
        p1 = start + self.c1
        p2 = start + self.c2
        p3 = start + self.end

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)

        xs = [
            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))
            for t in tx
        ]
        ys = [
            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))
            for t in ty
        ]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, p3

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        last_point = last_item.end_point

        c1 = last_point + self.c1
        c2 = last_point + self.c2
        end = last_point + self.end

        return (
            _render_curve(c1, c2, end),
            BezierCurve(c1=c1, c2=c2, end=end),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A cubic Bézier curve path element whose points are specified relative to the end
point of the previous path element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.curve_relative" href="#fpdf.drawing.PaintedPath.curve_relative">PaintedPath.curve_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeBezierCurve.c1"><code class="name">var <span class="ident">c1</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1757-L1873" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.curve_relative`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;
    The curve&#39;s first control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;
    The curve&#39;s second control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this relative cubic Bézier curve.

        Args:
            start (Point): The starting point of the curve (i.e., the end of the previous path element).

        Returns:
            A tuple containing:
                - BoundingBox: the axis-aligned bounding box containing the entire curve.
                - Point: the end point of the curve.
        &#34;&#34;&#34;
        # Resolve absolute coordinates
        p0 = start
        p1 = start + self.c1
        p2 = start + self.c2
        p3 = start + self.end

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)

        xs = [
            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))
            for t in tx
        ]
        ys = [
            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))
            for t in ty
        ]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, p3

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        last_point = last_item.end_point

        c1 = last_point + self.c1
        c2 = last_point + self.c2
        end = last_point + self.end

        return (
            _render_curve(c1, c2, end),
            BezierCurve(c1=c1, c2=c2, end=end),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's first control point relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve.c2"><code class="name">var <span class="ident">c2</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1757-L1873" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.curve_relative`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;
    The curve&#39;s first control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;
    The curve&#39;s second control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this relative cubic Bézier curve.

        Args:
            start (Point): The starting point of the curve (i.e., the end of the previous path element).

        Returns:
            A tuple containing:
                - BoundingBox: the axis-aligned bounding box containing the entire curve.
                - Point: the end point of the curve.
        &#34;&#34;&#34;
        # Resolve absolute coordinates
        p0 = start
        p1 = start + self.c1
        p2 = start + self.c2
        p3 = start + self.end

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)

        xs = [
            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))
            for t in tx
        ]
        ys = [
            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))
            for t in ty
        ]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, p3

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        last_point = last_item.end_point

        c1 = last_point + self.c1
        c2 = last_point + self.c2
        end = last_point + self.end

        return (
            _render_curve(c1, c2, end),
            BezierCurve(c1=c1, c2=c2, end=end),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's second control point relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1757-L1873" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.curve_relative`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;
    The curve&#39;s first control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;
    The curve&#39;s second control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this relative cubic Bézier curve.

        Args:
            start (Point): The starting point of the curve (i.e., the end of the previous path element).

        Returns:
            A tuple containing:
                - BoundingBox: the axis-aligned bounding box containing the entire curve.
                - Point: the end point of the curve.
        &#34;&#34;&#34;
        # Resolve absolute coordinates
        p0 = start
        p1 = start + self.c1
        p2 = start + self.c2
        p3 = start + self.end

        tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)
        ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)

        xs = [
            _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))
            for t in tx
        ]
        ys = [
            _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))
            for t in ty
        ]

        bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
        return bbox, p3

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        last_point = last_item.end_point

        c1 = last_point + self.c1
        c2 = last_point + self.c2
        end = last_point + self.end

        return (
            _render_curve(c1, c2, end),
            BezierCurve(c1=c1, c2=c2, end=end),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's end point relative to the end of the previous path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeBezierCurve.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1776-L1807" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;
    Compute the bounding box of this relative cubic Bézier curve.

    Args:
        start (Point): The starting point of the curve (i.e., the end of the previous path element).

    Returns:
        A tuple containing:
            - BoundingBox: the axis-aligned bounding box containing the entire curve.
            - Point: the end point of the curve.
    &#34;&#34;&#34;
    # Resolve absolute coordinates
    p0 = start
    p1 = start + self.c1
    p2 = start + self.c2
    p3 = start + self.end

    tx = [0, 1] + _cubic_bezier_critical_ts_1d(p0.x, p1.x, p2.x, p3.x)
    ty = [0, 1] + _cubic_bezier_critical_ts_1d(p0.y, p1.y, p2.y, p3.y)

    xs = [
        _eval_cubic_bezier_1d(t, float(p0.x), float(p1.x), float(p2.x), float(p3.x))
        for t in tx
    ]
    ys = [
        _eval_cubic_bezier_1d(t, float(p0.y), float(p1.y), float(p2.y), float(p3.y))
        for t in ty
    ]

    bbox = BoundingBox(min(xs), min(ys), max(xs), max(ys))
    return bbox, p3</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this relative cubic Bézier curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>Point</code></dt>
<dd>The starting point of the curve (i.e., the end of the previous path element).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple containing:
- BoundingBox: the axis-aligned bounding box containing the entire curve.
- Point: the end point of the curve.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1809-L1842" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `BezierCurve`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    last_point = last_item.end_point

    c1 = last_point + self.c1
    c2 = last_point + self.c2
    end = last_point + self.end

    return (
        _render_curve(c1, c2, end),
        BezierCurve(c1=c1, c2=c2, end=end),
        initial_point,
    )</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1844-L1873" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeBezierCurve.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeBezierCurve.render" href="#fpdf.drawing.RelativeBezierCurve.render">RelativeBezierCurve.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeHorizontalLine"><code class="flex name class">
<span>class <span class="ident">RelativeHorizontalLine</span></span>
<span>(</span><span>x: int | float | decimal.Decimal)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1397-L1472" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeHorizontalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its ordinate from the end of the previous element and
    computes its abscissa offset from the end of that element.

    See: `PaintedPath.horizontal_line_relative`
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;
    The abscissa of the horizontal line&#39;s end point relative to the abscissa of the
    previous path element.
    &#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a relative horizontal line.&#34;&#34;&#34;
        end = Point(float(start.x) + float(self.x), start.y)
        bbox = BoundingBox.from_points([start, end])
        return bbox, end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x + self.x, y=last_item.end_point.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeHorizontalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path line element that takes its ordinate from the end of the previous element and
computes its abscissa offset from the end of that element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.horizontal_line_relative" href="#fpdf.drawing.PaintedPath.horizontal_line_relative">PaintedPath.horizontal_line_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeHorizontalLine.x"><code class="name">var <span class="ident">x</span> : int | float | decimal.Decimal</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1397-L1472" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeHorizontalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its ordinate from the end of the previous element and
    computes its abscissa offset from the end of that element.

    See: `PaintedPath.horizontal_line_relative`
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;
    The abscissa of the horizontal line&#39;s end point relative to the abscissa of the
    previous path element.
    &#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a relative horizontal line.&#34;&#34;&#34;
        end = Point(float(start.x) + float(self.x), start.y)
        bbox = BoundingBox.from_points([start, end])
        return bbox, end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x + self.x, y=last_item.end_point.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeHorizontalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The abscissa of the horizontal line's end point relative to the abscissa of the
previous path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeHorizontalLine.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1411-L1415" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of a relative horizontal line.&#34;&#34;&#34;
    end = Point(float(start.x) + float(self.x), start.y)
    bbox = BoundingBox.from_points([start, end])
    return bbox, end</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of a relative horizontal line.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeHorizontalLine.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1417-L1441" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `Line`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    end_point = Point(x=last_item.end_point.x + self.x, y=last_item.end_point.y)
    return _render_line(end_point), Line(end_point), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeHorizontalLine.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1443-L1472" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeHorizontalLine.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeHorizontalLine.render" href="#fpdf.drawing.RelativeHorizontalLine.render">RelativeHorizontalLine.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeLine"><code class="flex name class">
<span>class <span class="ident">RelativeLine</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1248-L1321" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element with an endpoint relative to the end of the previous element.

    This draws a straight line from the end point of the previous path element to the
    point specified by `last_item.end_point + pt`. The absolute coordinates of the end
    point are resolved during the rendering process.

    See: `PaintedPath.line_relative`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The endpoint of the line relative to the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a relative line from the start point to the new end point.&#34;&#34;&#34;
        return BoundingBox.from_points([start, start + self.pt]), start + self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        point = last_item.end_point + self.pt
        return _render_line(point), Line(point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path line element with an endpoint relative to the end of the previous element.</p>
<p>This draws a straight line from the end point of the previous path element to the
point specified by <code>last_item.end_point + pt</code>. The absolute coordinates of the end
point are resolved during the rendering process.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.line_relative" href="#fpdf.drawing.PaintedPath.line_relative">PaintedPath.line_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeLine.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1248-L1321" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element with an endpoint relative to the end of the previous element.

    This draws a straight line from the end point of the previous path element to the
    point specified by `last_item.end_point + pt`. The absolute coordinates of the end
    point are resolved during the rendering process.

    See: `PaintedPath.line_relative`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The endpoint of the line relative to the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of a relative line from the start point to the new end point.&#34;&#34;&#34;
        return BoundingBox.from_points([start, start + self.pt]), start + self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        point = last_item.end_point + self.pt
        return _render_line(point), Line(point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The endpoint of the line relative to the previous path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeLine.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1262-L1264" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of a relative line from the start point to the new end point.&#34;&#34;&#34;
    return BoundingBox.from_points([start, start + self.pt]), start + self.pt</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of a relative line from the start point to the new end point.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeLine.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1266-L1290" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `Line`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    point = last_item.end_point + self.pt
    return _render_line(point), Line(point), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeLine.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1292-L1321" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeLine.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeLine.render" href="#fpdf.drawing.RelativeLine.render">RelativeLine.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeMove"><code class="flex name class">
<span>class <span class="ident">RelativeMove</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1095-L1167" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeMove(NamedTuple):
    &#34;&#34;&#34;
    A path move element with an end point relative to the end of the previous path
    element.

    If a path has been created but not yet painted, this will create a new subpath.

    See: `PaintedPath.move_relative`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The offset by which to move.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;RelativeMove doesn&#39;t draw anything, so it has no bounding box.&#34;&#34;&#34;
        return BoundingBox.empty(), start + self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Move`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        point = last_item.end_point + self.pt
        return _render_move(point), Move(point), point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeMove.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path move element with an end point relative to the end of the previous path
element.</p>
<p>If a path has been created but not yet painted, this will create a new subpath.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.move_relative" href="#fpdf.drawing.PaintedPath.move_relative">PaintedPath.move_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeMove.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1095-L1167" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeMove(NamedTuple):
    &#34;&#34;&#34;
    A path move element with an end point relative to the end of the previous path
    element.

    If a path has been created but not yet painted, this will create a new subpath.

    See: `PaintedPath.move_relative`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The offset by which to move.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;RelativeMove doesn&#39;t draw anything, so it has no bounding box.&#34;&#34;&#34;
        return BoundingBox.empty(), start + self.pt

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Move`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        point = last_item.end_point + self.pt
        return _render_move(point), Move(point), point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeMove.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The offset by which to move.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeMove.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1108-L1110" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;RelativeMove doesn&#39;t draw anything, so it has no bounding box.&#34;&#34;&#34;
    return BoundingBox.empty(), start + self.pt</code></pre>
</details>
<div class="desc"><p>RelativeMove doesn't draw anything, so it has no bounding box.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeMove.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1112-L1136" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `Move`
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    point = last_item.end_point + self.pt
    return _render_move(point), Move(point), point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.Move" href="#fpdf.drawing.Move">Move</a></code></p></div>
</dd>
<dt id="fpdf.drawing.RelativeMove.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1138-L1167" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeMove.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeMove.render" href="#fpdf.drawing.RelativeMove.render">RelativeMove.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve"><code class="flex name class">
<span>class <span class="ident">RelativeQuadraticBezierCurve</span></span>
<span>(</span><span>ctrl: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>end: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1979-L2060" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeQuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.quadratic_curve_relative`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point relative to the end of the previous path element.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this relative quadratic Bézier curve.&#34;&#34;&#34;
        ctrl = start + self.ctrl
        end = start + self.end
        return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `QuadraticBezierCurve`.
        &#34;&#34;&#34;
        last_point = last_item.end_point

        ctrl = last_point + self.ctrl
        end = last_point + self.end

        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)
        return absolute.render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeQuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {resolved} &#34;
            f&#34;then to {resolved.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A quadratic Bézier curve path element whose points are specified relative to the end
point of the previous path element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.quadratic_curve_relative" href="#fpdf.drawing.PaintedPath.quadratic_curve_relative">PaintedPath.quadratic_curve_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.ctrl"><code class="name">var <span class="ident">ctrl</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1979-L2060" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeQuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.quadratic_curve_relative`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point relative to the end of the previous path element.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this relative quadratic Bézier curve.&#34;&#34;&#34;
        ctrl = start + self.ctrl
        end = start + self.end
        return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `QuadraticBezierCurve`.
        &#34;&#34;&#34;
        last_point = last_item.end_point

        ctrl = last_point + self.ctrl
        end = last_point + self.end

        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)
        return absolute.render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeQuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {resolved} &#34;
            f&#34;then to {resolved.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's control point relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1979-L2060" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeQuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.quadratic_curve_relative`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point relative to the end of the previous path element.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this relative quadratic Bézier curve.&#34;&#34;&#34;
        ctrl = start + self.ctrl
        end = start + self.end
        return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `QuadraticBezierCurve`.
        &#34;&#34;&#34;
        last_point = last_item.end_point

        ctrl = last_point + self.ctrl
        end = last_point + self.end

        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)
        return absolute.render(resource_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeQuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {resolved} &#34;
            f&#34;then to {resolved.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The curve's end point relative to the end of the previous path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1992-L1996" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this relative quadratic Bézier curve.&#34;&#34;&#34;
    ctrl = start + self.ctrl
    end = start + self.end
    return QuadraticBezierCurve(ctrl=ctrl, end=end).bounding_box(start)</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this relative quadratic Bézier curve.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1998-L2026" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `QuadraticBezierCurve`.
    &#34;&#34;&#34;
    last_point = last_item.end_point

    ctrl = last_point + self.ctrl
    end = last_point + self.end

    absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)
    return absolute.render(resource_registry, style, last_item, initial_point)</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.QuadraticBezierCurve" href="#fpdf.drawing.QuadraticBezierCurve">QuadraticBezierCurve</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2028-L2060" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeQuadraticBezierCurve.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(
        f&#34;{self} resolved to {resolved} &#34;
        f&#34;then to {resolved.to_cubic_curve(last_item.end_point)}\n&#34;
    )

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.render" href="#fpdf.drawing.RelativeQuadraticBezierCurve.render">RelativeQuadraticBezierCurve.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeVerticalLine"><code class="flex name class">
<span>class <span class="ident">RelativeVerticalLine</span></span>
<span>(</span><span>y: int | float | decimal.Decimal)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1549-L1624" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeVerticalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its abscissa from the end of the previous element and
    computes its ordinate offset from the end of that element.

    See: `PaintedPath.vertical_line_relative`
    &#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;
    The ordinate of the vertical line&#39;s end point relative to the ordinate of the
    previous path element.
    &#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this relative vertical line.&#34;&#34;&#34;
        end = Point(start.x, float(start.y) + float(self.y))
        bbox = BoundingBox.from_points([start, end])
        return bbox, end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x, y=last_item.end_point.y + self.y)
        return _render_line(end_point), Line(end_point), initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeVerticalLine.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path line element that takes its abscissa from the end of the previous element and
computes its ordinate offset from the end of that element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.vertical_line_relative" href="#fpdf.drawing.PaintedPath.vertical_line_relative">PaintedPath.vertical_line_relative()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeVerticalLine.y"><code class="name">var <span class="ident">y</span> : int | float | decimal.Decimal</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1549-L1624" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RelativeVerticalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its abscissa from the end of the previous element and
    computes its ordinate offset from the end of that element.

    See: `PaintedPath.vertical_line_relative`
    &#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;
    The ordinate of the vertical line&#39;s end point relative to the ordinate of the
    previous path element.
    &#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this relative vertical line.&#34;&#34;&#34;
        end = Point(start.x, float(start.y) + float(self.y))
        bbox = BoundingBox.from_points([start, end])
        return bbox, end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x, y=last_item.end_point.y + self.y)
        return _render_line(end_point), Line(end_point), initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeVerticalLine.render`.
        &#34;&#34;&#34;
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The ordinate of the vertical line's end point relative to the ordinate of the
previous path element.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RelativeVerticalLine.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1563-L1567" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this relative vertical line.&#34;&#34;&#34;
    end = Point(start.x, float(start.y) + float(self.y))
    bbox = BoundingBox.from_points([start, end])
    return bbox, end</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this relative vertical line.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeVerticalLine.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1569-L1593" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `Line`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    end_point = Point(x=last_item.end_point.x, y=last_item.end_point.y + self.y)
    return _render_line(end_point), Line(end_point), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeVerticalLine.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1596-L1624" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RelativeVerticalLine.render`.
    &#34;&#34;&#34;
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RelativeVerticalLine.render" href="#fpdf.drawing.RelativeVerticalLine.render">RelativeVerticalLine.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Renderable"><code class="flex name class">
<span>class <span class="ident">Renderable</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L988-L1003" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@runtime_checkable
class Renderable(Protocol):
    &#34;&#34;&#34;
    Structural type for things that can render themselves into PDF operators
    and report a geometric bounding box.
    &#34;&#34;&#34;

    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: &#34;Renderable&#34;,
        initial_point: Point,
    ) -&gt; tuple[str, &#34;Renderable&#34;, Point]: ...

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]: ...</code></pre>
</details>
<div class="desc"><p>Structural type for things that can render themselves into PDF operators
and report a geometric bounding box.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Renderable.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1003-L1003" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.Renderable.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, '<a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>', <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L995-L1001" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: &#34;Renderable&#34;,
    initial_point: Point,
) -&gt; tuple[str, &#34;Renderable&#34;, Point]: ...</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RoundedRectangle"><code class="flex name class">
<span>class <span class="ident">RoundedRectangle</span></span>
<span>(</span><span>org: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>size: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>,<br>corner_radii: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2492-L2641" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RoundedRectangle(NamedTuple):
    &#34;&#34;&#34;
    A rectangle with rounded corners.

    See: `PaintedPath.rectangle`
    &#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;
    corner_radii: Point
    &#34;&#34;&#34;The x- and y-radius of the corners.&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        if (self.size.x == 0) and (self.size.y == 0):
            pass
        elif (self.size.x == 0) or (self.size.y == 0):
            items.append(Move(self.org))
            items.append(Line(self.org + self.size))
            items.append(Close())
        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):
            items.append(Rectangle(self.org, self.size))
        else:
            x, y = self.org
            w, h = self.size
            rx, ry = self.corner_radii
            sign_width = (self.size.x &gt;= 0) - (self.size.x &lt; 0)
            sign_height = (self.size.y &gt;= 0) - (self.size.y &lt; 0)

            if abs(rx) &gt; abs(w):
                rx = self.size.x

            if abs(ry) &gt; abs(h):
                ry = self.size.y

            rx = sign_width * abs(rx)
            ry = sign_height * abs(ry)
            arc_rad = Point(rx, ry)

            items.append(Move(Point(x + rx, y)))
            items.append(Line(Point(x + w - rx, y)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))
            items.append(Line(Point(x + w, y + h - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))
            items.append(Line(Point(x + rx, y + h)))
            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))
            items.append(Line(Point(x, y + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this rounded rectangle by decomposing into primitives
        and merging their individual bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Line`.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RoundedRectangle.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<div class="desc"><p>A rectangle with rounded corners.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.rectangle" href="#fpdf.drawing.PaintedPath.rectangle">PaintedPath.rectangle()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RoundedRectangle.corner_radii"><code class="name">var <span class="ident">corner_radii</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2492-L2641" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RoundedRectangle(NamedTuple):
    &#34;&#34;&#34;
    A rectangle with rounded corners.

    See: `PaintedPath.rectangle`
    &#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;
    corner_radii: Point
    &#34;&#34;&#34;The x- and y-radius of the corners.&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        if (self.size.x == 0) and (self.size.y == 0):
            pass
        elif (self.size.x == 0) or (self.size.y == 0):
            items.append(Move(self.org))
            items.append(Line(self.org + self.size))
            items.append(Close())
        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):
            items.append(Rectangle(self.org, self.size))
        else:
            x, y = self.org
            w, h = self.size
            rx, ry = self.corner_radii
            sign_width = (self.size.x &gt;= 0) - (self.size.x &lt; 0)
            sign_height = (self.size.y &gt;= 0) - (self.size.y &lt; 0)

            if abs(rx) &gt; abs(w):
                rx = self.size.x

            if abs(ry) &gt; abs(h):
                ry = self.size.y

            rx = sign_width * abs(rx)
            ry = sign_height * abs(ry)
            arc_rad = Point(rx, ry)

            items.append(Move(Point(x + rx, y)))
            items.append(Line(Point(x + w - rx, y)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))
            items.append(Line(Point(x + w, y + h - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))
            items.append(Line(Point(x + rx, y + h)))
            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))
            items.append(Line(Point(x, y + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this rounded rectangle by decomposing into primitives
        and merging their individual bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Line`.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RoundedRectangle.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<div class="desc"><p>The x- and y-radius of the corners.</p></div>
</dd>
<dt id="fpdf.drawing.RoundedRectangle.org"><code class="name">var <span class="ident">org</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2492-L2641" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RoundedRectangle(NamedTuple):
    &#34;&#34;&#34;
    A rectangle with rounded corners.

    See: `PaintedPath.rectangle`
    &#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;
    corner_radii: Point
    &#34;&#34;&#34;The x- and y-radius of the corners.&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        if (self.size.x == 0) and (self.size.y == 0):
            pass
        elif (self.size.x == 0) or (self.size.y == 0):
            items.append(Move(self.org))
            items.append(Line(self.org + self.size))
            items.append(Close())
        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):
            items.append(Rectangle(self.org, self.size))
        else:
            x, y = self.org
            w, h = self.size
            rx, ry = self.corner_radii
            sign_width = (self.size.x &gt;= 0) - (self.size.x &lt; 0)
            sign_height = (self.size.y &gt;= 0) - (self.size.y &lt; 0)

            if abs(rx) &gt; abs(w):
                rx = self.size.x

            if abs(ry) &gt; abs(h):
                ry = self.size.y

            rx = sign_width * abs(rx)
            ry = sign_height * abs(ry)
            arc_rad = Point(rx, ry)

            items.append(Move(Point(x + rx, y)))
            items.append(Line(Point(x + w - rx, y)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))
            items.append(Line(Point(x + w, y + h - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))
            items.append(Line(Point(x + rx, y + h)))
            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))
            items.append(Line(Point(x, y + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this rounded rectangle by decomposing into primitives
        and merging their individual bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Line`.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RoundedRectangle.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<div class="desc"><p>The top-left corner of the rectangle.</p></div>
</dd>
<dt id="fpdf.drawing.RoundedRectangle.size"><code class="name">var <span class="ident">size</span> : <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2492-L2641" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class RoundedRectangle(NamedTuple):
    &#34;&#34;&#34;
    A rectangle with rounded corners.

    See: `PaintedPath.rectangle`
    &#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;
    corner_radii: Point
    &#34;&#34;&#34;The x- and y-radius of the corners.&#34;&#34;&#34;

    def _decompose(self) -&gt; list[Renderable]:
        items = []

        if (self.size.x == 0) and (self.size.y == 0):
            pass
        elif (self.size.x == 0) or (self.size.y == 0):
            items.append(Move(self.org))
            items.append(Line(self.org + self.size))
            items.append(Close())
        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):
            items.append(Rectangle(self.org, self.size))
        else:
            x, y = self.org
            w, h = self.size
            rx, ry = self.corner_radii
            sign_width = (self.size.x &gt;= 0) - (self.size.x &lt; 0)
            sign_height = (self.size.y &gt;= 0) - (self.size.y &lt; 0)

            if abs(rx) &gt; abs(w):
                rx = self.size.x

            if abs(ry) &gt; abs(h):
                ry = self.size.y

            rx = sign_width * abs(rx)
            ry = sign_height * abs(ry)
            arc_rad = Point(rx, ry)

            items.append(Move(Point(x + rx, y)))
            items.append(Line(Point(x + w - rx, y)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))
            items.append(Line(Point(x + w, y + h - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))
            items.append(Line(Point(x + rx, y + h)))
            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))
            items.append(Line(Point(x, y + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))
            items.append(Close())

        return items

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;
        Compute the bounding box of this rounded rectangle by decomposing into primitives
        and merging their individual bounding boxes.
        &#34;&#34;&#34;
        bbox = BoundingBox.empty()
        current_point = start

        for item in self._decompose():
            b, current_point = item.bounding_box(current_point)
            bbox = bbox.merge(b)

        return bbox, self.org

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Line`.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RoundedRectangle.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item, initial_point

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                resource_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<div class="desc"><p>The width and height of the rectangle.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.RoundedRectangle.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2547-L2559" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;
    Compute the bounding box of this rounded rectangle by decomposing into primitives
    and merging their individual bounding boxes.
    &#34;&#34;&#34;
    bbox = BoundingBox.empty()
    current_point = start

    for item in self._decompose():
        b, current_point = item.bounding_box(current_point)
        bbox = bbox.merge(b)

    return bbox, self.org</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this rounded rectangle by decomposing into primitives
and merging their individual bounding boxes.</p></div>
</dd>
<dt id="fpdf.drawing.RoundedRectangle.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2561-L2595" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
        `Line`.
    &#34;&#34;&#34;
    components = self._decompose()

    if not components:
        return &#34;&#34;, last_item, initial_point

    render_list = []
    for item in components:
        rendered, last_item, initial_point = item.render(
            resource_registry, style, last_item, initial_point
        )
        render_list.append(rendered)

    return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is a resolved
<code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.RoundedRectangle.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2597-L2641" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `RoundedRectangle.render`.
    &#34;&#34;&#34;
    components = self._decompose()

    debug_stream.write(f&#34;{self} resolved to:\n&#34;)
    if not components:
        debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
        return &#34;&#34;, last_item, initial_point

    render_list = []
    for item in components[:-1]:
        rendered, last_item, initial_point = item.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
        render_list.append(rendered)

    rendered, last_item, initial_point = components[-1].render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
    render_list.append(rendered)

    return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.RoundedRectangle.render" href="#fpdf.drawing.RoundedRectangle.render">RoundedRectangle.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>x: float,<br>y: float,<br>text_runs: tuple[<a title="fpdf.drawing.TextRun" href="#fpdf.drawing.TextRun">TextRun</a>, ...],<br>text_anchor: str = 'start')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2787-L3035" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Text(NamedTuple):
    &#34;&#34;&#34;
    SVG-like text renderable.
    Stores the anchor position (x, y) and one or more TextRuns that include
    relative positioning offsets. Accurate glyph positioning is resolved
    during rendering once font metrics are available.
    &#34;&#34;&#34;

    x: float
    y: float
    text_runs: tuple[TextRun, ...]
    text_anchor: str = &#34;start&#34;  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;

    def _approximate_layout(self) -&gt; tuple[list[tuple[float, float, float]], float]:
        &#34;&#34;&#34;
        Produce an approximate layout for bounding-box estimation.

        Returns:
            A tuple of (per-run layout list, total width estimate).  Each layout
            entry is (x, y, width) in user space.
        &#34;&#34;&#34;
        positions: list[tuple[float, float, float]] = []
        pen_x = self.x
        pen_y = self.y
        max_right = pen_x
        min_left = pen_x

        for run in self.text_runs:
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            # Fallback width estimation: ~0.5em per glyph
            approx_width = 0.5 * run.size * max(0, len(run.text))
            positions.append((pen_x, pen_y, approx_width))
            min_left = min(min_left, pen_x)
            max_right = max(max_right, pen_x + approx_width)
            pen_x += approx_width

        total_width = max_right - min_left
        return positions, total_width

    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -&gt; float:
        &#34;&#34;&#34;Compute anchor offset for the provided approximate layout.&#34;&#34;&#34;
        if not positions:
            return 0.0

        if any(run.abs_x is not None for run in self.text_runs):
            return 0.0

        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] + pos[2] for pos in positions)

        if self.text_anchor == &#34;middle&#34;:
            return self.x - (min_x + max_x) / 2.0
        if self.text_anchor == &#34;end&#34;:
            return self.x - max_x
        return self.x - min_x

    def bounding_box(self, start: Point) -&gt; tuple[&#34;BoundingBox&#34;, Point]:
        &#34;&#34;&#34;
        Compute a conservative bbox for the text.

        Font metrics are not available at this stage so the layout relies on
        approximate glyph widths proportional to the run font size. The actual
        layout is computed precisely in render().
        &#34;&#34;&#34;
        if not self.text_runs:
            return BoundingBox.empty(), start

        positions, _ = self._approximate_layout()
        anchor_offset = self._anchor_offset(positions)

        min_x = float(&#34;inf&#34;)
        max_x = float(&#34;-inf&#34;)
        min_y = float(&#34;inf&#34;)
        max_y = float(&#34;-inf&#34;)

        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):
            adj_x = run_x + anchor_offset
            asc = 0.8 * run.size
            desc = 0.2 * run.size
            min_x = min(min_x, adj_x)
            max_x = max(max_x, adj_x + run_width)
            min_y = min(min_y, run_y - asc)
            max_y = max(max_y, run_y + desc)

        if min_x == float(&#34;inf&#34;):
            return BoundingBox.empty(), start

        x0 = min_x
        x1 = max_x
        y0 = min_y
        y1 = max_y

        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: &#34;GraphicsStyle&#34;,
        last_item: &#34;Renderable&#34;,
        initial_point: Point,
    ) -&gt; tuple[str, &#34;Renderable&#34;, Point]:
        &#34;&#34;&#34;
        Emit PDF text operators:

          BT
            &lt;font_id&gt; &lt;font_size&gt; Tf
            Tr &lt;mode&gt;               (map from GraphicsStyle-&gt;PathPaintRule)
            1 0 0 1 x y Tm
            (escaped-text) Tj
          ET
        &#34;&#34;&#34;
        if not self.text_runs:
            return &#34;&#34;, last_item, initial_point

        # Precise layout resolution with actual font metrics
        layout: list[tuple[float, float, float, TextRun, object]] = []
        pen_x = self.x
        pen_y = self.y
        min_x = pen_x
        max_x = pen_x

        for run in self.text_runs:
            font = resource_registry.get_font_from_family(run.family, run.emphasis)
            _, width = font.get_text_width(run.text, run.size, None)
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            min_x = min(min_x, pen_x)
            max_x = max(max_x, pen_x + width)
            layout.append((pen_x, pen_y, width, run, font))
            pen_x += width

        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)

        if layout and not has_absolute:
            if self.text_anchor == &#34;middle&#34;:
                anchor_offset = self.x - (min_x + max_x) / 2.0
            elif self.text_anchor == &#34;end&#34;:
                anchor_offset = self.x - max_x
            else:
                anchor_offset = self.x - min_x
        else:
            anchor_offset = 0.0

        ops: list[str] = []
        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)

        for run_x, run_y, width, run, font in layout:
            effective_style = (
                GraphicsStyle.merge(style, run.run_style)
                if run.run_style is not None
                else style
            )

            # Determine text rendering mode
            rule = effective_style.resolve_paint_rule()
            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):
                tr = 0
            elif rule is PathPaintRule.STROKE:
                tr = 1
            elif rule in (
                PathPaintRule.STROKE_FILL_NONZERO,
                PathPaintRule.STROKE_FILL_EVENODD,
            ):
                tr = 2
            else:  # PathPaintRule.DONT_PAINT:
                tr = 3

            run_ops: list[str] = []

            if run.run_style is not None:
                merged_style = effective_style
                style_dict_name = resource_registry.register_graphics_style(
                    merged_style
                )

                if style_dict_name is not None:
                    run_ops.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

                fill_color = merged_style.fill_color
                stroke_color = merged_style.stroke_color

                run_bbox = BoundingBox.from_points(
                    [
                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),
                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),
                    ]
                )

                if fill_color not in NO_EMIT_SET:
                    if isinstance(fill_color, GradientPaint):
                        run_ops.append(
                            fill_color.emit_fill(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(fill_color.serialize().lower())
                if stroke_color not in NO_EMIT_SET:
                    if isinstance(stroke_color, GradientPaint):
                        run_ops.append(
                            stroke_color.emit_stroke(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(stroke_color.serialize().upper())

                dash_pattern = merged_style.stroke_dash_pattern
                dash_phase = merged_style.stroke_dash_phase
                if dash_pattern not in NO_EMIT_SET:
                    run_ops.append(
                        render_pdf_primitive(dash_pattern)
                        + f&#34; {number_to_str(dash_phase)} d&#34;
                    )

            run_ops.extend(
                [
                    &#34;BT&#34;,
                    f&#34;/F{font.i} {number_to_str(run.size)} Tf&#34;,
                    f&#34;{number_to_str(tr)} Tr&#34;,
                    f&#34;1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm&#34;,
                    font.encode_text(run.text),
                    &#34;ET&#34;,
                ]
            )

            if run.run_style is not None:
                run_ops = [&#34;q&#34;] + run_ops + [&#34;Q&#34;]

            ops.extend(run_ops)

        return &#34; &#34;.join(ops), last_item, initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)
        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>SVG-like text renderable.
Stores the anchor position (x, y) and one or more TextRuns that include
relative positioning offsets. Accurate glyph positioning is resolved
during rendering once font metrics are available.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Text.text_anchor"><code class="name">var <span class="ident">text_anchor</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2787-L3035" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Text(NamedTuple):
    &#34;&#34;&#34;
    SVG-like text renderable.
    Stores the anchor position (x, y) and one or more TextRuns that include
    relative positioning offsets. Accurate glyph positioning is resolved
    during rendering once font metrics are available.
    &#34;&#34;&#34;

    x: float
    y: float
    text_runs: tuple[TextRun, ...]
    text_anchor: str = &#34;start&#34;  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;

    def _approximate_layout(self) -&gt; tuple[list[tuple[float, float, float]], float]:
        &#34;&#34;&#34;
        Produce an approximate layout for bounding-box estimation.

        Returns:
            A tuple of (per-run layout list, total width estimate).  Each layout
            entry is (x, y, width) in user space.
        &#34;&#34;&#34;
        positions: list[tuple[float, float, float]] = []
        pen_x = self.x
        pen_y = self.y
        max_right = pen_x
        min_left = pen_x

        for run in self.text_runs:
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            # Fallback width estimation: ~0.5em per glyph
            approx_width = 0.5 * run.size * max(0, len(run.text))
            positions.append((pen_x, pen_y, approx_width))
            min_left = min(min_left, pen_x)
            max_right = max(max_right, pen_x + approx_width)
            pen_x += approx_width

        total_width = max_right - min_left
        return positions, total_width

    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -&gt; float:
        &#34;&#34;&#34;Compute anchor offset for the provided approximate layout.&#34;&#34;&#34;
        if not positions:
            return 0.0

        if any(run.abs_x is not None for run in self.text_runs):
            return 0.0

        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] + pos[2] for pos in positions)

        if self.text_anchor == &#34;middle&#34;:
            return self.x - (min_x + max_x) / 2.0
        if self.text_anchor == &#34;end&#34;:
            return self.x - max_x
        return self.x - min_x

    def bounding_box(self, start: Point) -&gt; tuple[&#34;BoundingBox&#34;, Point]:
        &#34;&#34;&#34;
        Compute a conservative bbox for the text.

        Font metrics are not available at this stage so the layout relies on
        approximate glyph widths proportional to the run font size. The actual
        layout is computed precisely in render().
        &#34;&#34;&#34;
        if not self.text_runs:
            return BoundingBox.empty(), start

        positions, _ = self._approximate_layout()
        anchor_offset = self._anchor_offset(positions)

        min_x = float(&#34;inf&#34;)
        max_x = float(&#34;-inf&#34;)
        min_y = float(&#34;inf&#34;)
        max_y = float(&#34;-inf&#34;)

        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):
            adj_x = run_x + anchor_offset
            asc = 0.8 * run.size
            desc = 0.2 * run.size
            min_x = min(min_x, adj_x)
            max_x = max(max_x, adj_x + run_width)
            min_y = min(min_y, run_y - asc)
            max_y = max(max_y, run_y + desc)

        if min_x == float(&#34;inf&#34;):
            return BoundingBox.empty(), start

        x0 = min_x
        x1 = max_x
        y0 = min_y
        y1 = max_y

        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: &#34;GraphicsStyle&#34;,
        last_item: &#34;Renderable&#34;,
        initial_point: Point,
    ) -&gt; tuple[str, &#34;Renderable&#34;, Point]:
        &#34;&#34;&#34;
        Emit PDF text operators:

          BT
            &lt;font_id&gt; &lt;font_size&gt; Tf
            Tr &lt;mode&gt;               (map from GraphicsStyle-&gt;PathPaintRule)
            1 0 0 1 x y Tm
            (escaped-text) Tj
          ET
        &#34;&#34;&#34;
        if not self.text_runs:
            return &#34;&#34;, last_item, initial_point

        # Precise layout resolution with actual font metrics
        layout: list[tuple[float, float, float, TextRun, object]] = []
        pen_x = self.x
        pen_y = self.y
        min_x = pen_x
        max_x = pen_x

        for run in self.text_runs:
            font = resource_registry.get_font_from_family(run.family, run.emphasis)
            _, width = font.get_text_width(run.text, run.size, None)
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            min_x = min(min_x, pen_x)
            max_x = max(max_x, pen_x + width)
            layout.append((pen_x, pen_y, width, run, font))
            pen_x += width

        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)

        if layout and not has_absolute:
            if self.text_anchor == &#34;middle&#34;:
                anchor_offset = self.x - (min_x + max_x) / 2.0
            elif self.text_anchor == &#34;end&#34;:
                anchor_offset = self.x - max_x
            else:
                anchor_offset = self.x - min_x
        else:
            anchor_offset = 0.0

        ops: list[str] = []
        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)

        for run_x, run_y, width, run, font in layout:
            effective_style = (
                GraphicsStyle.merge(style, run.run_style)
                if run.run_style is not None
                else style
            )

            # Determine text rendering mode
            rule = effective_style.resolve_paint_rule()
            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):
                tr = 0
            elif rule is PathPaintRule.STROKE:
                tr = 1
            elif rule in (
                PathPaintRule.STROKE_FILL_NONZERO,
                PathPaintRule.STROKE_FILL_EVENODD,
            ):
                tr = 2
            else:  # PathPaintRule.DONT_PAINT:
                tr = 3

            run_ops: list[str] = []

            if run.run_style is not None:
                merged_style = effective_style
                style_dict_name = resource_registry.register_graphics_style(
                    merged_style
                )

                if style_dict_name is not None:
                    run_ops.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

                fill_color = merged_style.fill_color
                stroke_color = merged_style.stroke_color

                run_bbox = BoundingBox.from_points(
                    [
                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),
                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),
                    ]
                )

                if fill_color not in NO_EMIT_SET:
                    if isinstance(fill_color, GradientPaint):
                        run_ops.append(
                            fill_color.emit_fill(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(fill_color.serialize().lower())
                if stroke_color not in NO_EMIT_SET:
                    if isinstance(stroke_color, GradientPaint):
                        run_ops.append(
                            stroke_color.emit_stroke(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(stroke_color.serialize().upper())

                dash_pattern = merged_style.stroke_dash_pattern
                dash_phase = merged_style.stroke_dash_phase
                if dash_pattern not in NO_EMIT_SET:
                    run_ops.append(
                        render_pdf_primitive(dash_pattern)
                        + f&#34; {number_to_str(dash_phase)} d&#34;
                    )

            run_ops.extend(
                [
                    &#34;BT&#34;,
                    f&#34;/F{font.i} {number_to_str(run.size)} Tf&#34;,
                    f&#34;{number_to_str(tr)} Tr&#34;,
                    f&#34;1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm&#34;,
                    font.encode_text(run.text),
                    &#34;ET&#34;,
                ]
            )

            if run.run_style is not None:
                run_ops = [&#34;q&#34;] + run_ops + [&#34;Q&#34;]

            ops.extend(run_ops)

        return &#34; &#34;.join(ops), last_item, initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)
        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.drawing.Text.text_runs"><code class="name">var <span class="ident">text_runs</span> : tuple[<a title="fpdf.drawing.TextRun" href="#fpdf.drawing.TextRun">TextRun</a>, ...]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2787-L3035" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Text(NamedTuple):
    &#34;&#34;&#34;
    SVG-like text renderable.
    Stores the anchor position (x, y) and one or more TextRuns that include
    relative positioning offsets. Accurate glyph positioning is resolved
    during rendering once font metrics are available.
    &#34;&#34;&#34;

    x: float
    y: float
    text_runs: tuple[TextRun, ...]
    text_anchor: str = &#34;start&#34;  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;

    def _approximate_layout(self) -&gt; tuple[list[tuple[float, float, float]], float]:
        &#34;&#34;&#34;
        Produce an approximate layout for bounding-box estimation.

        Returns:
            A tuple of (per-run layout list, total width estimate).  Each layout
            entry is (x, y, width) in user space.
        &#34;&#34;&#34;
        positions: list[tuple[float, float, float]] = []
        pen_x = self.x
        pen_y = self.y
        max_right = pen_x
        min_left = pen_x

        for run in self.text_runs:
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            # Fallback width estimation: ~0.5em per glyph
            approx_width = 0.5 * run.size * max(0, len(run.text))
            positions.append((pen_x, pen_y, approx_width))
            min_left = min(min_left, pen_x)
            max_right = max(max_right, pen_x + approx_width)
            pen_x += approx_width

        total_width = max_right - min_left
        return positions, total_width

    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -&gt; float:
        &#34;&#34;&#34;Compute anchor offset for the provided approximate layout.&#34;&#34;&#34;
        if not positions:
            return 0.0

        if any(run.abs_x is not None for run in self.text_runs):
            return 0.0

        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] + pos[2] for pos in positions)

        if self.text_anchor == &#34;middle&#34;:
            return self.x - (min_x + max_x) / 2.0
        if self.text_anchor == &#34;end&#34;:
            return self.x - max_x
        return self.x - min_x

    def bounding_box(self, start: Point) -&gt; tuple[&#34;BoundingBox&#34;, Point]:
        &#34;&#34;&#34;
        Compute a conservative bbox for the text.

        Font metrics are not available at this stage so the layout relies on
        approximate glyph widths proportional to the run font size. The actual
        layout is computed precisely in render().
        &#34;&#34;&#34;
        if not self.text_runs:
            return BoundingBox.empty(), start

        positions, _ = self._approximate_layout()
        anchor_offset = self._anchor_offset(positions)

        min_x = float(&#34;inf&#34;)
        max_x = float(&#34;-inf&#34;)
        min_y = float(&#34;inf&#34;)
        max_y = float(&#34;-inf&#34;)

        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):
            adj_x = run_x + anchor_offset
            asc = 0.8 * run.size
            desc = 0.2 * run.size
            min_x = min(min_x, adj_x)
            max_x = max(max_x, adj_x + run_width)
            min_y = min(min_y, run_y - asc)
            max_y = max(max_y, run_y + desc)

        if min_x == float(&#34;inf&#34;):
            return BoundingBox.empty(), start

        x0 = min_x
        x1 = max_x
        y0 = min_y
        y1 = max_y

        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: &#34;GraphicsStyle&#34;,
        last_item: &#34;Renderable&#34;,
        initial_point: Point,
    ) -&gt; tuple[str, &#34;Renderable&#34;, Point]:
        &#34;&#34;&#34;
        Emit PDF text operators:

          BT
            &lt;font_id&gt; &lt;font_size&gt; Tf
            Tr &lt;mode&gt;               (map from GraphicsStyle-&gt;PathPaintRule)
            1 0 0 1 x y Tm
            (escaped-text) Tj
          ET
        &#34;&#34;&#34;
        if not self.text_runs:
            return &#34;&#34;, last_item, initial_point

        # Precise layout resolution with actual font metrics
        layout: list[tuple[float, float, float, TextRun, object]] = []
        pen_x = self.x
        pen_y = self.y
        min_x = pen_x
        max_x = pen_x

        for run in self.text_runs:
            font = resource_registry.get_font_from_family(run.family, run.emphasis)
            _, width = font.get_text_width(run.text, run.size, None)
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            min_x = min(min_x, pen_x)
            max_x = max(max_x, pen_x + width)
            layout.append((pen_x, pen_y, width, run, font))
            pen_x += width

        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)

        if layout and not has_absolute:
            if self.text_anchor == &#34;middle&#34;:
                anchor_offset = self.x - (min_x + max_x) / 2.0
            elif self.text_anchor == &#34;end&#34;:
                anchor_offset = self.x - max_x
            else:
                anchor_offset = self.x - min_x
        else:
            anchor_offset = 0.0

        ops: list[str] = []
        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)

        for run_x, run_y, width, run, font in layout:
            effective_style = (
                GraphicsStyle.merge(style, run.run_style)
                if run.run_style is not None
                else style
            )

            # Determine text rendering mode
            rule = effective_style.resolve_paint_rule()
            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):
                tr = 0
            elif rule is PathPaintRule.STROKE:
                tr = 1
            elif rule in (
                PathPaintRule.STROKE_FILL_NONZERO,
                PathPaintRule.STROKE_FILL_EVENODD,
            ):
                tr = 2
            else:  # PathPaintRule.DONT_PAINT:
                tr = 3

            run_ops: list[str] = []

            if run.run_style is not None:
                merged_style = effective_style
                style_dict_name = resource_registry.register_graphics_style(
                    merged_style
                )

                if style_dict_name is not None:
                    run_ops.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

                fill_color = merged_style.fill_color
                stroke_color = merged_style.stroke_color

                run_bbox = BoundingBox.from_points(
                    [
                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),
                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),
                    ]
                )

                if fill_color not in NO_EMIT_SET:
                    if isinstance(fill_color, GradientPaint):
                        run_ops.append(
                            fill_color.emit_fill(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(fill_color.serialize().lower())
                if stroke_color not in NO_EMIT_SET:
                    if isinstance(stroke_color, GradientPaint):
                        run_ops.append(
                            stroke_color.emit_stroke(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(stroke_color.serialize().upper())

                dash_pattern = merged_style.stroke_dash_pattern
                dash_phase = merged_style.stroke_dash_phase
                if dash_pattern not in NO_EMIT_SET:
                    run_ops.append(
                        render_pdf_primitive(dash_pattern)
                        + f&#34; {number_to_str(dash_phase)} d&#34;
                    )

            run_ops.extend(
                [
                    &#34;BT&#34;,
                    f&#34;/F{font.i} {number_to_str(run.size)} Tf&#34;,
                    f&#34;{number_to_str(tr)} Tr&#34;,
                    f&#34;1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm&#34;,
                    font.encode_text(run.text),
                    &#34;ET&#34;,
                ]
            )

            if run.run_style is not None:
                run_ops = [&#34;q&#34;] + run_ops + [&#34;Q&#34;]

            ops.extend(run_ops)

        return &#34; &#34;.join(ops), last_item, initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)
        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.drawing.Text.x"><code class="name">var <span class="ident">x</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2787-L3035" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Text(NamedTuple):
    &#34;&#34;&#34;
    SVG-like text renderable.
    Stores the anchor position (x, y) and one or more TextRuns that include
    relative positioning offsets. Accurate glyph positioning is resolved
    during rendering once font metrics are available.
    &#34;&#34;&#34;

    x: float
    y: float
    text_runs: tuple[TextRun, ...]
    text_anchor: str = &#34;start&#34;  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;

    def _approximate_layout(self) -&gt; tuple[list[tuple[float, float, float]], float]:
        &#34;&#34;&#34;
        Produce an approximate layout for bounding-box estimation.

        Returns:
            A tuple of (per-run layout list, total width estimate).  Each layout
            entry is (x, y, width) in user space.
        &#34;&#34;&#34;
        positions: list[tuple[float, float, float]] = []
        pen_x = self.x
        pen_y = self.y
        max_right = pen_x
        min_left = pen_x

        for run in self.text_runs:
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            # Fallback width estimation: ~0.5em per glyph
            approx_width = 0.5 * run.size * max(0, len(run.text))
            positions.append((pen_x, pen_y, approx_width))
            min_left = min(min_left, pen_x)
            max_right = max(max_right, pen_x + approx_width)
            pen_x += approx_width

        total_width = max_right - min_left
        return positions, total_width

    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -&gt; float:
        &#34;&#34;&#34;Compute anchor offset for the provided approximate layout.&#34;&#34;&#34;
        if not positions:
            return 0.0

        if any(run.abs_x is not None for run in self.text_runs):
            return 0.0

        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] + pos[2] for pos in positions)

        if self.text_anchor == &#34;middle&#34;:
            return self.x - (min_x + max_x) / 2.0
        if self.text_anchor == &#34;end&#34;:
            return self.x - max_x
        return self.x - min_x

    def bounding_box(self, start: Point) -&gt; tuple[&#34;BoundingBox&#34;, Point]:
        &#34;&#34;&#34;
        Compute a conservative bbox for the text.

        Font metrics are not available at this stage so the layout relies on
        approximate glyph widths proportional to the run font size. The actual
        layout is computed precisely in render().
        &#34;&#34;&#34;
        if not self.text_runs:
            return BoundingBox.empty(), start

        positions, _ = self._approximate_layout()
        anchor_offset = self._anchor_offset(positions)

        min_x = float(&#34;inf&#34;)
        max_x = float(&#34;-inf&#34;)
        min_y = float(&#34;inf&#34;)
        max_y = float(&#34;-inf&#34;)

        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):
            adj_x = run_x + anchor_offset
            asc = 0.8 * run.size
            desc = 0.2 * run.size
            min_x = min(min_x, adj_x)
            max_x = max(max_x, adj_x + run_width)
            min_y = min(min_y, run_y - asc)
            max_y = max(max_y, run_y + desc)

        if min_x == float(&#34;inf&#34;):
            return BoundingBox.empty(), start

        x0 = min_x
        x1 = max_x
        y0 = min_y
        y1 = max_y

        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: &#34;GraphicsStyle&#34;,
        last_item: &#34;Renderable&#34;,
        initial_point: Point,
    ) -&gt; tuple[str, &#34;Renderable&#34;, Point]:
        &#34;&#34;&#34;
        Emit PDF text operators:

          BT
            &lt;font_id&gt; &lt;font_size&gt; Tf
            Tr &lt;mode&gt;               (map from GraphicsStyle-&gt;PathPaintRule)
            1 0 0 1 x y Tm
            (escaped-text) Tj
          ET
        &#34;&#34;&#34;
        if not self.text_runs:
            return &#34;&#34;, last_item, initial_point

        # Precise layout resolution with actual font metrics
        layout: list[tuple[float, float, float, TextRun, object]] = []
        pen_x = self.x
        pen_y = self.y
        min_x = pen_x
        max_x = pen_x

        for run in self.text_runs:
            font = resource_registry.get_font_from_family(run.family, run.emphasis)
            _, width = font.get_text_width(run.text, run.size, None)
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            min_x = min(min_x, pen_x)
            max_x = max(max_x, pen_x + width)
            layout.append((pen_x, pen_y, width, run, font))
            pen_x += width

        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)

        if layout and not has_absolute:
            if self.text_anchor == &#34;middle&#34;:
                anchor_offset = self.x - (min_x + max_x) / 2.0
            elif self.text_anchor == &#34;end&#34;:
                anchor_offset = self.x - max_x
            else:
                anchor_offset = self.x - min_x
        else:
            anchor_offset = 0.0

        ops: list[str] = []
        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)

        for run_x, run_y, width, run, font in layout:
            effective_style = (
                GraphicsStyle.merge(style, run.run_style)
                if run.run_style is not None
                else style
            )

            # Determine text rendering mode
            rule = effective_style.resolve_paint_rule()
            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):
                tr = 0
            elif rule is PathPaintRule.STROKE:
                tr = 1
            elif rule in (
                PathPaintRule.STROKE_FILL_NONZERO,
                PathPaintRule.STROKE_FILL_EVENODD,
            ):
                tr = 2
            else:  # PathPaintRule.DONT_PAINT:
                tr = 3

            run_ops: list[str] = []

            if run.run_style is not None:
                merged_style = effective_style
                style_dict_name = resource_registry.register_graphics_style(
                    merged_style
                )

                if style_dict_name is not None:
                    run_ops.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

                fill_color = merged_style.fill_color
                stroke_color = merged_style.stroke_color

                run_bbox = BoundingBox.from_points(
                    [
                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),
                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),
                    ]
                )

                if fill_color not in NO_EMIT_SET:
                    if isinstance(fill_color, GradientPaint):
                        run_ops.append(
                            fill_color.emit_fill(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(fill_color.serialize().lower())
                if stroke_color not in NO_EMIT_SET:
                    if isinstance(stroke_color, GradientPaint):
                        run_ops.append(
                            stroke_color.emit_stroke(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(stroke_color.serialize().upper())

                dash_pattern = merged_style.stroke_dash_pattern
                dash_phase = merged_style.stroke_dash_phase
                if dash_pattern not in NO_EMIT_SET:
                    run_ops.append(
                        render_pdf_primitive(dash_pattern)
                        + f&#34; {number_to_str(dash_phase)} d&#34;
                    )

            run_ops.extend(
                [
                    &#34;BT&#34;,
                    f&#34;/F{font.i} {number_to_str(run.size)} Tf&#34;,
                    f&#34;{number_to_str(tr)} Tr&#34;,
                    f&#34;1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm&#34;,
                    font.encode_text(run.text),
                    &#34;ET&#34;,
                ]
            )

            if run.run_style is not None:
                run_ops = [&#34;q&#34;] + run_ops + [&#34;Q&#34;]

            ops.extend(run_ops)

        return &#34; &#34;.join(ops), last_item, initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)
        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.drawing.Text.y"><code class="name">var <span class="ident">y</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2787-L3035" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Text(NamedTuple):
    &#34;&#34;&#34;
    SVG-like text renderable.
    Stores the anchor position (x, y) and one or more TextRuns that include
    relative positioning offsets. Accurate glyph positioning is resolved
    during rendering once font metrics are available.
    &#34;&#34;&#34;

    x: float
    y: float
    text_runs: tuple[TextRun, ...]
    text_anchor: str = &#34;start&#34;  # &#34;start&#34; | &#34;middle&#34; | &#34;end&#34;

    def _approximate_layout(self) -&gt; tuple[list[tuple[float, float, float]], float]:
        &#34;&#34;&#34;
        Produce an approximate layout for bounding-box estimation.

        Returns:
            A tuple of (per-run layout list, total width estimate).  Each layout
            entry is (x, y, width) in user space.
        &#34;&#34;&#34;
        positions: list[tuple[float, float, float]] = []
        pen_x = self.x
        pen_y = self.y
        max_right = pen_x
        min_left = pen_x

        for run in self.text_runs:
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            # Fallback width estimation: ~0.5em per glyph
            approx_width = 0.5 * run.size * max(0, len(run.text))
            positions.append((pen_x, pen_y, approx_width))
            min_left = min(min_left, pen_x)
            max_right = max(max_right, pen_x + approx_width)
            pen_x += approx_width

        total_width = max_right - min_left
        return positions, total_width

    def _anchor_offset(self, positions: list[tuple[float, float, float]]) -&gt; float:
        &#34;&#34;&#34;Compute anchor offset for the provided approximate layout.&#34;&#34;&#34;
        if not positions:
            return 0.0

        if any(run.abs_x is not None for run in self.text_runs):
            return 0.0

        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] + pos[2] for pos in positions)

        if self.text_anchor == &#34;middle&#34;:
            return self.x - (min_x + max_x) / 2.0
        if self.text_anchor == &#34;end&#34;:
            return self.x - max_x
        return self.x - min_x

    def bounding_box(self, start: Point) -&gt; tuple[&#34;BoundingBox&#34;, Point]:
        &#34;&#34;&#34;
        Compute a conservative bbox for the text.

        Font metrics are not available at this stage so the layout relies on
        approximate glyph widths proportional to the run font size. The actual
        layout is computed precisely in render().
        &#34;&#34;&#34;
        if not self.text_runs:
            return BoundingBox.empty(), start

        positions, _ = self._approximate_layout()
        anchor_offset = self._anchor_offset(positions)

        min_x = float(&#34;inf&#34;)
        max_x = float(&#34;-inf&#34;)
        min_y = float(&#34;inf&#34;)
        max_y = float(&#34;-inf&#34;)

        for (run_x, run_y, run_width), run in zip(positions, self.text_runs):
            adj_x = run_x + anchor_offset
            asc = 0.8 * run.size
            desc = 0.2 * run.size
            min_x = min(min_x, adj_x)
            max_x = max(max_x, adj_x + run_width)
            min_y = min(min_y, run_y - asc)
            max_y = max(max_y, run_y + desc)

        if min_x == float(&#34;inf&#34;):
            return BoundingBox.empty(), start

        x0 = min_x
        x1 = max_x
        y0 = min_y
        y1 = max_y

        return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: &#34;GraphicsStyle&#34;,
        last_item: &#34;Renderable&#34;,
        initial_point: Point,
    ) -&gt; tuple[str, &#34;Renderable&#34;, Point]:
        &#34;&#34;&#34;
        Emit PDF text operators:

          BT
            &lt;font_id&gt; &lt;font_size&gt; Tf
            Tr &lt;mode&gt;               (map from GraphicsStyle-&gt;PathPaintRule)
            1 0 0 1 x y Tm
            (escaped-text) Tj
          ET
        &#34;&#34;&#34;
        if not self.text_runs:
            return &#34;&#34;, last_item, initial_point

        # Precise layout resolution with actual font metrics
        layout: list[tuple[float, float, float, TextRun, object]] = []
        pen_x = self.x
        pen_y = self.y
        min_x = pen_x
        max_x = pen_x

        for run in self.text_runs:
            font = resource_registry.get_font_from_family(run.family, run.emphasis)
            _, width = font.get_text_width(run.text, run.size, None)
            if run.abs_x is not None:
                pen_x = run.abs_x
            if run.abs_y is not None:
                pen_y = run.abs_y
            pen_x += run.dx
            pen_y += run.dy
            min_x = min(min_x, pen_x)
            max_x = max(max_x, pen_x + width)
            layout.append((pen_x, pen_y, width, run, font))
            pen_x += width

        has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)

        if layout and not has_absolute:
            if self.text_anchor == &#34;middle&#34;:
                anchor_offset = self.x - (min_x + max_x) / 2.0
            elif self.text_anchor == &#34;end&#34;:
                anchor_offset = self.x - max_x
            else:
                anchor_offset = self.x - min_x
        else:
            anchor_offset = 0.0

        ops: list[str] = []
        NO_EMIT_SET = (None, GraphicsStyle.INHERIT)

        for run_x, run_y, width, run, font in layout:
            effective_style = (
                GraphicsStyle.merge(style, run.run_style)
                if run.run_style is not None
                else style
            )

            # Determine text rendering mode
            rule = effective_style.resolve_paint_rule()
            if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):
                tr = 0
            elif rule is PathPaintRule.STROKE:
                tr = 1
            elif rule in (
                PathPaintRule.STROKE_FILL_NONZERO,
                PathPaintRule.STROKE_FILL_EVENODD,
            ):
                tr = 2
            else:  # PathPaintRule.DONT_PAINT:
                tr = 3

            run_ops: list[str] = []

            if run.run_style is not None:
                merged_style = effective_style
                style_dict_name = resource_registry.register_graphics_style(
                    merged_style
                )

                if style_dict_name is not None:
                    run_ops.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

                fill_color = merged_style.fill_color
                stroke_color = merged_style.stroke_color

                run_bbox = BoundingBox.from_points(
                    [
                        Point(run_x + anchor_offset, run_y - 0.8 * run.size),
                        Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),
                    ]
                )

                if fill_color not in NO_EMIT_SET:
                    if isinstance(fill_color, GradientPaint):
                        run_ops.append(
                            fill_color.emit_fill(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(fill_color.serialize().lower())
                if stroke_color not in NO_EMIT_SET:
                    if isinstance(stroke_color, GradientPaint):
                        run_ops.append(
                            stroke_color.emit_stroke(resource_registry, run_bbox)
                        )
                    else:
                        run_ops.append(stroke_color.serialize().upper())

                dash_pattern = merged_style.stroke_dash_pattern
                dash_phase = merged_style.stroke_dash_phase
                if dash_pattern not in NO_EMIT_SET:
                    run_ops.append(
                        render_pdf_primitive(dash_pattern)
                        + f&#34; {number_to_str(dash_phase)} d&#34;
                    )

            run_ops.extend(
                [
                    &#34;BT&#34;,
                    f&#34;/F{font.i} {number_to_str(run.size)} Tf&#34;,
                    f&#34;{number_to_str(tr)} Tr&#34;,
                    f&#34;1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm&#34;,
                    font.encode_text(run.text),
                    &#34;ET&#34;,
                ]
            )

            if run.run_style is not None:
                run_ops = [&#34;q&#34;] + run_ops + [&#34;Q&#34;]

            ops.extend(run_ops)

        return &#34; &#34;.join(ops), last_item, initial_point

    # pylint: disable=unused-argument
    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)
        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Text.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2848-L2884" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[&#34;BoundingBox&#34;, Point]:
    &#34;&#34;&#34;
    Compute a conservative bbox for the text.

    Font metrics are not available at this stage so the layout relies on
    approximate glyph widths proportional to the run font size. The actual
    layout is computed precisely in render().
    &#34;&#34;&#34;
    if not self.text_runs:
        return BoundingBox.empty(), start

    positions, _ = self._approximate_layout()
    anchor_offset = self._anchor_offset(positions)

    min_x = float(&#34;inf&#34;)
    max_x = float(&#34;-inf&#34;)
    min_y = float(&#34;inf&#34;)
    max_y = float(&#34;-inf&#34;)

    for (run_x, run_y, run_width), run in zip(positions, self.text_runs):
        adj_x = run_x + anchor_offset
        asc = 0.8 * run.size
        desc = 0.2 * run.size
        min_x = min(min_x, adj_x)
        max_x = max(max_x, adj_x + run_width)
        min_y = min(min_y, run_y - asc)
        max_y = max(max_y, run_y + desc)

    if min_x == float(&#34;inf&#34;):
        return BoundingBox.empty(), start

    x0 = min_x
    x1 = max_x
    y0 = min_y
    y1 = max_y

    return BoundingBox.from_points([Point(x0, y0), Point(x1, y1)]), start</code></pre>
</details>
<div class="desc"><p>Compute a conservative bbox for the text.</p>
<p>Font metrics are not available at this stage so the layout relies on
approximate glyph widths proportional to the run font size. The actual
layout is computed precisely in render().</p></div>
</dd>
<dt id="fpdf.drawing.Text.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, '<a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>', <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2886-L3024" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: &#34;GraphicsStyle&#34;,
    last_item: &#34;Renderable&#34;,
    initial_point: Point,
) -&gt; tuple[str, &#34;Renderable&#34;, Point]:
    &#34;&#34;&#34;
    Emit PDF text operators:

      BT
        &lt;font_id&gt; &lt;font_size&gt; Tf
        Tr &lt;mode&gt;               (map from GraphicsStyle-&gt;PathPaintRule)
        1 0 0 1 x y Tm
        (escaped-text) Tj
      ET
    &#34;&#34;&#34;
    if not self.text_runs:
        return &#34;&#34;, last_item, initial_point

    # Precise layout resolution with actual font metrics
    layout: list[tuple[float, float, float, TextRun, object]] = []
    pen_x = self.x
    pen_y = self.y
    min_x = pen_x
    max_x = pen_x

    for run in self.text_runs:
        font = resource_registry.get_font_from_family(run.family, run.emphasis)
        _, width = font.get_text_width(run.text, run.size, None)
        if run.abs_x is not None:
            pen_x = run.abs_x
        if run.abs_y is not None:
            pen_y = run.abs_y
        pen_x += run.dx
        pen_y += run.dy
        min_x = min(min_x, pen_x)
        max_x = max(max_x, pen_x + width)
        layout.append((pen_x, pen_y, width, run, font))
        pen_x += width

    has_absolute = any(run.abs_x is not None for _, _, _, run, _ in layout)

    if layout and not has_absolute:
        if self.text_anchor == &#34;middle&#34;:
            anchor_offset = self.x - (min_x + max_x) / 2.0
        elif self.text_anchor == &#34;end&#34;:
            anchor_offset = self.x - max_x
        else:
            anchor_offset = self.x - min_x
    else:
        anchor_offset = 0.0

    ops: list[str] = []
    NO_EMIT_SET = (None, GraphicsStyle.INHERIT)

    for run_x, run_y, width, run, font in layout:
        effective_style = (
            GraphicsStyle.merge(style, run.run_style)
            if run.run_style is not None
            else style
        )

        # Determine text rendering mode
        rule = effective_style.resolve_paint_rule()
        if rule in (PathPaintRule.FILL_NONZERO, PathPaintRule.FILL_EVENODD):
            tr = 0
        elif rule is PathPaintRule.STROKE:
            tr = 1
        elif rule in (
            PathPaintRule.STROKE_FILL_NONZERO,
            PathPaintRule.STROKE_FILL_EVENODD,
        ):
            tr = 2
        else:  # PathPaintRule.DONT_PAINT:
            tr = 3

        run_ops: list[str] = []

        if run.run_style is not None:
            merged_style = effective_style
            style_dict_name = resource_registry.register_graphics_style(
                merged_style
            )

            if style_dict_name is not None:
                run_ops.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

            fill_color = merged_style.fill_color
            stroke_color = merged_style.stroke_color

            run_bbox = BoundingBox.from_points(
                [
                    Point(run_x + anchor_offset, run_y - 0.8 * run.size),
                    Point(run_x + anchor_offset + width, run_y + 0.2 * run.size),
                ]
            )

            if fill_color not in NO_EMIT_SET:
                if isinstance(fill_color, GradientPaint):
                    run_ops.append(
                        fill_color.emit_fill(resource_registry, run_bbox)
                    )
                else:
                    run_ops.append(fill_color.serialize().lower())
            if stroke_color not in NO_EMIT_SET:
                if isinstance(stroke_color, GradientPaint):
                    run_ops.append(
                        stroke_color.emit_stroke(resource_registry, run_bbox)
                    )
                else:
                    run_ops.append(stroke_color.serialize().upper())

            dash_pattern = merged_style.stroke_dash_pattern
            dash_phase = merged_style.stroke_dash_phase
            if dash_pattern not in NO_EMIT_SET:
                run_ops.append(
                    render_pdf_primitive(dash_pattern)
                    + f&#34; {number_to_str(dash_phase)} d&#34;
                )

        run_ops.extend(
            [
                &#34;BT&#34;,
                f&#34;/F{font.i} {number_to_str(run.size)} Tf&#34;,
                f&#34;{number_to_str(tr)} Tr&#34;,
                f&#34;1 0 0 -1 {number_to_str(run_x + anchor_offset)} {number_to_str(run_y)} Tm&#34;,
                font.encode_text(run.text),
                &#34;ET&#34;,
            ]
        )

        if run.run_style is not None:
            run_ops = [&#34;q&#34;] + run_ops + [&#34;Q&#34;]

        ops.extend(run_ops)

    return &#34; &#34;.join(ops), last_item, initial_point</code></pre>
</details>
<div class="desc"><p>Emit PDF text operators:</p>
<p>BT
<font_id> <font_size> Tf
Tr <mode>
(map from GraphicsStyle-&gt;PathPaintRule)
1 0 0 1 x y Tm
(escaped-text) Tj
ET</p></div>
</dd>
<dt id="fpdf.drawing.Text.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L3027-L3035" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(str(self) + &#34;\n&#34;)
    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.TextRun"><code class="flex name class">
<span>class <span class="ident">TextRun</span></span>
<span>(</span><span>text: str,<br>family: str,<br>emphasis: str,<br>size: float,<br>dx: float = 0.0,<br>dy: float = 0.0,<br>abs_x: float | None = None,<br>abs_y: float | None = None,<br>transform: <a title="fpdf.drawing_primitives.Transform" href="drawing_primitives.html#fpdf.drawing_primitives.Transform">Transform</a> | None = None,<br>run_style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>TextRun(text, family, emphasis, size, dx, dy, abs_x, abs_y, transform, run_style)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.TextRun.abs_x"><code class="name">var <span class="ident">abs_x</span> : float | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 6</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.abs_y"><code class="name">var <span class="ident">abs_y</span> : float | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 7</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.dx"><code class="name">var <span class="ident">dx</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.dy"><code class="name">var <span class="ident">dy</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.emphasis"><code class="name">var <span class="ident">emphasis</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.family"><code class="name">var <span class="ident">family</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.run_style"><code class="name">var <span class="ident">run_style</span> : <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 9</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.size"><code class="name">var <span class="ident">size</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.drawing.TextRun.transform"><code class="name">var <span class="ident">transform</span> : <a title="fpdf.drawing_primitives.Transform" href="drawing_primitives.html#fpdf.drawing_primitives.Transform">Transform</a> | None</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L2774-L2784" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class TextRun(NamedTuple):
    text: str
    family: str
    emphasis: str
    size: float
    dx: float = 0.0
    dy: float = 0.0
    abs_x: Optional[float] = None
    abs_y: Optional[float] = None
    transform: Optional[Transform] = None
    run_style: Optional[GraphicsStyle] = None</code></pre>
</details>
<div class="desc"><p>Alias for field number 8</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.VerticalLine"><code class="flex name class">
<span>class <span class="ident">VerticalLine</span></span>
<span>(</span><span>y: int | float | decimal.Decimal)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1475-L1546" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class VerticalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its abscissa from the end of the previous element.

    See: `PaintedPath.vertical_line_to`
    &#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;The ordinate of the vertical line&#39;s end point.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this vertical line.&#34;&#34;&#34;
        end = Point(start.x, float(self.y))
        bbox = BoundingBox.from_points([start, end])
        return bbox, end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x, y=float(self.y))
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `VerticalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>A path line element that takes its abscissa from the end of the previous element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.vertical_line_to" href="#fpdf.drawing.PaintedPath.vertical_line_to">PaintedPath.vertical_line_to()</a></code></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.VerticalLine.y"><code class="name">var <span class="ident">y</span> : int | float | decimal.Decimal</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1475-L1546" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class VerticalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its abscissa from the end of the previous element.

    See: `PaintedPath.vertical_line_to`
    &#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;The ordinate of the vertical line&#39;s end point.&#34;&#34;&#34;

    def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
        &#34;&#34;&#34;Compute the bounding box of this vertical line.&#34;&#34;&#34;
        end = Point(start.x, float(self.y))
        bbox = BoundingBox.from_points([start, end])
        return bbox, end

    @force_nodocument
    def render(
        self,
        resource_registry: &#34;ResourceCatalog&#34;,
        style: GraphicsStyle,
        last_item: Renderable,
        initial_point: Point,
    ) -&gt; tuple[str, Renderable, Point]:
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x, y=float(self.y))
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, resource_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            resource_registry (ResourceCatalog): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `VerticalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            resource_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>The ordinate of the vertical line's end point.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.VerticalLine.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self,<br>start: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[<a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1485-L1489" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def bounding_box(self, start: Point) -&gt; tuple[BoundingBox, Point]:
    &#34;&#34;&#34;Compute the bounding box of this vertical line.&#34;&#34;&#34;
    end = Point(start.x, float(self.y))
    bbox = BoundingBox.from_points([start, end])
    return bbox, end</code></pre>
</details>
<div class="desc"><p>Compute the bounding box of this vertical line.</p></div>
</dd>
<dt id="fpdf.drawing.VerticalLine.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self,<br>resource_registry: ResourceCatalog,<br>style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>,<br>last_item: <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>,<br>initial_point: <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>) ‑> tuple[str, <a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a>, <a title="fpdf.drawing_primitives.Point" href="drawing_primitives.html#fpdf.drawing_primitives.Point">Point</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1491-L1515" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render(
    self,
    resource_registry: &#34;ResourceCatalog&#34;,
    style: GraphicsStyle,
    last_item: Renderable,
    initial_point: Point,
) -&gt; tuple[str, Renderable, Point]:
    &#34;&#34;&#34;
    Render this path element to its PDF representation.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

    Returns:
        a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
        `Line`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    end_point = Point(x=last_item.end_point.x, y=float(self.y))
    return _render_line(end_point), Line(end_point), initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a tuple of <code>(str, new_last_item)</code>, where <code>new_last_item</code> is the resolved
<code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.VerticalLine.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, resource_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/0008e30a9ab03f062a405d002f68bebee003751f/fpdf/drawing.py#L1517-L1546" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">@force_nodocument
def render_debug(
    self, resource_registry, style, last_item, initial_point, debug_stream, pfx
):
    &#34;&#34;&#34;
    Render this path element to its PDF representation and produce debug
    information.

    Args:
        resource_registry (ResourceCatalog): the owner&#39;s graphics state
            dictionary registry.
        style (GraphicsStyle): the current resolved graphics style
        last_item: the previous path element.
        initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
        debug_stream (io.TextIO): the stream to which the debug output should be
            written. This is not guaranteed to be seekable (e.g. it may be stdout or
            stderr).
        pfx (str): the current debug output prefix string (only needed if emitting
            more than one line).

    Returns:
        The same tuple as `VerticalLine.render`.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    rendered, resolved, initial_point = self.render(
        resource_registry, style, last_item, initial_point
    )
    debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

    return rendered, resolved, initial_point</code></pre>
</details>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_registry</code></strong> :&ensp;<code>ResourceCatalog</code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.VerticalLine.render" href="#fpdf.drawing.VerticalLine.render">VerticalLine.render()</a></code>.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.drawing.clone_structure" href="#fpdf.drawing.clone_structure">clone_structure</a></code></li>
<li><code><a title="fpdf.drawing.render_pdf_primitive" href="#fpdf.drawing.render_pdf_primitive">render_pdf_primitive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.drawing.Arc" href="#fpdf.drawing.Arc">Arc</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.Arc.bounding_box" href="#fpdf.drawing.Arc.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Arc.end" href="#fpdf.drawing.Arc.end">end</a></code></li>
<li><code><a title="fpdf.drawing.Arc.large" href="#fpdf.drawing.Arc.large">large</a></code></li>
<li><code><a title="fpdf.drawing.Arc.radii" href="#fpdf.drawing.Arc.radii">radii</a></code></li>
<li><code><a title="fpdf.drawing.Arc.render" href="#fpdf.drawing.Arc.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Arc.render_debug" href="#fpdf.drawing.Arc.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.Arc.rotation" href="#fpdf.drawing.Arc.rotation">rotation</a></code></li>
<li><code><a title="fpdf.drawing.Arc.subdivide_sweep" href="#fpdf.drawing.Arc.subdivide_sweep">subdivide_sweep</a></code></li>
<li><code><a title="fpdf.drawing.Arc.sweep" href="#fpdf.drawing.Arc.sweep">sweep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.BezierCurve.bounding_box" href="#fpdf.drawing.BezierCurve.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.c1" href="#fpdf.drawing.BezierCurve.c1">c1</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.c2" href="#fpdf.drawing.BezierCurve.c2">c2</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.end" href="#fpdf.drawing.BezierCurve.end">end</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.end_point" href="#fpdf.drawing.BezierCurve.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.render" href="#fpdf.drawing.BezierCurve.render">render</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.render_debug" href="#fpdf.drawing.BezierCurve.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.BoundingBox" href="#fpdf.drawing.BoundingBox">BoundingBox</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.BoundingBox.corners" href="#fpdf.drawing.BoundingBox.corners">corners</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.empty" href="#fpdf.drawing.BoundingBox.empty">empty</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.expanded" href="#fpdf.drawing.BoundingBox.expanded">expanded</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.expanded_to_stroke" href="#fpdf.drawing.BoundingBox.expanded_to_stroke">expanded_to_stroke</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.from_points" href="#fpdf.drawing.BoundingBox.from_points">from_points</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.height" href="#fpdf.drawing.BoundingBox.height">height</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.is_valid" href="#fpdf.drawing.BoundingBox.is_valid">is_valid</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.max_distance_to_point" href="#fpdf.drawing.BoundingBox.max_distance_to_point">max_distance_to_point</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.merge" href="#fpdf.drawing.BoundingBox.merge">merge</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.project_interval_on_axis" href="#fpdf.drawing.BoundingBox.project_interval_on_axis">project_interval_on_axis</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.to_pdf_array" href="#fpdf.drawing.BoundingBox.to_pdf_array">to_pdf_array</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.to_tuple" href="#fpdf.drawing.BoundingBox.to_tuple">to_tuple</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.transformed" href="#fpdf.drawing.BoundingBox.transformed">transformed</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.width" href="#fpdf.drawing.BoundingBox.width">width</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.x0" href="#fpdf.drawing.BoundingBox.x0">x0</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.x1" href="#fpdf.drawing.BoundingBox.x1">x1</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.y0" href="#fpdf.drawing.BoundingBox.y0">y0</a></code></li>
<li><code><a title="fpdf.drawing.BoundingBox.y1" href="#fpdf.drawing.BoundingBox.y1">y1</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.ClippingPath.add_path_element" href="#fpdf.drawing.ClippingPath.add_path_element">add_path_element</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.arc_relative" href="#fpdf.drawing.ClippingPath.arc_relative">arc_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.arc_to" href="#fpdf.drawing.ClippingPath.arc_to">arc_to</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.auto_close" href="#fpdf.drawing.ClippingPath.auto_close">auto_close</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.bounding_box" href="#fpdf.drawing.ClippingPath.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.circle" href="#fpdf.drawing.ClippingPath.circle">circle</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.clipping_path" href="#fpdf.drawing.ClippingPath.clipping_path">clipping_path</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.close" href="#fpdf.drawing.ClippingPath.close">close</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.curve_relative" href="#fpdf.drawing.ClippingPath.curve_relative">curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.curve_to" href="#fpdf.drawing.ClippingPath.curve_to">curve_to</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.ellipse" href="#fpdf.drawing.ClippingPath.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.horizontal_line_relative" href="#fpdf.drawing.ClippingPath.horizontal_line_relative">horizontal_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.horizontal_line_to" href="#fpdf.drawing.ClippingPath.horizontal_line_to">horizontal_line_to</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.line_relative" href="#fpdf.drawing.ClippingPath.line_relative">line_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.line_to" href="#fpdf.drawing.ClippingPath.line_to">line_to</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.move_relative" href="#fpdf.drawing.ClippingPath.move_relative">move_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.move_to" href="#fpdf.drawing.ClippingPath.move_to">move_to</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.paint_rule" href="#fpdf.drawing.ClippingPath.paint_rule">paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.quadratic_curve_relative" href="#fpdf.drawing.ClippingPath.quadratic_curve_relative">quadratic_curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.quadratic_curve_to" href="#fpdf.drawing.ClippingPath.quadratic_curve_to">quadratic_curve_to</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.rectangle" href="#fpdf.drawing.ClippingPath.rectangle">rectangle</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.render" href="#fpdf.drawing.ClippingPath.render">render</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.render_debug" href="#fpdf.drawing.ClippingPath.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.style" href="#fpdf.drawing.ClippingPath.style">style</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.text" href="#fpdf.drawing.ClippingPath.text">text</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.transform" href="#fpdf.drawing.ClippingPath.transform">transform</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.transform_group" href="#fpdf.drawing.ClippingPath.transform_group">transform_group</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.vertical_line_relative" href="#fpdf.drawing.ClippingPath.vertical_line_relative">vertical_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.vertical_line_to" href="#fpdf.drawing.ClippingPath.vertical_line_to">vertical_line_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Close" href="#fpdf.drawing.Close">Close</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Close.bounding_box" href="#fpdf.drawing.Close.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Close.render" href="#fpdf.drawing.Close.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Close.render_debug" href="#fpdf.drawing.Close.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.DrawingContext" href="#fpdf.drawing.DrawingContext">DrawingContext</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.DrawingContext.add_item" href="#fpdf.drawing.DrawingContext.add_item">add_item</a></code></li>
<li><code><a title="fpdf.drawing.DrawingContext.render" href="#fpdf.drawing.DrawingContext.render">render</a></code></li>
<li><code><a title="fpdf.drawing.DrawingContext.render_debug" href="#fpdf.drawing.DrawingContext.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Ellipse" href="#fpdf.drawing.Ellipse">Ellipse</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Ellipse.bounding_box" href="#fpdf.drawing.Ellipse.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Ellipse.center" href="#fpdf.drawing.Ellipse.center">center</a></code></li>
<li><code><a title="fpdf.drawing.Ellipse.radii" href="#fpdf.drawing.Ellipse.radii">radii</a></code></li>
<li><code><a title="fpdf.drawing.Ellipse.render" href="#fpdf.drawing.Ellipse.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Ellipse.render_debug" href="#fpdf.drawing.Ellipse.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.GlyphPathPen" href="#fpdf.drawing.GlyphPathPen">GlyphPathPen</a></code></h4>
</li>
<li>
<h4><code><a title="fpdf.drawing.GradientPaint" href="#fpdf.drawing.GradientPaint">GradientPaint</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.GradientPaint.apply_page_ctm" href="#fpdf.drawing.GradientPaint.apply_page_ctm">apply_page_ctm</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.emit_fill" href="#fpdf.drawing.GradientPaint.emit_fill">emit_fill</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.emit_stroke" href="#fpdf.drawing.GradientPaint.emit_stroke">emit_stroke</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.gradient" href="#fpdf.drawing.GradientPaint.gradient">gradient</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.gradient_transform" href="#fpdf.drawing.GradientPaint.gradient_transform">gradient_transform</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.has_alpha" href="#fpdf.drawing.GradientPaint.has_alpha">has_alpha</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.skip_alpha" href="#fpdf.drawing.GradientPaint.skip_alpha">skip_alpha</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.spread_method" href="#fpdf.drawing.GradientPaint.spread_method">spread_method</a></code></li>
<li><code><a title="fpdf.drawing.GradientPaint.units" href="#fpdf.drawing.GradientPaint.units">units</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.GraphicsContext.add_item" href="#fpdf.drawing.GraphicsContext.add_item">add_item</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.bounding_box" href="#fpdf.drawing.GraphicsContext.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.build_render_list" href="#fpdf.drawing.GraphicsContext.build_render_list">build_render_list</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.clipping_path" href="#fpdf.drawing.GraphicsContext.clipping_path">clipping_path</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.merge" href="#fpdf.drawing.GraphicsContext.merge">merge</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.path_items" href="#fpdf.drawing.GraphicsContext.path_items">path_items</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.remove_last_item" href="#fpdf.drawing.GraphicsContext.remove_last_item">remove_last_item</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.render" href="#fpdf.drawing.GraphicsContext.render">render</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.render_debug" href="#fpdf.drawing.GraphicsContext.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.style" href="#fpdf.drawing.GraphicsContext.style">style</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.transform" href="#fpdf.drawing.GraphicsContext.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.GraphicsStyle.BM" href="#fpdf.drawing.GraphicsStyle.BM">BM</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.CA" href="#fpdf.drawing.GraphicsStyle.CA">CA</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.INHERIT" href="#fpdf.drawing.GraphicsStyle.INHERIT">INHERIT</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.LC" href="#fpdf.drawing.GraphicsStyle.LC">LC</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.LJ" href="#fpdf.drawing.GraphicsStyle.LJ">LJ</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.LW" href="#fpdf.drawing.GraphicsStyle.LW">LW</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.MERGE_PROPERTIES" href="#fpdf.drawing.GraphicsStyle.MERGE_PROPERTIES">MERGE_PROPERTIES</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.ML" href="#fpdf.drawing.GraphicsStyle.ML">ML</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.PDF_STYLE_KEYS" href="#fpdf.drawing.GraphicsStyle.PDF_STYLE_KEYS">PDF_STYLE_KEYS</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.SA" href="#fpdf.drawing.GraphicsStyle.SA">SA</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.SMask" href="#fpdf.drawing.GraphicsStyle.SMask">SMask</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.TRANSPARENCY_KEYS" href="#fpdf.drawing.GraphicsStyle.TRANSPARENCY_KEYS">TRANSPARENCY_KEYS</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.allow_transparency" href="#fpdf.drawing.GraphicsStyle.allow_transparency">allow_transparency</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.auto_close" href="#fpdf.drawing.GraphicsStyle.auto_close">auto_close</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.blend_mode" href="#fpdf.drawing.GraphicsStyle.blend_mode">blend_mode</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.ca" href="#fpdf.drawing.GraphicsStyle.ca">ca</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.fill_color" href="#fpdf.drawing.GraphicsStyle.fill_color">fill_color</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.fill_opacity" href="#fpdf.drawing.GraphicsStyle.fill_opacity">fill_opacity</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.intersection_rule" href="#fpdf.drawing.GraphicsStyle.intersection_rule">intersection_rule</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.merge" href="#fpdf.drawing.GraphicsStyle.merge">merge</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.paint_rule" href="#fpdf.drawing.GraphicsStyle.paint_rule">paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.resolve_paint_rule" href="#fpdf.drawing.GraphicsStyle.resolve_paint_rule">resolve_paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.serialize" href="#fpdf.drawing.GraphicsStyle.serialize">serialize</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.soft_mask" href="#fpdf.drawing.GraphicsStyle.soft_mask">soft_mask</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_cap_style" href="#fpdf.drawing.GraphicsStyle.stroke_cap_style">stroke_cap_style</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_color" href="#fpdf.drawing.GraphicsStyle.stroke_color">stroke_color</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_dash_pattern" href="#fpdf.drawing.GraphicsStyle.stroke_dash_pattern">stroke_dash_pattern</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_dash_phase" href="#fpdf.drawing.GraphicsStyle.stroke_dash_phase">stroke_dash_phase</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_join_style" href="#fpdf.drawing.GraphicsStyle.stroke_join_style">stroke_join_style</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_miter_limit" href="#fpdf.drawing.GraphicsStyle.stroke_miter_limit">stroke_miter_limit</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_opacity" href="#fpdf.drawing.GraphicsStyle.stroke_opacity">stroke_opacity</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_width" href="#fpdf.drawing.GraphicsStyle.stroke_width">stroke_width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.HorizontalLine" href="#fpdf.drawing.HorizontalLine">HorizontalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.HorizontalLine.bounding_box" href="#fpdf.drawing.HorizontalLine.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.HorizontalLine.render" href="#fpdf.drawing.HorizontalLine.render">render</a></code></li>
<li><code><a title="fpdf.drawing.HorizontalLine.render_debug" href="#fpdf.drawing.HorizontalLine.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.HorizontalLine.x" href="#fpdf.drawing.HorizontalLine.x">x</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.ImplicitClose" href="#fpdf.drawing.ImplicitClose">ImplicitClose</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.ImplicitClose.bounding_box" href="#fpdf.drawing.ImplicitClose.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.ImplicitClose.render" href="#fpdf.drawing.ImplicitClose.render">render</a></code></li>
<li><code><a title="fpdf.drawing.ImplicitClose.render_debug" href="#fpdf.drawing.ImplicitClose.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Line.bounding_box" href="#fpdf.drawing.Line.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Line.end_point" href="#fpdf.drawing.Line.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.Line.pt" href="#fpdf.drawing.Line.pt">pt</a></code></li>
<li><code><a title="fpdf.drawing.Line.render" href="#fpdf.drawing.Line.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Line.render_debug" href="#fpdf.drawing.Line.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Move" href="#fpdf.drawing.Move">Move</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Move.bounding_box" href="#fpdf.drawing.Move.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Move.end_point" href="#fpdf.drawing.Move.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.Move.pt" href="#fpdf.drawing.Move.pt">pt</a></code></li>
<li><code><a title="fpdf.drawing.Move.render" href="#fpdf.drawing.Move.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Move.render_debug" href="#fpdf.drawing.Move.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.PaintBlendComposite" href="#fpdf.drawing.PaintBlendComposite">PaintBlendComposite</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.PaintBlendComposite.backdrop" href="#fpdf.drawing.PaintBlendComposite.backdrop">backdrop</a></code></li>
<li><code><a title="fpdf.drawing.PaintBlendComposite.blend_mode" href="#fpdf.drawing.PaintBlendComposite.blend_mode">blend_mode</a></code></li>
<li><code><a title="fpdf.drawing.PaintBlendComposite.render" href="#fpdf.drawing.PaintBlendComposite.render">render</a></code></li>
<li><code><a title="fpdf.drawing.PaintBlendComposite.render_debug" href="#fpdf.drawing.PaintBlendComposite.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.PaintBlendComposite.source" href="#fpdf.drawing.PaintBlendComposite.source">source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.PaintComposite" href="#fpdf.drawing.PaintComposite">PaintComposite</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.PaintComposite.render" href="#fpdf.drawing.PaintComposite.render">render</a></code></li>
<li><code><a title="fpdf.drawing.PaintComposite.render_debug" href="#fpdf.drawing.PaintComposite.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.PaintSoftMask" href="#fpdf.drawing.PaintSoftMask">PaintSoftMask</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.PaintSoftMask.alpha_layers_from" href="#fpdf.drawing.PaintSoftMask.alpha_layers_from">alpha_layers_from</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.coverage_white" href="#fpdf.drawing.PaintSoftMask.coverage_white">coverage_white</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.from_AB" href="#fpdf.drawing.PaintSoftMask.from_AB">from_AB</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.get_bounding_box" href="#fpdf.drawing.PaintSoftMask.get_bounding_box">get_bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.get_resource_dictionary" href="#fpdf.drawing.PaintSoftMask.get_resource_dictionary">get_resource_dictionary</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.invert" href="#fpdf.drawing.PaintSoftMask.invert">invert</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.mask_path" href="#fpdf.drawing.PaintSoftMask.mask_path">mask_path</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.matrix" href="#fpdf.drawing.PaintSoftMask.matrix">matrix</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.object_id" href="#fpdf.drawing.PaintSoftMask.object_id">object_id</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.render" href="#fpdf.drawing.PaintSoftMask.render">render</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.resources" href="#fpdf.drawing.PaintSoftMask.resources">resources</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.serialize" href="#fpdf.drawing.PaintSoftMask.serialize">serialize</a></code></li>
<li><code><a title="fpdf.drawing.PaintSoftMask.use_luminosity" href="#fpdf.drawing.PaintSoftMask.use_luminosity">use_luminosity</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.PaintedPath.add_path_element" href="#fpdf.drawing.PaintedPath.add_path_element">add_path_element</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.arc_relative" href="#fpdf.drawing.PaintedPath.arc_relative">arc_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.arc_to" href="#fpdf.drawing.PaintedPath.arc_to">arc_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.auto_close" href="#fpdf.drawing.PaintedPath.auto_close">auto_close</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.bounding_box" href="#fpdf.drawing.PaintedPath.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.circle" href="#fpdf.drawing.PaintedPath.circle">circle</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.clipping_path" href="#fpdf.drawing.PaintedPath.clipping_path">clipping_path</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.close" href="#fpdf.drawing.PaintedPath.close">close</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.curve_relative" href="#fpdf.drawing.PaintedPath.curve_relative">curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.curve_to" href="#fpdf.drawing.PaintedPath.curve_to">curve_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.ellipse" href="#fpdf.drawing.PaintedPath.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.get_graphics_context" href="#fpdf.drawing.PaintedPath.get_graphics_context">get_graphics_context</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.horizontal_line_relative" href="#fpdf.drawing.PaintedPath.horizontal_line_relative">horizontal_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.horizontal_line_to" href="#fpdf.drawing.PaintedPath.horizontal_line_to">horizontal_line_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.line_relative" href="#fpdf.drawing.PaintedPath.line_relative">line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.line_to" href="#fpdf.drawing.PaintedPath.line_to">line_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.move_relative" href="#fpdf.drawing.PaintedPath.move_relative">move_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.move_to" href="#fpdf.drawing.PaintedPath.move_to">move_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.paint_rule" href="#fpdf.drawing.PaintedPath.paint_rule">paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.quadratic_curve_relative" href="#fpdf.drawing.PaintedPath.quadratic_curve_relative">quadratic_curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.quadratic_curve_to" href="#fpdf.drawing.PaintedPath.quadratic_curve_to">quadratic_curve_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.rectangle" href="#fpdf.drawing.PaintedPath.rectangle">rectangle</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.remove_last_path_element" href="#fpdf.drawing.PaintedPath.remove_last_path_element">remove_last_path_element</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.render" href="#fpdf.drawing.PaintedPath.render">render</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.render_debug" href="#fpdf.drawing.PaintedPath.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.style" href="#fpdf.drawing.PaintedPath.style">style</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.text" href="#fpdf.drawing.PaintedPath.text">text</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.transform" href="#fpdf.drawing.PaintedPath.transform">transform</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.transform_group" href="#fpdf.drawing.PaintedPath.transform_group">transform_group</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.vertical_line_relative" href="#fpdf.drawing.PaintedPath.vertical_line_relative">vertical_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.vertical_line_to" href="#fpdf.drawing.PaintedPath.vertical_line_to">vertical_line_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.PathPen" href="#fpdf.drawing.PathPen">PathPen</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.PathPen.arcTo" href="#fpdf.drawing.PathPen.arcTo">arcTo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.QuadraticBezierCurve" href="#fpdf.drawing.QuadraticBezierCurve">QuadraticBezierCurve</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.bounding_box" href="#fpdf.drawing.QuadraticBezierCurve.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.ctrl" href="#fpdf.drawing.QuadraticBezierCurve.ctrl">ctrl</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.end" href="#fpdf.drawing.QuadraticBezierCurve.end">end</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.end_point" href="#fpdf.drawing.QuadraticBezierCurve.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.render" href="#fpdf.drawing.QuadraticBezierCurve.render">render</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.render_debug" href="#fpdf.drawing.QuadraticBezierCurve.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.to_cubic_curve" href="#fpdf.drawing.QuadraticBezierCurve.to_cubic_curve">to_cubic_curve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Rectangle" href="#fpdf.drawing.Rectangle">Rectangle</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Rectangle.bounding_box" href="#fpdf.drawing.Rectangle.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Rectangle.org" href="#fpdf.drawing.Rectangle.org">org</a></code></li>
<li><code><a title="fpdf.drawing.Rectangle.render" href="#fpdf.drawing.Rectangle.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Rectangle.render_debug" href="#fpdf.drawing.Rectangle.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.Rectangle.size" href="#fpdf.drawing.Rectangle.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeArc" href="#fpdf.drawing.RelativeArc">RelativeArc</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.RelativeArc.bounding_box" href="#fpdf.drawing.RelativeArc.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.end" href="#fpdf.drawing.RelativeArc.end">end</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.large" href="#fpdf.drawing.RelativeArc.large">large</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.radii" href="#fpdf.drawing.RelativeArc.radii">radii</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.render" href="#fpdf.drawing.RelativeArc.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.render_debug" href="#fpdf.drawing.RelativeArc.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.rotation" href="#fpdf.drawing.RelativeArc.rotation">rotation</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.sweep" href="#fpdf.drawing.RelativeArc.sweep">sweep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeBezierCurve" href="#fpdf.drawing.RelativeBezierCurve">RelativeBezierCurve</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.RelativeBezierCurve.bounding_box" href="#fpdf.drawing.RelativeBezierCurve.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.c1" href="#fpdf.drawing.RelativeBezierCurve.c1">c1</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.c2" href="#fpdf.drawing.RelativeBezierCurve.c2">c2</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.end" href="#fpdf.drawing.RelativeBezierCurve.end">end</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.render" href="#fpdf.drawing.RelativeBezierCurve.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.render_debug" href="#fpdf.drawing.RelativeBezierCurve.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeHorizontalLine" href="#fpdf.drawing.RelativeHorizontalLine">RelativeHorizontalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeHorizontalLine.bounding_box" href="#fpdf.drawing.RelativeHorizontalLine.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeHorizontalLine.render" href="#fpdf.drawing.RelativeHorizontalLine.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeHorizontalLine.render_debug" href="#fpdf.drawing.RelativeHorizontalLine.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.RelativeHorizontalLine.x" href="#fpdf.drawing.RelativeHorizontalLine.x">x</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeLine" href="#fpdf.drawing.RelativeLine">RelativeLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeLine.bounding_box" href="#fpdf.drawing.RelativeLine.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeLine.pt" href="#fpdf.drawing.RelativeLine.pt">pt</a></code></li>
<li><code><a title="fpdf.drawing.RelativeLine.render" href="#fpdf.drawing.RelativeLine.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeLine.render_debug" href="#fpdf.drawing.RelativeLine.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeMove" href="#fpdf.drawing.RelativeMove">RelativeMove</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeMove.bounding_box" href="#fpdf.drawing.RelativeMove.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeMove.pt" href="#fpdf.drawing.RelativeMove.pt">pt</a></code></li>
<li><code><a title="fpdf.drawing.RelativeMove.render" href="#fpdf.drawing.RelativeMove.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeMove.render_debug" href="#fpdf.drawing.RelativeMove.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve" href="#fpdf.drawing.RelativeQuadraticBezierCurve">RelativeQuadraticBezierCurve</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.bounding_box" href="#fpdf.drawing.RelativeQuadraticBezierCurve.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.ctrl" href="#fpdf.drawing.RelativeQuadraticBezierCurve.ctrl">ctrl</a></code></li>
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.end" href="#fpdf.drawing.RelativeQuadraticBezierCurve.end">end</a></code></li>
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.render" href="#fpdf.drawing.RelativeQuadraticBezierCurve.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.render_debug" href="#fpdf.drawing.RelativeQuadraticBezierCurve.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeVerticalLine" href="#fpdf.drawing.RelativeVerticalLine">RelativeVerticalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeVerticalLine.bounding_box" href="#fpdf.drawing.RelativeVerticalLine.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RelativeVerticalLine.render" href="#fpdf.drawing.RelativeVerticalLine.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RelativeVerticalLine.render_debug" href="#fpdf.drawing.RelativeVerticalLine.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.RelativeVerticalLine.y" href="#fpdf.drawing.RelativeVerticalLine.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Renderable" href="#fpdf.drawing.Renderable">Renderable</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Renderable.bounding_box" href="#fpdf.drawing.Renderable.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Renderable.render" href="#fpdf.drawing.Renderable.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RoundedRectangle" href="#fpdf.drawing.RoundedRectangle">RoundedRectangle</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.RoundedRectangle.bounding_box" href="#fpdf.drawing.RoundedRectangle.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.corner_radii" href="#fpdf.drawing.RoundedRectangle.corner_radii">corner_radii</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.org" href="#fpdf.drawing.RoundedRectangle.org">org</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.render" href="#fpdf.drawing.RoundedRectangle.render">render</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.render_debug" href="#fpdf.drawing.RoundedRectangle.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.size" href="#fpdf.drawing.RoundedRectangle.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Text" href="#fpdf.drawing.Text">Text</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.Text.bounding_box" href="#fpdf.drawing.Text.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.Text.render" href="#fpdf.drawing.Text.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Text.render_debug" href="#fpdf.drawing.Text.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.Text.text_anchor" href="#fpdf.drawing.Text.text_anchor">text_anchor</a></code></li>
<li><code><a title="fpdf.drawing.Text.text_runs" href="#fpdf.drawing.Text.text_runs">text_runs</a></code></li>
<li><code><a title="fpdf.drawing.Text.x" href="#fpdf.drawing.Text.x">x</a></code></li>
<li><code><a title="fpdf.drawing.Text.y" href="#fpdf.drawing.Text.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.TextRun" href="#fpdf.drawing.TextRun">TextRun</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.TextRun.abs_x" href="#fpdf.drawing.TextRun.abs_x">abs_x</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.abs_y" href="#fpdf.drawing.TextRun.abs_y">abs_y</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.dx" href="#fpdf.drawing.TextRun.dx">dx</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.dy" href="#fpdf.drawing.TextRun.dy">dy</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.emphasis" href="#fpdf.drawing.TextRun.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.family" href="#fpdf.drawing.TextRun.family">family</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.run_style" href="#fpdf.drawing.TextRun.run_style">run_style</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.size" href="#fpdf.drawing.TextRun.size">size</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.text" href="#fpdf.drawing.TextRun.text">text</a></code></li>
<li><code><a title="fpdf.drawing.TextRun.transform" href="#fpdf.drawing.TextRun.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.VerticalLine" href="#fpdf.drawing.VerticalLine">VerticalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.VerticalLine.bounding_box" href="#fpdf.drawing.VerticalLine.bounding_box">bounding_box</a></code></li>
<li><code><a title="fpdf.drawing.VerticalLine.render" href="#fpdf.drawing.VerticalLine.render">render</a></code></li>
<li><code><a title="fpdf.drawing.VerticalLine.render_debug" href="#fpdf.drawing.VerticalLine.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.VerticalLine.y" href="#fpdf.drawing.VerticalLine.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
